// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 44d26b261f707442adefe32c512410f8ceed57fb
//
// device: STM32F767
// cpu: CM7

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window Watchdog interrupt
    WWDG: InterruptVector = unhandled,
    /// PVD through EXTI line detection
    PVD: InterruptVector = unhandled,
    /// Tamper and TimeStamp interrupts through the
    /// EXTI line
    TAMP_STAMP: InterruptVector = unhandled,
    /// RTC Tamper or TimeStamp /CSS on LSE through
    /// EXTI line 19 interrupts
    RTC_WKUP: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI Line0 interrupt
    EXTI0: InterruptVector = unhandled,
    /// EXTI Line1 interrupt
    EXTI1: InterruptVector = unhandled,
    /// EXTI Line2 interrupt
    EXTI2: InterruptVector = unhandled,
    /// EXTI Line3 interrupt
    EXTI3: InterruptVector = unhandled,
    /// EXTI Line4 interrupt
    EXTI4: InterruptVector = unhandled,
    /// DMA1 Stream0 global interrupt
    DMA1_Stream0: InterruptVector = unhandled,
    /// DMA1 Stream1 global interrupt
    DMA1_Stream1: InterruptVector = unhandled,
    /// DMA1 Stream2 global interrupt
    DMA1_Stream2: InterruptVector = unhandled,
    /// DMA1 Stream3 global interrupt
    DMA1_Stream3: InterruptVector = unhandled,
    /// DMA1 Stream4 global interrupt
    DMA1_Stream4: InterruptVector = unhandled,
    /// DMA1 Stream5 global interrupt
    DMA1_Stream5: InterruptVector = unhandled,
    /// DMA1 Stream6 global interrupt
    DMA1_Stream6: InterruptVector = unhandled,
    /// ADC1 global interrupt
    ADC: InterruptVector = unhandled,
    /// CAN1 TX interrupts
    CAN1_TX: InterruptVector = unhandled,
    /// CAN1 RX0 interrupts
    CAN1_RX0: InterruptVector = unhandled,
    /// CAN1 RX1 interrupts
    CAN1_RX1: InterruptVector = unhandled,
    /// CAN1 SCE interrupt
    CAN1_SCE: InterruptVector = unhandled,
    /// EXTI Line[9:5] interrupts
    EXTI9_5: InterruptVector = unhandled,
    /// TIM1 Break interrupt and TIM9 global
    /// interrupt
    TIM1_BRK_TIM9: InterruptVector = unhandled,
    /// TIM1 Update interrupt and TIM10
    TIM1_UP_TIM10: InterruptVector = unhandled,
    /// TIM1 Trigger and Commutation interrupts and
    /// TIM11 global interrupt
    TIM1_TRG_COM_TIM11: InterruptVector = unhandled,
    /// TIM1 Capture Compare interrupt
    TIM1_CC: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    /// TIM4 global interrupt
    TIM4: InterruptVector = unhandled,
    /// I2C1 event interrupt
    I2C1_EV: InterruptVector = unhandled,
    /// I2C1 error interrupt
    I2C1_ER: InterruptVector = unhandled,
    /// I2C2 event interrupt
    I2C2_EV: InterruptVector = unhandled,
    /// I2C2 error interrupt
    I2C2_ER: InterruptVector = unhandled,
    /// SPI1 global interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt
    USART1: InterruptVector = unhandled,
    /// USART2 global interrupt
    USART2: InterruptVector = unhandled,
    /// USART3 global interrupt
    USART3: InterruptVector = unhandled,
    /// EXTI Line[15:10] interrupts
    EXTI15_10: InterruptVector = unhandled,
    /// RTC alarms through EXTI line 18
    /// interrupts
    RTC_ALARM: InterruptVector = unhandled,
    /// USB On-The-Go FS Wakeup through EXTI line
    /// interrupt
    OTG_FS_WKUP: InterruptVector = unhandled,
    /// TIM8 Break interrupt and TIM12 global
    /// interrupt
    TIM8_BRK_TIM12: InterruptVector = unhandled,
    /// TIM8 Update interrupt and TIM13 global
    /// interrupt
    TIM8_UP_TIM13: InterruptVector = unhandled,
    /// TIM8 Trigger and Commutation interrupts and
    /// TIM14 global interrupt
    TIM8_TRG_COM_TIM14: InterruptVector = unhandled,
    /// TIM8 Capture Compare interrupt
    TIM8_CC: InterruptVector = unhandled,
    /// DMA1 Stream7 global interrupt
    DMA1_Stream7: InterruptVector = unhandled,
    /// FMC global interrupt
    FMC: InterruptVector = unhandled,
    /// SDMMC1 global interrupt
    SDMMC1: InterruptVector = unhandled,
    /// TIM5 global interrupt
    TIM5: InterruptVector = unhandled,
    /// SPI3 global interrupt
    SPI3: InterruptVector = unhandled,
    /// UART4 global interrupt
    UART4: InterruptVector = unhandled,
    /// UART5 global interrupt
    UART5: InterruptVector = unhandled,
    /// TIM6 global interrupt, DAC1 and DAC2 underrun
    /// error interrupt
    TIM6_DAC: InterruptVector = unhandled,
    /// TIM7 global interrupt
    TIM7: InterruptVector = unhandled,
    /// DMA2 Stream0 global interrupt
    DMA2_Stream0: InterruptVector = unhandled,
    /// DMA2 Stream1 global interrupt
    DMA2_Stream1: InterruptVector = unhandled,
    /// DMA2 Stream2 global interrupt
    DMA2_Stream2: InterruptVector = unhandled,
    /// DMA2 Stream3 global interrupt
    DMA2_Stream3: InterruptVector = unhandled,
    /// DMA2 Stream4 global interrupt
    DMA2_Stream4: InterruptVector = unhandled,
    /// Ethernet global interrupt
    ETH: InterruptVector = unhandled,
    /// Ethernet Wakeup through EXTI
    /// line
    ETH_WKUP: InterruptVector = unhandled,
    /// CAN2 TX interrupts
    CAN2_TX: InterruptVector = unhandled,
    /// CAN2 RX0 interrupts
    CAN2_RX0: InterruptVector = unhandled,
    /// CAN2 RX1 interrupts
    CAN2_RX1: InterruptVector = unhandled,
    /// CAN2 SCE interrupt
    CAN2_SCE: InterruptVector = unhandled,
    /// USB On The Go FS global
    /// interrupt
    OTG_FS: InterruptVector = unhandled,
    /// DMA2 Stream5 global interrupt
    DMA2_Stream5: InterruptVector = unhandled,
    /// DMA2 Stream6 global interrupt
    DMA2_Stream6: InterruptVector = unhandled,
    /// DMA2 Stream7 global interrupt
    DMA2_Stream7: InterruptVector = unhandled,
    /// USART6 global interrupt
    USART6: InterruptVector = unhandled,
    /// I2C3 event interrupt
    I2C3_EV: InterruptVector = unhandled,
    /// I2C3 error interrupt
    I2C3_ER: InterruptVector = unhandled,
    /// USB On The Go HS End Point 1 Out global
    /// interrupt
    OTG_HS_EP1_OUT: InterruptVector = unhandled,
    /// USB On The Go HS End Point 1 In global
    /// interrupt
    OTG_HS_EP1_IN: InterruptVector = unhandled,
    /// USB On The Go HS Wakeup through EXTI
    /// interrupt
    OTG_HS_WKUP: InterruptVector = unhandled,
    /// USB On The Go HS global
    /// interrupt
    OTG_HS: InterruptVector = unhandled,
    /// DCMI global interrupt
    DCMI: InterruptVector = unhandled,
    /// CRYP crypto global interrupt
    CRYP: InterruptVector = unhandled,
    /// Hash and Rng global interrupt
    HASH_RNG: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    /// UART7 global interrupt
    UART7: InterruptVector = unhandled,
    /// UART 8 global interrupt
    UART8: InterruptVector = unhandled,
    /// SPI 4 global interrupt
    SPI4: InterruptVector = unhandled,
    /// SPI 5 global interrupt
    SPI5: InterruptVector = unhandled,
    /// SPI 6 global interrupt
    SPI6: InterruptVector = unhandled,
    /// SAI1 global interrupt
    SAI1: InterruptVector = unhandled,
    /// LTDC global interrupt
    LCD_TFT: InterruptVector = unhandled,
    /// LCD-TFT global Error interrupt
    LCD_TFT_1: InterruptVector = unhandled,
    /// DMA2D global interrupt
    DMA2D: InterruptVector = unhandled,
    /// SAI2 global interrupt
    SAI2: InterruptVector = unhandled,
    /// QuadSPI global interrupt
    QuadSPI: InterruptVector = unhandled,
    /// LP Timer1 global interrupt
    LP_Timer1: InterruptVector = unhandled,
    reserved3: u32 = undefined,
    /// I2C4 event interrupt
    I2C4_EV: InterruptVector = unhandled,
    /// I2C4 Error interrupt
    I2C4_ER: InterruptVector = unhandled,
    /// SPDIFRX global interrupt
    SPDIFRX: InterruptVector = unhandled,
    /// DSI host global interrupt
    DSIHOST: InterruptVector = unhandled,
    /// DFSDM1 Filter 0 global interrupt
    DFSDM1_FLT0: InterruptVector = unhandled,
    /// DFSDM1 Filter 1 global interrupt
    DFSDM1_FLT1: InterruptVector = unhandled,
    /// DFSDM1 Filter 2 global interrupt
    DFSDM1_FLT2: InterruptVector = unhandled,
    /// DFSDM1 Filter 3 global interrupt
    DFSDM1_FLT3: InterruptVector = unhandled,
    /// SDMMC2 global interrupt
    SDMMC2: InterruptVector = unhandled,
    /// CAN3 TX interrupt
    CAN3_TX: InterruptVector = unhandled,
    /// CAN3 RX0 interrupt
    CAN3_RX0: InterruptVector = unhandled,
    /// CAN3 RX1 interrupt
    CAN3_RX1: InterruptVector = unhandled,
    /// CAN3 SCE interrupt
    CAN3_SCE: InterruptVector = unhandled,
    /// JPEG global interrupt
    JPEG: InterruptVector = unhandled,
    /// MDIO slave global interrupt
    MDIOS: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };
    };

    /// Random number generator
    pub const RNG = struct {
        pub const base_address = 0x50060800;

        /// address: 0x50060800
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Random number generator
            /// enable
            RNGEN: u1,
            /// Interrupt enable
            IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x0);

        /// address: 0x50060804
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data ready
            DRDY: u1,
            /// Clock error current status
            CECS: u1,
            /// Seed error current status
            SECS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock error interrupt
            /// status
            CEIS: u1,
            /// Seed error interrupt
            /// status
            SEIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x50060808
        /// data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Random data
            RNDATA: u32,
        }), base_address + 0x8);
    };

    /// Hash processor
    pub const HASH = struct {
        pub const base_address = 0x50060400;

        /// address: 0x50060400
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Initialize message digest
            /// calculation
            INIT: u1,
            /// DMA enable
            DMAE: u1,
            /// Data type selection
            DATATYPE: u2,
            /// Mode selection
            MODE: u1,
            /// Algorithm selection
            ALGO0: u1,
            /// Number of words already
            /// pushed
            NBW: u4,
            /// DIN not empty
            DINNE: u1,
            /// Multiple DMA Transfers
            MDMAT: u1,
            reserved2: u1,
            reserved3: u1,
            /// Long key selection
            LKEY: u1,
            reserved4: u1,
            /// ALGO
            ALGO1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x0);

        /// address: 0x50060404
        /// data input register
        pub const DIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data input
            DATAIN: u32,
        }), base_address + 0x4);

        /// address: 0x50060408
        /// start register
        pub const STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of valid bits in the last word of
            /// the message
            NBLW: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Digest calculation
            DCAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x5006040c
        /// digest registers
        pub const HR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H0
            H0: u32,
        }), base_address + 0xc);

        /// address: 0x50060410
        /// digest registers
        pub const HR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H1
            H1: u32,
        }), base_address + 0x10);

        /// address: 0x50060414
        /// digest registers
        pub const HR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H2
            H2: u32,
        }), base_address + 0x14);

        /// address: 0x50060418
        /// digest registers
        pub const HR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H3
            H3: u32,
        }), base_address + 0x18);

        /// address: 0x5006041c
        /// digest registers
        pub const HR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H4
            H4: u32,
        }), base_address + 0x1c);

        /// address: 0x50060420
        /// interrupt enable register
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data input interrupt
            /// enable
            DINIE: u1,
            /// Digest calculation completion interrupt
            /// enable
            DCIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x20);

        /// address: 0x50060424
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data input interrupt
            /// status
            DINIS: u1,
            /// Digest calculation completion interrupt
            /// status
            DCIS: u1,
            /// DMA Status
            DMAS: u1,
            /// Busy bit
            BUSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x24);

        /// address: 0x500604f8
        /// context swap registers
        pub const CSR0 = @intToPtr(*volatile u32, base_address + 0xf8);

        /// address: 0x500604fc
        /// context swap registers
        pub const CSR1 = @intToPtr(*volatile u32, base_address + 0xfc);

        /// address: 0x50060500
        /// context swap registers
        pub const CSR2 = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x50060504
        /// context swap registers
        pub const CSR3 = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x50060508
        /// context swap registers
        pub const CSR4 = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x5006050c
        /// context swap registers
        pub const CSR5 = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x50060510
        /// context swap registers
        pub const CSR6 = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x50060514
        /// context swap registers
        pub const CSR7 = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x50060518
        /// context swap registers
        pub const CSR8 = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x5006051c
        /// context swap registers
        pub const CSR9 = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x50060520
        /// context swap registers
        pub const CSR10 = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0x50060524
        /// context swap registers
        pub const CSR11 = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x50060528
        /// context swap registers
        pub const CSR12 = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x5006052c
        /// context swap registers
        pub const CSR13 = @intToPtr(*volatile u32, base_address + 0x12c);

        /// address: 0x50060530
        /// context swap registers
        pub const CSR14 = @intToPtr(*volatile u32, base_address + 0x130);

        /// address: 0x50060534
        /// context swap registers
        pub const CSR15 = @intToPtr(*volatile u32, base_address + 0x134);

        /// address: 0x50060538
        /// context swap registers
        pub const CSR16 = @intToPtr(*volatile u32, base_address + 0x138);

        /// address: 0x5006053c
        /// context swap registers
        pub const CSR17 = @intToPtr(*volatile u32, base_address + 0x13c);

        /// address: 0x50060540
        /// context swap registers
        pub const CSR18 = @intToPtr(*volatile u32, base_address + 0x140);

        /// address: 0x50060544
        /// context swap registers
        pub const CSR19 = @intToPtr(*volatile u32, base_address + 0x144);

        /// address: 0x50060548
        /// context swap registers
        pub const CSR20 = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x5006054c
        /// context swap registers
        pub const CSR21 = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x50060550
        /// context swap registers
        pub const CSR22 = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x50060554
        /// context swap registers
        pub const CSR23 = @intToPtr(*volatile u32, base_address + 0x154);

        /// address: 0x50060558
        /// context swap registers
        pub const CSR24 = @intToPtr(*volatile u32, base_address + 0x158);

        /// address: 0x5006055c
        /// context swap registers
        pub const CSR25 = @intToPtr(*volatile u32, base_address + 0x15c);

        /// address: 0x50060560
        /// context swap registers
        pub const CSR26 = @intToPtr(*volatile u32, base_address + 0x160);

        /// address: 0x50060564
        /// context swap registers
        pub const CSR27 = @intToPtr(*volatile u32, base_address + 0x164);

        /// address: 0x50060568
        /// context swap registers
        pub const CSR28 = @intToPtr(*volatile u32, base_address + 0x168);

        /// address: 0x5006056c
        /// context swap registers
        pub const CSR29 = @intToPtr(*volatile u32, base_address + 0x16c);

        /// address: 0x50060570
        /// context swap registers
        pub const CSR30 = @intToPtr(*volatile u32, base_address + 0x170);

        /// address: 0x50060574
        /// context swap registers
        pub const CSR31 = @intToPtr(*volatile u32, base_address + 0x174);

        /// address: 0x50060578
        /// context swap registers
        pub const CSR32 = @intToPtr(*volatile u32, base_address + 0x178);

        /// address: 0x5006057c
        /// context swap registers
        pub const CSR33 = @intToPtr(*volatile u32, base_address + 0x17c);

        /// address: 0x50060580
        /// context swap registers
        pub const CSR34 = @intToPtr(*volatile u32, base_address + 0x180);

        /// address: 0x50060584
        /// context swap registers
        pub const CSR35 = @intToPtr(*volatile u32, base_address + 0x184);

        /// address: 0x50060588
        /// context swap registers
        pub const CSR36 = @intToPtr(*volatile u32, base_address + 0x188);

        /// address: 0x5006058c
        /// context swap registers
        pub const CSR37 = @intToPtr(*volatile u32, base_address + 0x18c);

        /// address: 0x50060590
        /// context swap registers
        pub const CSR38 = @intToPtr(*volatile u32, base_address + 0x190);

        /// address: 0x50060594
        /// context swap registers
        pub const CSR39 = @intToPtr(*volatile u32, base_address + 0x194);

        /// address: 0x50060598
        /// context swap registers
        pub const CSR40 = @intToPtr(*volatile u32, base_address + 0x198);

        /// address: 0x5006059c
        /// context swap registers
        pub const CSR41 = @intToPtr(*volatile u32, base_address + 0x19c);

        /// address: 0x500605a0
        /// context swap registers
        pub const CSR42 = @intToPtr(*volatile u32, base_address + 0x1a0);

        /// address: 0x500605a4
        /// context swap registers
        pub const CSR43 = @intToPtr(*volatile u32, base_address + 0x1a4);

        /// address: 0x500605a8
        /// context swap registers
        pub const CSR44 = @intToPtr(*volatile u32, base_address + 0x1a8);

        /// address: 0x500605ac
        /// context swap registers
        pub const CSR45 = @intToPtr(*volatile u32, base_address + 0x1ac);

        /// address: 0x500605b0
        /// context swap registers
        pub const CSR46 = @intToPtr(*volatile u32, base_address + 0x1b0);

        /// address: 0x500605b4
        /// context swap registers
        pub const CSR47 = @intToPtr(*volatile u32, base_address + 0x1b4);

        /// address: 0x500605b8
        /// context swap registers
        pub const CSR48 = @intToPtr(*volatile u32, base_address + 0x1b8);

        /// address: 0x500605bc
        /// context swap registers
        pub const CSR49 = @intToPtr(*volatile u32, base_address + 0x1bc);

        /// address: 0x500605c0
        /// context swap registers
        pub const CSR50 = @intToPtr(*volatile u32, base_address + 0x1c0);

        /// address: 0x500605c4
        /// context swap registers
        pub const CSR51 = @intToPtr(*volatile u32, base_address + 0x1c4);

        /// address: 0x500605c8
        /// context swap registers
        pub const CSR52 = @intToPtr(*volatile u32, base_address + 0x1c8);

        /// address: 0x500605cc
        /// context swap registers
        pub const CSR53 = @intToPtr(*volatile u32, base_address + 0x1cc);

        /// address: 0x50060710
        /// HASH digest register
        pub const HASH_HR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H0
            H0: u32,
        }), base_address + 0x310);

        /// address: 0x50060714
        /// read-only
        pub const HASH_HR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H1
            H1: u32,
        }), base_address + 0x314);

        /// address: 0x50060718
        /// read-only
        pub const HASH_HR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H2
            H2: u32,
        }), base_address + 0x318);

        /// address: 0x5006071c
        /// read-only
        pub const HASH_HR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H3
            H3: u32,
        }), base_address + 0x31c);

        /// address: 0x50060720
        /// read-only
        pub const HASH_HR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H4
            H4: u32,
        }), base_address + 0x320);

        /// address: 0x50060724
        /// read-only
        pub const HASH_HR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H5
            H5: u32,
        }), base_address + 0x324);

        /// address: 0x50060728
        /// read-only
        pub const HASH_HR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H6
            H6: u32,
        }), base_address + 0x328);

        /// address: 0x5006072c
        /// read-only
        pub const HASH_HR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H7
            H7: u32,
        }), base_address + 0x32c);
    };

    /// Cryptographic processor
    pub const CRYP = struct {
        pub const base_address = 0x50060000;

        /// address: 0x50060000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Algorithm direction
            ALGODIR: u1,
            /// Algorithm mode
            ALGOMODE0: u3,
            /// Data type selection
            DATATYPE: u2,
            /// Key size selection (AES mode
            /// only)
            KEYSIZE: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// FIFO flush
            FFLUSH: u1,
            /// Cryptographic processor
            /// enable
            CRYPEN: u1,
            /// GCM_CCMPH
            GCM_CCMPH: u2,
            reserved6: u1,
            /// ALGOMODE
            ALGOMODE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x50060004
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input FIFO empty
            IFEM: u1,
            /// Input FIFO not full
            IFNF: u1,
            /// Output FIFO not empty
            OFNE: u1,
            /// Output FIFO full
            OFFU: u1,
            /// Busy bit
            BUSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x4);

        /// address: 0x50060008
        /// data input register
        pub const DIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data input
            DATAIN: u32,
        }), base_address + 0x8);

        /// address: 0x5006000c
        /// data output register
        pub const DOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data output
            DATAOUT: u32,
        }), base_address + 0xc);

        /// address: 0x50060010
        /// DMA control register
        pub const DMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA input enable
            DIEN: u1,
            /// DMA output enable
            DOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x10);

        /// address: 0x50060014
        /// interrupt mask set/clear
        /// register
        pub const IMSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input FIFO service interrupt
            /// mask
            INIM: u1,
            /// Output FIFO service interrupt
            /// mask
            OUTIM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x50060018
        /// raw interrupt status register
        pub const RISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input FIFO service raw interrupt
            /// status
            INRIS: u1,
            /// Output FIFO service raw interrupt
            /// status
            OUTRIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x18);

        /// address: 0x5006001c
        /// masked interrupt status
        /// register
        pub const MISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input FIFO service masked interrupt
            /// status
            INMIS: u1,
            /// Output FIFO service masked interrupt
            /// status
            OUTMIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1c);

        /// address: 0x50060020
        /// key registers
        pub const K0LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b224
            b224: u1,
            /// b225
            b225: u1,
            /// b226
            b226: u1,
            /// b227
            b227: u1,
            /// b228
            b228: u1,
            /// b229
            b229: u1,
            /// b230
            b230: u1,
            /// b231
            b231: u1,
            /// b232
            b232: u1,
            /// b233
            b233: u1,
            /// b234
            b234: u1,
            /// b235
            b235: u1,
            /// b236
            b236: u1,
            /// b237
            b237: u1,
            /// b238
            b238: u1,
            /// b239
            b239: u1,
            /// b240
            b240: u1,
            /// b241
            b241: u1,
            /// b242
            b242: u1,
            /// b243
            b243: u1,
            /// b244
            b244: u1,
            /// b245
            b245: u1,
            /// b246
            b246: u1,
            /// b247
            b247: u1,
            /// b248
            b248: u1,
            /// b249
            b249: u1,
            /// b250
            b250: u1,
            /// b251
            b251: u1,
            /// b252
            b252: u1,
            /// b253
            b253: u1,
            /// b254
            b254: u1,
            /// b255
            b255: u1,
        }), base_address + 0x20);

        /// address: 0x50060024
        /// key registers
        pub const K0RR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b192
            b192: u1,
            /// b193
            b193: u1,
            /// b194
            b194: u1,
            /// b195
            b195: u1,
            /// b196
            b196: u1,
            /// b197
            b197: u1,
            /// b198
            b198: u1,
            /// b199
            b199: u1,
            /// b200
            b200: u1,
            /// b201
            b201: u1,
            /// b202
            b202: u1,
            /// b203
            b203: u1,
            /// b204
            b204: u1,
            /// b205
            b205: u1,
            /// b206
            b206: u1,
            /// b207
            b207: u1,
            /// b208
            b208: u1,
            /// b209
            b209: u1,
            /// b210
            b210: u1,
            /// b211
            b211: u1,
            /// b212
            b212: u1,
            /// b213
            b213: u1,
            /// b214
            b214: u1,
            /// b215
            b215: u1,
            /// b216
            b216: u1,
            /// b217
            b217: u1,
            /// b218
            b218: u1,
            /// b219
            b219: u1,
            /// b220
            b220: u1,
            /// b221
            b221: u1,
            /// b222
            b222: u1,
            /// b223
            b223: u1,
        }), base_address + 0x24);

        /// address: 0x50060028
        /// key registers
        pub const K1LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b160
            b160: u1,
            /// b161
            b161: u1,
            /// b162
            b162: u1,
            /// b163
            b163: u1,
            /// b164
            b164: u1,
            /// b165
            b165: u1,
            /// b166
            b166: u1,
            /// b167
            b167: u1,
            /// b168
            b168: u1,
            /// b169
            b169: u1,
            /// b170
            b170: u1,
            /// b171
            b171: u1,
            /// b172
            b172: u1,
            /// b173
            b173: u1,
            /// b174
            b174: u1,
            /// b175
            b175: u1,
            /// b176
            b176: u1,
            /// b177
            b177: u1,
            /// b178
            b178: u1,
            /// b179
            b179: u1,
            /// b180
            b180: u1,
            /// b181
            b181: u1,
            /// b182
            b182: u1,
            /// b183
            b183: u1,
            /// b184
            b184: u1,
            /// b185
            b185: u1,
            /// b186
            b186: u1,
            /// b187
            b187: u1,
            /// b188
            b188: u1,
            /// b189
            b189: u1,
            /// b190
            b190: u1,
            /// b191
            b191: u1,
        }), base_address + 0x28);

        /// address: 0x5006002c
        /// key registers
        pub const K1RR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b128
            b128: u1,
            /// b129
            b129: u1,
            /// b130
            b130: u1,
            /// b131
            b131: u1,
            /// b132
            b132: u1,
            /// b133
            b133: u1,
            /// b134
            b134: u1,
            /// b135
            b135: u1,
            /// b136
            b136: u1,
            /// b137
            b137: u1,
            /// b138
            b138: u1,
            /// b139
            b139: u1,
            /// b140
            b140: u1,
            /// b141
            b141: u1,
            /// b142
            b142: u1,
            /// b143
            b143: u1,
            /// b144
            b144: u1,
            /// b145
            b145: u1,
            /// b146
            b146: u1,
            /// b147
            b147: u1,
            /// b148
            b148: u1,
            /// b149
            b149: u1,
            /// b150
            b150: u1,
            /// b151
            b151: u1,
            /// b152
            b152: u1,
            /// b153
            b153: u1,
            /// b154
            b154: u1,
            /// b155
            b155: u1,
            /// b156
            b156: u1,
            /// b157
            b157: u1,
            /// b158
            b158: u1,
            /// b159
            b159: u1,
        }), base_address + 0x2c);

        /// address: 0x50060030
        /// key registers
        pub const K2LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b96
            b96: u1,
            /// b97
            b97: u1,
            /// b98
            b98: u1,
            /// b99
            b99: u1,
            /// b100
            b100: u1,
            /// b101
            b101: u1,
            /// b102
            b102: u1,
            /// b103
            b103: u1,
            /// b104
            b104: u1,
            /// b105
            b105: u1,
            /// b106
            b106: u1,
            /// b107
            b107: u1,
            /// b108
            b108: u1,
            /// b109
            b109: u1,
            /// b110
            b110: u1,
            /// b111
            b111: u1,
            /// b112
            b112: u1,
            /// b113
            b113: u1,
            /// b114
            b114: u1,
            /// b115
            b115: u1,
            /// b116
            b116: u1,
            /// b117
            b117: u1,
            /// b118
            b118: u1,
            /// b119
            b119: u1,
            /// b120
            b120: u1,
            /// b121
            b121: u1,
            /// b122
            b122: u1,
            /// b123
            b123: u1,
            /// b124
            b124: u1,
            /// b125
            b125: u1,
            /// b126
            b126: u1,
            /// b127
            b127: u1,
        }), base_address + 0x30);

        /// address: 0x50060034
        /// key registers
        pub const K2RR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b64
            b64: u1,
            /// b65
            b65: u1,
            /// b66
            b66: u1,
            /// b67
            b67: u1,
            /// b68
            b68: u1,
            /// b69
            b69: u1,
            /// b70
            b70: u1,
            /// b71
            b71: u1,
            /// b72
            b72: u1,
            /// b73
            b73: u1,
            /// b74
            b74: u1,
            /// b75
            b75: u1,
            /// b76
            b76: u1,
            /// b77
            b77: u1,
            /// b78
            b78: u1,
            /// b79
            b79: u1,
            /// b80
            b80: u1,
            /// b81
            b81: u1,
            /// b82
            b82: u1,
            /// b83
            b83: u1,
            /// b84
            b84: u1,
            /// b85
            b85: u1,
            /// b86
            b86: u1,
            /// b87
            b87: u1,
            /// b88
            b88: u1,
            /// b89
            b89: u1,
            /// b90
            b90: u1,
            /// b91
            b91: u1,
            /// b92
            b92: u1,
            /// b93
            b93: u1,
            /// b94
            b94: u1,
            /// b95
            b95: u1,
        }), base_address + 0x34);

        /// address: 0x50060038
        /// key registers
        pub const K3LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b32
            b32: u1,
            /// b33
            b33: u1,
            /// b34
            b34: u1,
            /// b35
            b35: u1,
            /// b36
            b36: u1,
            /// b37
            b37: u1,
            /// b38
            b38: u1,
            /// b39
            b39: u1,
            /// b40
            b40: u1,
            /// b41
            b41: u1,
            /// b42
            b42: u1,
            /// b43
            b43: u1,
            /// b44
            b44: u1,
            /// b45
            b45: u1,
            /// b46
            b46: u1,
            /// b47
            b47: u1,
            /// b48
            b48: u1,
            /// b49
            b49: u1,
            /// b50
            b50: u1,
            /// b51
            b51: u1,
            /// b52
            b52: u1,
            /// b53
            b53: u1,
            /// b54
            b54: u1,
            /// b55
            b55: u1,
            /// b56
            b56: u1,
            /// b57
            b57: u1,
            /// b58
            b58: u1,
            /// b59
            b59: u1,
            /// b60
            b60: u1,
            /// b61
            b61: u1,
            /// b62
            b62: u1,
            /// b63
            b63: u1,
        }), base_address + 0x38);

        /// address: 0x5006003c
        /// key registers
        pub const K3RR = @intToPtr(*volatile Mmio(32, packed struct {
            /// b0
            b0: u1,
            /// b1
            b1: u1,
            /// b2
            b2: u1,
            /// b3
            b3: u1,
            /// b4
            b4: u1,
            /// b5
            b5: u1,
            /// b6
            b6: u1,
            /// b7
            b7: u1,
            /// b8
            b8: u1,
            /// b9
            b9: u1,
            /// b10
            b10: u1,
            /// b11
            b11: u1,
            /// b12
            b12: u1,
            /// b13
            b13: u1,
            /// b14
            b14: u1,
            /// b15
            b15: u1,
            /// b16
            b16: u1,
            /// b17
            b17: u1,
            /// b18
            b18: u1,
            /// b19
            b19: u1,
            /// b20
            b20: u1,
            /// b21
            b21: u1,
            /// b22
            b22: u1,
            /// b23
            b23: u1,
            /// b24
            b24: u1,
            /// b25
            b25: u1,
            /// b26
            b26: u1,
            /// b27
            b27: u1,
            /// b28
            b28: u1,
            /// b29
            b29: u1,
            /// b30
            b30: u1,
            /// b31
            b31: u1,
        }), base_address + 0x3c);

        /// address: 0x50060040
        /// initialization vector
        /// registers
        pub const IV0LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IV31
            IV31: u1,
            /// IV30
            IV30: u1,
            /// IV29
            IV29: u1,
            /// IV28
            IV28: u1,
            /// IV27
            IV27: u1,
            /// IV26
            IV26: u1,
            /// IV25
            IV25: u1,
            /// IV24
            IV24: u1,
            /// IV23
            IV23: u1,
            /// IV22
            IV22: u1,
            /// IV21
            IV21: u1,
            /// IV20
            IV20: u1,
            /// IV19
            IV19: u1,
            /// IV18
            IV18: u1,
            /// IV17
            IV17: u1,
            /// IV16
            IV16: u1,
            /// IV15
            IV15: u1,
            /// IV14
            IV14: u1,
            /// IV13
            IV13: u1,
            /// IV12
            IV12: u1,
            /// IV11
            IV11: u1,
            /// IV10
            IV10: u1,
            /// IV9
            IV9: u1,
            /// IV8
            IV8: u1,
            /// IV7
            IV7: u1,
            /// IV6
            IV6: u1,
            /// IV5
            IV5: u1,
            /// IV4
            IV4: u1,
            /// IV3
            IV3: u1,
            /// IV2
            IV2: u1,
            /// IV1
            IV1: u1,
            /// IV0
            IV0: u1,
        }), base_address + 0x40);

        /// address: 0x50060044
        /// initialization vector
        /// registers
        pub const IV0RR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IV63
            IV63: u1,
            /// IV62
            IV62: u1,
            /// IV61
            IV61: u1,
            /// IV60
            IV60: u1,
            /// IV59
            IV59: u1,
            /// IV58
            IV58: u1,
            /// IV57
            IV57: u1,
            /// IV56
            IV56: u1,
            /// IV55
            IV55: u1,
            /// IV54
            IV54: u1,
            /// IV53
            IV53: u1,
            /// IV52
            IV52: u1,
            /// IV51
            IV51: u1,
            /// IV50
            IV50: u1,
            /// IV49
            IV49: u1,
            /// IV48
            IV48: u1,
            /// IV47
            IV47: u1,
            /// IV46
            IV46: u1,
            /// IV45
            IV45: u1,
            /// IV44
            IV44: u1,
            /// IV43
            IV43: u1,
            /// IV42
            IV42: u1,
            /// IV41
            IV41: u1,
            /// IV40
            IV40: u1,
            /// IV39
            IV39: u1,
            /// IV38
            IV38: u1,
            /// IV37
            IV37: u1,
            /// IV36
            IV36: u1,
            /// IV35
            IV35: u1,
            /// IV34
            IV34: u1,
            /// IV33
            IV33: u1,
            /// IV32
            IV32: u1,
        }), base_address + 0x44);

        /// address: 0x50060048
        /// initialization vector
        /// registers
        pub const IV1LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IV95
            IV95: u1,
            /// IV94
            IV94: u1,
            /// IV93
            IV93: u1,
            /// IV92
            IV92: u1,
            /// IV91
            IV91: u1,
            /// IV90
            IV90: u1,
            /// IV89
            IV89: u1,
            /// IV88
            IV88: u1,
            /// IV87
            IV87: u1,
            /// IV86
            IV86: u1,
            /// IV85
            IV85: u1,
            /// IV84
            IV84: u1,
            /// IV83
            IV83: u1,
            /// IV82
            IV82: u1,
            /// IV81
            IV81: u1,
            /// IV80
            IV80: u1,
            /// IV79
            IV79: u1,
            /// IV78
            IV78: u1,
            /// IV77
            IV77: u1,
            /// IV76
            IV76: u1,
            /// IV75
            IV75: u1,
            /// IV74
            IV74: u1,
            /// IV73
            IV73: u1,
            /// IV72
            IV72: u1,
            /// IV71
            IV71: u1,
            /// IV70
            IV70: u1,
            /// IV69
            IV69: u1,
            /// IV68
            IV68: u1,
            /// IV67
            IV67: u1,
            /// IV66
            IV66: u1,
            /// IV65
            IV65: u1,
            /// IV64
            IV64: u1,
        }), base_address + 0x48);

        /// address: 0x5006004c
        /// initialization vector
        /// registers
        pub const IV1RR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IV127
            IV127: u1,
            /// IV126
            IV126: u1,
            /// IV125
            IV125: u1,
            /// IV124
            IV124: u1,
            /// IV123
            IV123: u1,
            /// IV122
            IV122: u1,
            /// IV121
            IV121: u1,
            /// IV120
            IV120: u1,
            /// IV119
            IV119: u1,
            /// IV118
            IV118: u1,
            /// IV117
            IV117: u1,
            /// IV116
            IV116: u1,
            /// IV115
            IV115: u1,
            /// IV114
            IV114: u1,
            /// IV113
            IV113: u1,
            /// IV112
            IV112: u1,
            /// IV111
            IV111: u1,
            /// IV110
            IV110: u1,
            /// IV109
            IV109: u1,
            /// IV108
            IV108: u1,
            /// IV107
            IV107: u1,
            /// IV106
            IV106: u1,
            /// IV105
            IV105: u1,
            /// IV104
            IV104: u1,
            /// IV103
            IV103: u1,
            /// IV102
            IV102: u1,
            /// IV101
            IV101: u1,
            /// IV100
            IV100: u1,
            /// IV99
            IV99: u1,
            /// IV98
            IV98: u1,
            /// IV97
            IV97: u1,
            /// IV96
            IV96: u1,
        }), base_address + 0x4c);

        /// address: 0x50060050
        /// context swap register
        pub const CSGCMCCM0R = @intToPtr(*volatile u32, base_address + 0x50);

        /// address: 0x50060054
        /// context swap register
        pub const CSGCMCCM1R = @intToPtr(*volatile u32, base_address + 0x54);

        /// address: 0x50060058
        /// context swap register
        pub const CSGCMCCM2R = @intToPtr(*volatile u32, base_address + 0x58);

        /// address: 0x5006005c
        /// context swap register
        pub const CSGCMCCM3R = @intToPtr(*volatile u32, base_address + 0x5c);

        /// address: 0x50060060
        /// context swap register
        pub const CSGCMCCM4R = @intToPtr(*volatile u32, base_address + 0x60);

        /// address: 0x50060064
        /// context swap register
        pub const CSGCMCCM5R = @intToPtr(*volatile u32, base_address + 0x64);

        /// address: 0x50060068
        /// context swap register
        pub const CSGCMCCM6R = @intToPtr(*volatile u32, base_address + 0x68);

        /// address: 0x5006006c
        /// context swap register
        pub const CSGCMCCM7R = @intToPtr(*volatile u32, base_address + 0x6c);

        /// address: 0x50060070
        /// context swap register
        pub const CSGCM0R = @intToPtr(*volatile u32, base_address + 0x70);

        /// address: 0x50060074
        /// context swap register
        pub const CSGCM1R = @intToPtr(*volatile u32, base_address + 0x74);

        /// address: 0x50060078
        /// context swap register
        pub const CSGCM2R = @intToPtr(*volatile u32, base_address + 0x78);

        /// address: 0x5006007c
        /// context swap register
        pub const CSGCM3R = @intToPtr(*volatile u32, base_address + 0x7c);

        /// address: 0x50060080
        /// context swap register
        pub const CSGCM4R = @intToPtr(*volatile u32, base_address + 0x80);

        /// address: 0x50060084
        /// context swap register
        pub const CSGCM5R = @intToPtr(*volatile u32, base_address + 0x84);

        /// address: 0x50060088
        /// context swap register
        pub const CSGCM6R = @intToPtr(*volatile u32, base_address + 0x88);

        /// address: 0x5006008c
        /// context swap register
        pub const CSGCM7R = @intToPtr(*volatile u32, base_address + 0x8c);
    };

    /// Digital camera interface
    pub const DCMI = struct {
        pub const base_address = 0x50050000;

        /// address: 0x50050000
        /// control register 1
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture enable
            CAPTURE: u1,
            /// Capture mode
            CM: u1,
            /// Crop feature
            CROP: u1,
            /// JPEG format
            JPEG: u1,
            /// Embedded synchronization
            /// select
            ESS: u1,
            /// Pixel clock polarity
            PCKPOL: u1,
            /// Horizontal synchronization
            /// polarity
            HSPOL: u1,
            /// Vertical synchronization
            /// polarity
            VSPOL: u1,
            /// Frame capture rate control
            FCRC: u2,
            /// Extended data mode
            EDM: u2,
            reserved0: u1,
            reserved1: u1,
            /// DCMI enable
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x0);

        /// address: 0x50050004
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSYNC
            HSYNC: u1,
            /// VSYNC
            VSYNC: u1,
            /// FIFO not empty
            FNE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x50050008
        /// raw interrupt status register
        pub const RIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture complete raw interrupt
            /// status
            FRAME_RIS: u1,
            /// Overrun raw interrupt
            /// status
            OVR_RIS: u1,
            /// Synchronization error raw interrupt
            /// status
            ERR_RIS: u1,
            /// VSYNC raw interrupt status
            VSYNC_RIS: u1,
            /// Line raw interrupt status
            LINE_RIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x8);

        /// address: 0x5005000c
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture complete interrupt
            /// enable
            FRAME_IE: u1,
            /// Overrun interrupt enable
            OVR_IE: u1,
            /// Synchronization error interrupt
            /// enable
            ERR_IE: u1,
            /// VSYNC interrupt enable
            VSYNC_IE: u1,
            /// Line interrupt enable
            LINE_IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xc);

        /// address: 0x50050010
        /// masked interrupt status
        /// register
        pub const MIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture complete masked interrupt
            /// status
            FRAME_MIS: u1,
            /// Overrun masked interrupt
            /// status
            OVR_MIS: u1,
            /// Synchronization error masked interrupt
            /// status
            ERR_MIS: u1,
            /// VSYNC masked interrupt
            /// status
            VSYNC_MIS: u1,
            /// Line masked interrupt
            /// status
            LINE_MIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x10);

        /// address: 0x50050014
        /// interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture complete interrupt status
            /// clear
            FRAME_ISC: u1,
            /// Overrun interrupt status
            /// clear
            OVR_ISC: u1,
            /// Synchronization error interrupt status
            /// clear
            ERR_ISC: u1,
            /// Vertical synch interrupt status
            /// clear
            VSYNC_ISC: u1,
            /// line interrupt status
            /// clear
            LINE_ISC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x14);

        /// address: 0x50050018
        /// embedded synchronization code
        /// register
        pub const ESCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame start delimiter code
            FSC: u8,
            /// Line start delimiter code
            LSC: u8,
            /// Line end delimiter code
            LEC: u8,
            /// Frame end delimiter code
            FEC: u8,
        }), base_address + 0x18);

        /// address: 0x5005001c
        /// embedded synchronization unmask
        /// register
        pub const ESUR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame start delimiter
            /// unmask
            FSU: u8,
            /// Line start delimiter
            /// unmask
            LSU: u8,
            /// Line end delimiter unmask
            LEU: u8,
            /// Frame end delimiter unmask
            FEU: u8,
        }), base_address + 0x1c);

        /// address: 0x50050020
        /// crop window start
        pub const CWSTRT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal offset count
            HOFFCNT: u14,
            reserved0: u1,
            reserved1: u1,
            /// Vertical start line count
            VST: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x20);

        /// address: 0x50050024
        /// crop window size
        pub const CWSIZE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture count
            CAPCNT: u14,
            reserved0: u1,
            reserved1: u1,
            /// Vertical line count
            VLINE: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x24);

        /// address: 0x50050028
        /// data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            Byte0: u8,
            /// Data byte 1
            Byte1: u8,
            /// Data byte 2
            Byte2: u8,
            /// Data byte 3
            Byte3: u8,
        }), base_address + 0x28);
    };

    /// Flexible memory controller
    pub const FMC = struct {
        pub const base_address = 0xa0000000;

        /// address: 0xa0000000
        /// SRAM/NOR-Flash chip-select control register
        /// 1
        pub const BCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            reserved1: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            /// CCLKEN
            CCLKEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x0);

        /// address: 0xa0000004
        /// SRAM/NOR-Flash chip-select timing register
        /// 1
        pub const BTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0xa0000008
        /// SRAM/NOR-Flash chip-select control register
        /// 2
        pub const BCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x8);

        /// address: 0xa000000c
        /// SRAM/NOR-Flash chip-select timing register
        /// 2
        pub const BTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0xa0000010
        /// SRAM/NOR-Flash chip-select control register
        /// 3
        pub const BCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x10);

        /// address: 0xa0000014
        /// SRAM/NOR-Flash chip-select timing register
        /// 3
        pub const BTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0xa0000018
        /// SRAM/NOR-Flash chip-select control register
        /// 4
        pub const BCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x18);

        /// address: 0xa000001c
        /// SRAM/NOR-Flash chip-select timing register
        /// 4
        pub const BTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x1c);

        /// address: 0xa0000080
        /// PC Card/NAND Flash control
        /// register
        pub const PCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x80);

        /// address: 0xa0000084
        /// FIFO status and interrupt
        /// register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x84);

        /// address: 0xa0000088
        /// Common memory space timing
        /// register
        pub const PMEM = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0x88);

        /// address: 0xa000008c
        /// Attribute memory space timing
        /// register
        pub const PATT = @intToPtr(*volatile Mmio(32, packed struct {
            /// ATTSETx
            ATTSETx: u8,
            /// ATTWAITx
            ATTWAITx: u8,
            /// ATTHOLDx
            ATTHOLDx: u8,
            /// ATTHIZx
            ATTHIZx: u8,
        }), base_address + 0x8c);

        /// address: 0xa0000094
        /// ECC result register
        pub const ECCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECCx
            ECCx: u32,
        }), base_address + 0x94);

        /// address: 0xa0000104
        /// SRAM/NOR-Flash write timing registers
        /// 1
        pub const BWTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x104);

        /// address: 0xa000010c
        /// SRAM/NOR-Flash write timing registers
        /// 2
        pub const BWTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10c);

        /// address: 0xa0000114
        /// SRAM/NOR-Flash write timing registers
        /// 3
        pub const BWTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x114);

        /// address: 0xa000011c
        /// SRAM/NOR-Flash write timing registers
        /// 4
        pub const BWTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x11c);

        /// address: 0xa0000140
        /// SDRAM Control Register 1
        pub const SDCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of column address
            /// bits
            NC: u2,
            /// Number of row address bits
            NR: u2,
            /// Memory data bus width
            MWID: u2,
            /// Number of internal banks
            NB: u1,
            /// CAS latency
            CAS: u2,
            /// Write protection
            WP: u1,
            /// SDRAM clock configuration
            SDCLK: u2,
            /// Burst read
            RBURST: u1,
            /// Read pipe
            RPIPE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x140);

        /// address: 0xa0000144
        /// SDRAM Control Register 2
        pub const SDCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of column address
            /// bits
            NC: u2,
            /// Number of row address bits
            NR: u2,
            /// Memory data bus width
            MWID: u2,
            /// Number of internal banks
            NB: u1,
            /// CAS latency
            CAS: u2,
            /// Write protection
            WP: u1,
            /// SDRAM clock configuration
            SDCLK: u2,
            /// Burst read
            RBURST: u1,
            /// Read pipe
            RPIPE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x144);

        /// address: 0xa0000148
        /// SDRAM Timing register 1
        pub const SDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Load Mode Register to
            /// Active
            TMRD: u4,
            /// Exit self-refresh delay
            TXSR: u4,
            /// Self refresh time
            TRAS: u4,
            /// Row cycle delay
            TRC: u4,
            /// Recovery delay
            TWR: u4,
            /// Row precharge delay
            TRP: u4,
            /// Row to column delay
            TRCD: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x148);

        /// address: 0xa000014c
        /// SDRAM Timing register 2
        pub const SDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Load Mode Register to
            /// Active
            TMRD: u4,
            /// Exit self-refresh delay
            TXSR: u4,
            /// Self refresh time
            TRAS: u4,
            /// Row cycle delay
            TRC: u4,
            /// Recovery delay
            TWR: u4,
            /// Row precharge delay
            TRP: u4,
            /// Row to column delay
            TRCD: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x14c);

        /// address: 0xa0000150
        /// SDRAM Command Mode register
        pub const SDCMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command mode
            MODE: u3,
            /// Command target bank 2
            CTB2: u1,
            /// Command target bank 1
            CTB1: u1,
            /// Number of Auto-refresh
            NRFS: u4,
            /// Mode Register definition
            MRD: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x150);

        /// address: 0xa0000154
        /// SDRAM Refresh Timer register
        pub const SDRTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear Refresh error flag
            CRE: u1,
            /// Refresh Timer Count
            COUNT: u13,
            /// RES Interrupt Enable
            REIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x154);

        /// address: 0xa0000158
        /// SDRAM Status register
        pub const SDSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Refresh error flag
            RE: u1,
            /// Status Mode for Bank 1
            MODES1: u2,
            /// Status Mode for Bank 2
            MODES2: u2,
            /// Busy status
            BUSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x158);
    };

    /// DMA controller
    pub const DMA2 = struct {
        pub const base_address = 0x40026400;

        /// address: 0x40026400
        /// low interrupt status register
        pub const LISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF0: u1,
            reserved0: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF0: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF0: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF0: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF0: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF1: u1,
            reserved1: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF1: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF1: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF1: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF2: u1,
            reserved6: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF2: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF2: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF2: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF2: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF3: u1,
            reserved7: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF3: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF3: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF3: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40026404
        /// high interrupt status register
        pub const HISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF4: u1,
            reserved0: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF4: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF4: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF4: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF4: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF5: u1,
            reserved1: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF5: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF5: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF5: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF5: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF6: u1,
            reserved6: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF6: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF6: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF6: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF6: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF7: u1,
            reserved7: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF7: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF7: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF7: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40026408
        /// low interrupt flag clear
        /// register
        pub const LIFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF0: u1,
            reserved0: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF0: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF0: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF0: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF0: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF1: u1,
            reserved1: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF1: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF1: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF1: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF2: u1,
            reserved6: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF2: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF2: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF2: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF2: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF3: u1,
            reserved7: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF3: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF3: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF3: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x8);

        /// address: 0x4002640c
        /// high interrupt flag clear
        /// register
        pub const HIFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF4: u1,
            reserved0: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF4: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF4: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF4: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF4: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF5: u1,
            reserved1: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF5: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF5: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF5: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF5: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF6: u1,
            reserved6: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF6: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF6: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF6: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF6: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF7: u1,
            reserved7: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF7: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF7: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF7: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x40026410
        /// stream x configuration
        /// register
        pub const S0CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            reserved0: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40026414
        /// stream x number of data
        /// register
        pub const S0NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40026418
        /// stream x peripheral address
        /// register
        pub const S0PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x18);

        /// address: 0x4002641c
        /// stream x memory 0 address
        /// register
        pub const S0M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x1c);

        /// address: 0x40026420
        /// stream x memory 1 address
        /// register
        pub const S0M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x20);

        /// address: 0x40026424
        /// stream x FIFO control register
        pub const S0FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40026428
        /// stream x configuration
        /// register
        pub const S1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x28);

        /// address: 0x4002642c
        /// stream x number of data
        /// register
        pub const S1NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x40026430
        /// stream x peripheral address
        /// register
        pub const S1PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x30);

        /// address: 0x40026434
        /// stream x memory 0 address
        /// register
        pub const S1M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x34);

        /// address: 0x40026438
        /// stream x memory 1 address
        /// register
        pub const S1M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x38);

        /// address: 0x4002643c
        /// stream x FIFO control register
        pub const S1FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x3c);

        /// address: 0x40026440
        /// stream x configuration
        /// register
        pub const S2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x40);

        /// address: 0x40026444
        /// stream x number of data
        /// register
        pub const S2NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40026448
        /// stream x peripheral address
        /// register
        pub const S2PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x48);

        /// address: 0x4002644c
        /// stream x memory 0 address
        /// register
        pub const S2M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x4c);

        /// address: 0x40026450
        /// stream x memory 1 address
        /// register
        pub const S2M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x50);

        /// address: 0x40026454
        /// stream x FIFO control register
        pub const S2FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x54);

        /// address: 0x40026458
        /// stream x configuration
        /// register
        pub const S3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x58);

        /// address: 0x4002645c
        /// stream x number of data
        /// register
        pub const S3NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40026460
        /// stream x peripheral address
        /// register
        pub const S3PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40026464
        /// stream x memory 0 address
        /// register
        pub const S3M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x64);

        /// address: 0x40026468
        /// stream x memory 1 address
        /// register
        pub const S3M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x68);

        /// address: 0x4002646c
        /// stream x FIFO control register
        pub const S3FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x6c);

        /// address: 0x40026470
        /// stream x configuration
        /// register
        pub const S4CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x70);

        /// address: 0x40026474
        /// stream x number of data
        /// register
        pub const S4NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x74);

        /// address: 0x40026478
        /// stream x peripheral address
        /// register
        pub const S4PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x78);

        /// address: 0x4002647c
        /// stream x memory 0 address
        /// register
        pub const S4M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x7c);

        /// address: 0x40026480
        /// stream x memory 1 address
        /// register
        pub const S4M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x80);

        /// address: 0x40026484
        /// stream x FIFO control register
        pub const S4FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x84);

        /// address: 0x40026488
        /// stream x configuration
        /// register
        pub const S5CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x88);

        /// address: 0x4002648c
        /// stream x number of data
        /// register
        pub const S5NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x40026490
        /// stream x peripheral address
        /// register
        pub const S5PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x90);

        /// address: 0x40026494
        /// stream x memory 0 address
        /// register
        pub const S5M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x94);

        /// address: 0x40026498
        /// stream x memory 1 address
        /// register
        pub const S5M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x98);

        /// address: 0x4002649c
        /// stream x FIFO control register
        pub const S5FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x9c);

        /// address: 0x400264a0
        /// stream x configuration
        /// register
        pub const S6CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xa0);

        /// address: 0x400264a4
        /// stream x number of data
        /// register
        pub const S6NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa4);

        /// address: 0x400264a8
        /// stream x peripheral address
        /// register
        pub const S6PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0xa8);

        /// address: 0x400264ac
        /// stream x memory 0 address
        /// register
        pub const S6M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0xac);

        /// address: 0x400264b0
        /// stream x memory 1 address
        /// register
        pub const S6M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0xb0);

        /// address: 0x400264b4
        /// stream x FIFO control register
        pub const S6FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x400264b8
        /// stream x configuration
        /// register
        pub const S7CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xb8);

        /// address: 0x400264bc
        /// stream x number of data
        /// register
        pub const S7NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xbc);

        /// address: 0x400264c0
        /// stream x peripheral address
        /// register
        pub const S7PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0xc0);

        /// address: 0x400264c4
        /// stream x memory 0 address
        /// register
        pub const S7M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0xc4);

        /// address: 0x400264c8
        /// stream x memory 1 address
        /// register
        pub const S7M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0xc8);

        /// address: 0x400264cc
        /// stream x FIFO control register
        pub const S7FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xcc);
    };
    pub const DMA1 = struct {
        pub const base_address = 0x40026000;

        /// address: 0x40026000
        /// low interrupt status register
        pub const LISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF0: u1,
            reserved0: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF0: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF0: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF0: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF0: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF1: u1,
            reserved1: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF1: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF1: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF1: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF2: u1,
            reserved6: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF2: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF2: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF2: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF2: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=3..0)
            FEIF3: u1,
            reserved7: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=3..0)
            DMEIF3: u1,
            /// Stream x transfer error interrupt flag
            /// (x=3..0)
            TEIF3: u1,
            /// Stream x half transfer interrupt flag
            /// (x=3..0)
            HTIF3: u1,
            /// Stream x transfer complete interrupt
            /// flag (x = 3..0)
            TCIF3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40026004
        /// high interrupt status register
        pub const HISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF4: u1,
            reserved0: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF4: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF4: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF4: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF4: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF5: u1,
            reserved1: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF5: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF5: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF5: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF5: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF6: u1,
            reserved6: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF6: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF6: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF6: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF6: u1,
            /// Stream x FIFO error interrupt flag
            /// (x=7..4)
            FEIF7: u1,
            reserved7: u1,
            /// Stream x direct mode error interrupt
            /// flag (x=7..4)
            DMEIF7: u1,
            /// Stream x transfer error interrupt flag
            /// (x=7..4)
            TEIF7: u1,
            /// Stream x half transfer interrupt flag
            /// (x=7..4)
            HTIF7: u1,
            /// Stream x transfer complete interrupt
            /// flag (x=7..4)
            TCIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40026008
        /// low interrupt flag clear
        /// register
        pub const LIFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF0: u1,
            reserved0: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF0: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF0: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF0: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF0: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF1: u1,
            reserved1: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF1: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF1: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF1: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF2: u1,
            reserved6: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF2: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF2: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF2: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF2: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 3..0)
            CFEIF3: u1,
            reserved7: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 3..0)
            CDMEIF3: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 3..0)
            CTEIF3: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 3..0)
            CHTIF3: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 3..0)
            CTCIF3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x8);

        /// address: 0x4002600c
        /// high interrupt flag clear
        /// register
        pub const HIFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF4: u1,
            reserved0: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF4: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF4: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF4: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF4: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF5: u1,
            reserved1: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF5: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF5: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF5: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF5: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF6: u1,
            reserved6: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF6: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF6: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF6: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF6: u1,
            /// Stream x clear FIFO error interrupt flag
            /// (x = 7..4)
            CFEIF7: u1,
            reserved7: u1,
            /// Stream x clear direct mode error
            /// interrupt flag (x = 7..4)
            CDMEIF7: u1,
            /// Stream x clear transfer error interrupt
            /// flag (x = 7..4)
            CTEIF7: u1,
            /// Stream x clear half transfer interrupt
            /// flag (x = 7..4)
            CHTIF7: u1,
            /// Stream x clear transfer complete
            /// interrupt flag (x = 7..4)
            CTCIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x40026010
        /// stream x configuration
        /// register
        pub const S0CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            reserved0: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40026014
        /// stream x number of data
        /// register
        pub const S0NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40026018
        /// stream x peripheral address
        /// register
        pub const S0PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x18);

        /// address: 0x4002601c
        /// stream x memory 0 address
        /// register
        pub const S0M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x1c);

        /// address: 0x40026020
        /// stream x memory 1 address
        /// register
        pub const S0M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x20);

        /// address: 0x40026024
        /// stream x FIFO control register
        pub const S0FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40026028
        /// stream x configuration
        /// register
        pub const S1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x28);

        /// address: 0x4002602c
        /// stream x number of data
        /// register
        pub const S1NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x40026030
        /// stream x peripheral address
        /// register
        pub const S1PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x30);

        /// address: 0x40026034
        /// stream x memory 0 address
        /// register
        pub const S1M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x34);

        /// address: 0x40026038
        /// stream x memory 1 address
        /// register
        pub const S1M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x38);

        /// address: 0x4002603c
        /// stream x FIFO control register
        pub const S1FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x3c);

        /// address: 0x40026040
        /// stream x configuration
        /// register
        pub const S2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x40);

        /// address: 0x40026044
        /// stream x number of data
        /// register
        pub const S2NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40026048
        /// stream x peripheral address
        /// register
        pub const S2PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x48);

        /// address: 0x4002604c
        /// stream x memory 0 address
        /// register
        pub const S2M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x4c);

        /// address: 0x40026050
        /// stream x memory 1 address
        /// register
        pub const S2M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x50);

        /// address: 0x40026054
        /// stream x FIFO control register
        pub const S2FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x54);

        /// address: 0x40026058
        /// stream x configuration
        /// register
        pub const S3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x58);

        /// address: 0x4002605c
        /// stream x number of data
        /// register
        pub const S3NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40026060
        /// stream x peripheral address
        /// register
        pub const S3PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40026064
        /// stream x memory 0 address
        /// register
        pub const S3M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x64);

        /// address: 0x40026068
        /// stream x memory 1 address
        /// register
        pub const S3M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x68);

        /// address: 0x4002606c
        /// stream x FIFO control register
        pub const S3FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x6c);

        /// address: 0x40026070
        /// stream x configuration
        /// register
        pub const S4CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x70);

        /// address: 0x40026074
        /// stream x number of data
        /// register
        pub const S4NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x74);

        /// address: 0x40026078
        /// stream x peripheral address
        /// register
        pub const S4PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x78);

        /// address: 0x4002607c
        /// stream x memory 0 address
        /// register
        pub const S4M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x7c);

        /// address: 0x40026080
        /// stream x memory 1 address
        /// register
        pub const S4M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x80);

        /// address: 0x40026084
        /// stream x FIFO control register
        pub const S4FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x84);

        /// address: 0x40026088
        /// stream x configuration
        /// register
        pub const S5CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x88);

        /// address: 0x4002608c
        /// stream x number of data
        /// register
        pub const S5NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x40026090
        /// stream x peripheral address
        /// register
        pub const S5PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x90);

        /// address: 0x40026094
        /// stream x memory 0 address
        /// register
        pub const S5M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0x94);

        /// address: 0x40026098
        /// stream x memory 1 address
        /// register
        pub const S5M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0x98);

        /// address: 0x4002609c
        /// stream x FIFO control register
        pub const S5FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x9c);

        /// address: 0x400260a0
        /// stream x configuration
        /// register
        pub const S6CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xa0);

        /// address: 0x400260a4
        /// stream x number of data
        /// register
        pub const S6NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa4);

        /// address: 0x400260a8
        /// stream x peripheral address
        /// register
        pub const S6PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0xa8);

        /// address: 0x400260ac
        /// stream x memory 0 address
        /// register
        pub const S6M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0xac);

        /// address: 0x400260b0
        /// stream x memory 1 address
        /// register
        pub const S6M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0xb0);

        /// address: 0x400260b4
        /// stream x FIFO control register
        pub const S6FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x400260b8
        /// stream x configuration
        /// register
        pub const S7CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stream enable / flag stream ready when
            /// read low
            EN: u1,
            /// Direct mode error interrupt
            /// enable
            DMEIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Peripheral flow controller
            PFCTRL: u1,
            /// Data transfer direction
            DIR: u2,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral data size
            PSIZE: u2,
            /// Memory data size
            MSIZE: u2,
            /// Peripheral increment offset
            /// size
            PINCOS: u1,
            /// Priority level
            PL: u2,
            /// Double buffer mode
            DBM: u1,
            /// Current target (only in double buffer
            /// mode)
            CT: u1,
            /// ACK
            ACK: u1,
            /// Peripheral burst transfer
            /// configuration
            PBURST: u2,
            /// Memory burst transfer
            /// configuration
            MBURST: u2,
            /// Channel selection
            CHSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xb8);

        /// address: 0x400260bc
        /// stream x number of data
        /// register
        pub const S7NDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data items to
            /// transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xbc);

        /// address: 0x400260c0
        /// stream x peripheral address
        /// register
        pub const S7PAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0xc0);

        /// address: 0x400260c4
        /// stream x memory 0 address
        /// register
        pub const S7M0AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 0 address
            M0A: u32,
        }), base_address + 0xc4);

        /// address: 0x400260c8
        /// stream x memory 1 address
        /// register
        pub const S7M1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory 1 address (used in case of Double
            /// buffer mode)
            M1A: u32,
        }), base_address + 0xc8);

        /// address: 0x400260cc
        /// stream x FIFO control register
        pub const S7FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold selection
            FTH: u2,
            /// Direct mode disable
            DMDIS: u1,
            /// FIFO status
            FS: u3,
            reserved0: u1,
            /// FIFO error interrupt
            /// enable
            FEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xcc);
    };

    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40023800;

        /// address: 0x40023800
        /// clock control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal high-speed clock
            /// enable
            HSION: u1,
            /// Internal high-speed clock ready
            /// flag
            HSIRDY: u1,
            reserved0: u1,
            /// Internal high-speed clock
            /// trimming
            HSITRIM: u5,
            /// Internal high-speed clock
            /// calibration
            HSICAL: u8,
            /// HSE clock enable
            HSEON: u1,
            /// HSE clock ready flag
            HSERDY: u1,
            /// HSE clock bypass
            HSEBYP: u1,
            /// Clock security system
            /// enable
            CSSON: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Main PLL (PLL) enable
            PLLON: u1,
            /// Main PLL (PLL) clock ready
            /// flag
            PLLRDY: u1,
            /// PLLI2S enable
            PLLI2SON: u1,
            /// PLLI2S clock ready flag
            PLLI2SRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40023804
        /// PLL configuration register
        pub const PLLCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Division factor for the main PLL (PLL)
            /// and audio PLL (PLLI2S) input clock
            PLLM0: u1,
            /// Division factor for the main PLL (PLL)
            /// and audio PLL (PLLI2S) input clock
            PLLM1: u1,
            /// Division factor for the main PLL (PLL)
            /// and audio PLL (PLLI2S) input clock
            PLLM2: u1,
            /// Division factor for the main PLL (PLL)
            /// and audio PLL (PLLI2S) input clock
            PLLM3: u1,
            /// Division factor for the main PLL (PLL)
            /// and audio PLL (PLLI2S) input clock
            PLLM4: u1,
            /// Division factor for the main PLL (PLL)
            /// and audio PLL (PLLI2S) input clock
            PLLM5: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN0: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN1: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN2: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN3: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN4: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN5: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN6: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN7: u1,
            /// Main PLL (PLL) multiplication factor for
            /// VCO
            PLLN8: u1,
            reserved0: u1,
            /// Main PLL (PLL) division factor for main
            /// system clock
            PLLP0: u1,
            /// Main PLL (PLL) division factor for main
            /// system clock
            PLLP1: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Main PLL(PLL) and audio PLL (PLLI2S)
            /// entry clock source
            PLLSRC: u1,
            reserved5: u1,
            /// Main PLL (PLL) division factor for USB
            /// OTG FS, SDIO and random number generator
            /// clocks
            PLLQ0: u1,
            /// Main PLL (PLL) division factor for USB
            /// OTG FS, SDIO and random number generator
            /// clocks
            PLLQ1: u1,
            /// Main PLL (PLL) division factor for USB
            /// OTG FS, SDIO and random number generator
            /// clocks
            PLLQ2: u1,
            /// Main PLL (PLL) division factor for USB
            /// OTG FS, SDIO and random number generator
            /// clocks
            PLLQ3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40023808
        /// clock configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock switch
            SW0: u1,
            /// System clock switch
            SW1: u1,
            /// System clock switch status
            SWS0: u1,
            /// System clock switch status
            SWS1: u1,
            /// AHB prescaler
            HPRE: u4,
            reserved0: u1,
            reserved1: u1,
            /// APB Low speed prescaler
            /// (APB1)
            PPRE1: u3,
            /// APB high-speed prescaler
            /// (APB2)
            PPRE2: u3,
            /// HSE division factor for RTC
            /// clock
            RTCPRE: u5,
            /// Microcontroller clock output
            /// 1
            MCO1: u2,
            /// I2S clock selection
            I2SSRC: u1,
            /// MCO1 prescaler
            MCO1PRE: u3,
            /// MCO2 prescaler
            MCO2PRE: u3,
            /// Microcontroller clock output
            /// 2
            MCO2: u2,
        }), base_address + 0x8);

        /// address: 0x4002380c
        /// clock interrupt register
        pub const CIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt flag
            LSIRDYF: u1,
            /// LSE ready interrupt flag
            LSERDYF: u1,
            /// HSI ready interrupt flag
            HSIRDYF: u1,
            /// HSE ready interrupt flag
            HSERDYF: u1,
            /// Main PLL (PLL) ready interrupt
            /// flag
            PLLRDYF: u1,
            /// PLLI2S ready interrupt
            /// flag
            PLLI2SRDYF: u1,
            /// PLLSAI ready interrupt
            /// flag
            PLLSAIRDYF: u1,
            /// Clock security system interrupt
            /// flag
            CSSF: u1,
            /// LSI ready interrupt enable
            LSIRDYIE: u1,
            /// LSE ready interrupt enable
            LSERDYIE: u1,
            /// HSI ready interrupt enable
            HSIRDYIE: u1,
            /// HSE ready interrupt enable
            HSERDYIE: u1,
            /// Main PLL (PLL) ready interrupt
            /// enable
            PLLRDYIE: u1,
            /// PLLI2S ready interrupt
            /// enable
            PLLI2SRDYIE: u1,
            /// PLLSAI Ready Interrupt
            /// Enable
            PLLSAIRDYIE: u1,
            reserved0: u1,
            /// LSI ready interrupt clear
            LSIRDYC: u1,
            /// LSE ready interrupt clear
            LSERDYC: u1,
            /// HSI ready interrupt clear
            HSIRDYC: u1,
            /// HSE ready interrupt clear
            HSERDYC: u1,
            /// Main PLL(PLL) ready interrupt
            /// clear
            PLLRDYC: u1,
            /// PLLI2S ready interrupt
            /// clear
            PLLI2SRDYC: u1,
            /// PLLSAI Ready Interrupt
            /// Clear
            PLLSAIRDYC: u1,
            /// Clock security system interrupt
            /// clear
            CSSC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40023810
        /// AHB1 peripheral reset register
        pub const AHB1RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A reset
            GPIOARST: u1,
            /// IO port B reset
            GPIOBRST: u1,
            /// IO port C reset
            GPIOCRST: u1,
            /// IO port D reset
            GPIODRST: u1,
            /// IO port E reset
            GPIOERST: u1,
            /// IO port F reset
            GPIOFRST: u1,
            /// IO port G reset
            GPIOGRST: u1,
            /// IO port H reset
            GPIOHRST: u1,
            /// IO port I reset
            GPIOIRST: u1,
            /// IO port J reset
            GPIOJRST: u1,
            /// IO port K reset
            GPIOKRST: u1,
            reserved0: u1,
            /// CRC reset
            CRCRST: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// DMA2 reset
            DMA1RST: u1,
            /// DMA2 reset
            DMA2RST: u1,
            /// DMA2D reset
            DMA2DRST: u1,
            reserved9: u1,
            /// Ethernet MAC reset
            ETHMACRST: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// USB OTG HS module reset
            OTGHSRST: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40023814
        /// AHB2 peripheral reset register
        pub const AHB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Camera interface reset
            DCMIRST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Cryptographic module reset
            CRYPRST: u1,
            /// Hash module reset
            HSAHRST: u1,
            /// Random number generator module
            /// reset
            RNGRST: u1,
            /// USB OTG FS module reset
            OTGFSRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40023818
        /// AHB3 peripheral reset register
        pub const AHB3RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flexible memory controller module
            /// reset
            FMCRST: u1,
            /// Quad SPI memory controller
            /// reset
            QSPIRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x18);

        /// address: 0x40023820
        /// APB1 peripheral reset register
        pub const APB1RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 reset
            TIM2RST: u1,
            /// TIM3 reset
            TIM3RST: u1,
            /// TIM4 reset
            TIM4RST: u1,
            /// TIM5 reset
            TIM5RST: u1,
            /// TIM6 reset
            TIM6RST: u1,
            /// TIM7 reset
            TIM7RST: u1,
            /// TIM12 reset
            TIM12RST: u1,
            /// TIM13 reset
            TIM13RST: u1,
            /// TIM14 reset
            TIM14RST: u1,
            /// Low power timer 1 reset
            LPTIM1RST: u1,
            reserved0: u1,
            /// Window watchdog reset
            WWDGRST: u1,
            reserved1: u1,
            /// CAN 3 reset
            CAN3RST: u1,
            /// SPI 2 reset
            SPI2RST: u1,
            /// SPI 3 reset
            SPI3RST: u1,
            /// SPDIF-RX reset
            SPDIFRXRST: u1,
            /// USART 2 reset
            UART2RST: u1,
            /// USART 3 reset
            UART3RST: u1,
            /// USART 4 reset
            UART4RST: u1,
            /// USART 5 reset
            UART5RST: u1,
            /// I2C 1 reset
            I2C1RST: u1,
            /// I2C 2 reset
            I2C2RST: u1,
            /// I2C3 reset
            I2C3RST: u1,
            /// I2C 4 reset
            I2C4RST: u1,
            /// CAN1 reset
            CAN1RST: u1,
            /// CAN2 reset
            CAN2RST: u1,
            /// HDMI-CEC reset
            CECRST: u1,
            /// Power interface reset
            PWRRST: u1,
            /// DAC reset
            DACRST: u1,
            /// UART7 reset
            UART7RST: u1,
            /// UART8 reset
            UART8RST: u1,
        }), base_address + 0x20);

        /// address: 0x40023824
        /// APB2 peripheral reset register
        pub const APB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1 reset
            TIM1RST: u1,
            /// TIM8 reset
            TIM8RST: u1,
            reserved0: u1,
            reserved1: u1,
            /// USART1 reset
            USART1RST: u1,
            /// USART6 reset
            USART6RST: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC interface reset (common to all
            /// ADCs)
            ADCRST: u1,
            reserved4: u1,
            reserved5: u1,
            /// SDMMC1 reset
            SDMMC1RST: u1,
            /// SPI 1 reset
            SPI1RST: u1,
            /// SPI4 reset
            SPI4RST: u1,
            /// System configuration controller
            /// reset
            SYSCFGRST: u1,
            reserved6: u1,
            /// TIM9 reset
            TIM9RST: u1,
            /// TIM10 reset
            TIM10RST: u1,
            /// TIM11 reset
            TIM11RST: u1,
            reserved7: u1,
            /// SPI5 reset
            SPI5RST: u1,
            /// SPI6 reset
            SPI6RST: u1,
            /// SAI1 reset
            SAI1RST: u1,
            /// SAI2 reset
            SAI2RST: u1,
            reserved8: u1,
            reserved9: u1,
            /// LTDC reset
            LTDCRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x24);

        /// address: 0x40023830
        /// AHB1 peripheral clock register
        pub const AHB1ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A clock enable
            GPIOAEN: u1,
            /// IO port B clock enable
            GPIOBEN: u1,
            /// IO port C clock enable
            GPIOCEN: u1,
            /// IO port D clock enable
            GPIODEN: u1,
            /// IO port E clock enable
            GPIOEEN: u1,
            /// IO port F clock enable
            GPIOFEN: u1,
            /// IO port G clock enable
            GPIOGEN: u1,
            /// IO port H clock enable
            GPIOHEN: u1,
            /// IO port I clock enable
            GPIOIEN: u1,
            /// IO port J clock enable
            GPIOJEN: u1,
            /// IO port K clock enable
            GPIOKEN: u1,
            reserved0: u1,
            /// CRC clock enable
            CRCEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Backup SRAM interface clock
            /// enable
            BKPSRAMEN: u1,
            reserved6: u1,
            /// CCM data RAM clock enable
            CCMDATARAMEN: u1,
            /// DMA1 clock enable
            DMA1EN: u1,
            /// DMA2 clock enable
            DMA2EN: u1,
            /// DMA2D clock enable
            DMA2DEN: u1,
            reserved7: u1,
            /// Ethernet MAC clock enable
            ETHMACEN: u1,
            /// Ethernet Transmission clock
            /// enable
            ETHMACTXEN: u1,
            /// Ethernet Reception clock
            /// enable
            ETHMACRXEN: u1,
            /// Ethernet PTP clock enable
            ETHMACPTPEN: u1,
            /// USB OTG HS clock enable
            OTGHSEN: u1,
            /// USB OTG HSULPI clock
            /// enable
            OTGHSULPIEN: u1,
            padding0: u1,
        }), base_address + 0x30);

        /// address: 0x40023834
        /// AHB2 peripheral clock enable
        /// register
        pub const AHB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Camera interface enable
            DCMIEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Cryptographic modules clock
            /// enable
            CRYPEN: u1,
            /// Hash modules clock enable
            HASHEN: u1,
            /// Random number generator clock
            /// enable
            RNGEN: u1,
            /// USB OTG FS clock enable
            OTGFSEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x34);

        /// address: 0x40023838
        /// AHB3 peripheral clock enable
        /// register
        pub const AHB3ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flexible memory controller module clock
            /// enable
            FMCEN: u1,
            /// Quad SPI memory controller clock
            /// enable
            QSPIEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x38);

        /// address: 0x40023840
        /// APB1 peripheral clock enable
        /// register
        pub const APB1ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 clock enable
            TIM2EN: u1,
            /// TIM3 clock enable
            TIM3EN: u1,
            /// TIM4 clock enable
            TIM4EN: u1,
            /// TIM5 clock enable
            TIM5EN: u1,
            /// TIM6 clock enable
            TIM6EN: u1,
            /// TIM7 clock enable
            TIM7EN: u1,
            /// TIM12 clock enable
            TIM12EN: u1,
            /// TIM13 clock enable
            TIM13EN: u1,
            /// TIM14 clock enable
            TIM14EN: u1,
            /// Low power timer 1 clock
            /// enable
            LPTMI1EN: u1,
            /// RTC register interface clock enable
            RTCAPBEN: u1,
            /// Window watchdog clock
            /// enable
            WWDGEN: u1,
            reserved0: u1,
            /// CAN 3 clock enable
            CAN3EN: u1,
            /// SPI2 clock enable
            SPI2EN: u1,
            /// SPI3 clock enable
            SPI3EN: u1,
            /// SPDIF-RX clock enable
            SPDIFRXEN: u1,
            /// USART 2 clock enable
            USART2EN: u1,
            /// USART3 clock enable
            USART3EN: u1,
            /// UART4 clock enable
            UART4EN: u1,
            /// UART5 clock enable
            UART5EN: u1,
            /// I2C1 clock enable
            I2C1EN: u1,
            /// I2C2 clock enable
            I2C2EN: u1,
            /// I2C3 clock enable
            I2C3EN: u1,
            /// I2C4 clock enable
            I2C4EN: u1,
            /// CAN 1 clock enable
            CAN1EN: u1,
            /// CAN 2 clock enable
            CAN2EN: u1,
            /// HDMI-CEN clock enable
            CECEN: u1,
            /// Power interface clock
            /// enable
            PWREN: u1,
            /// DAC interface clock enable
            DACEN: u1,
            /// UART7 clock enable
            UART7ENR: u1,
            /// UART8 clock enable
            UART8ENR: u1,
        }), base_address + 0x40);

        /// address: 0x40023844
        /// APB2 peripheral clock enable
        /// register
        pub const APB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1 clock enable
            TIM1EN: u1,
            /// TIM8 clock enable
            TIM8EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// USART1 clock enable
            USART1EN: u1,
            /// USART6 clock enable
            USART6EN: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC1 clock enable
            ADC1EN: u1,
            /// ADC2 clock enable
            ADC2EN: u1,
            /// ADC3 clock enable
            ADC3EN: u1,
            /// SDMMC1 clock enable
            SDMMC1EN: u1,
            /// SPI1 clock enable
            SPI1EN: u1,
            /// SPI4 clock enable
            SPI4ENR: u1,
            /// System configuration controller clock
            /// enable
            SYSCFGEN: u1,
            reserved4: u1,
            /// TIM9 clock enable
            TIM9EN: u1,
            /// TIM10 clock enable
            TIM10EN: u1,
            /// TIM11 clock enable
            TIM11EN: u1,
            reserved5: u1,
            /// SPI5 clock enable
            SPI5ENR: u1,
            /// SPI6 clock enable
            SPI6ENR: u1,
            /// SAI1 clock enable
            SAI1EN: u1,
            /// SAI2 clock enable
            SAI2EN: u1,
            reserved6: u1,
            reserved7: u1,
            /// LTDC clock enable
            LTDCEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x44);

        /// address: 0x40023850
        /// AHB1 peripheral clock enable in low power
        /// mode register
        pub const AHB1LPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A clock enable during sleep
            /// mode
            GPIOALPEN: u1,
            /// IO port B clock enable during Sleep
            /// mode
            GPIOBLPEN: u1,
            /// IO port C clock enable during Sleep
            /// mode
            GPIOCLPEN: u1,
            /// IO port D clock enable during Sleep
            /// mode
            GPIODLPEN: u1,
            /// IO port E clock enable during Sleep
            /// mode
            GPIOELPEN: u1,
            /// IO port F clock enable during Sleep
            /// mode
            GPIOFLPEN: u1,
            /// IO port G clock enable during Sleep
            /// mode
            GPIOGLPEN: u1,
            /// IO port H clock enable during Sleep
            /// mode
            GPIOHLPEN: u1,
            /// IO port I clock enable during Sleep
            /// mode
            GPIOILPEN: u1,
            /// IO port J clock enable during Sleep
            /// mode
            GPIOJLPEN: u1,
            /// IO port K clock enable during Sleep
            /// mode
            GPIOKLPEN: u1,
            reserved0: u1,
            /// CRC clock enable during Sleep
            /// mode
            CRCLPEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Flash interface clock enable during
            /// Sleep mode
            FLITFLPEN: u1,
            /// SRAM 1interface clock enable during
            /// Sleep mode
            SRAM1LPEN: u1,
            /// SRAM 2 interface clock enable during
            /// Sleep mode
            SRAM2LPEN: u1,
            /// Backup SRAM interface clock enable
            /// during Sleep mode
            BKPSRAMLPEN: u1,
            /// SRAM 3 interface clock enable during
            /// Sleep mode
            SRAM3LPEN: u1,
            reserved3: u1,
            /// DMA1 clock enable during Sleep
            /// mode
            DMA1LPEN: u1,
            /// DMA2 clock enable during Sleep
            /// mode
            DMA2LPEN: u1,
            /// DMA2D clock enable during Sleep
            /// mode
            DMA2DLPEN: u1,
            reserved4: u1,
            /// Ethernet MAC clock enable during Sleep
            /// mode
            ETHMACLPEN: u1,
            /// Ethernet transmission clock enable
            /// during Sleep mode
            ETHMACTXLPEN: u1,
            /// Ethernet reception clock enable during
            /// Sleep mode
            ETHMACRXLPEN: u1,
            /// Ethernet PTP clock enable during Sleep
            /// mode
            ETHMACPTPLPEN: u1,
            /// USB OTG HS clock enable during Sleep
            /// mode
            OTGHSLPEN: u1,
            /// USB OTG HS ULPI clock enable during
            /// Sleep mode
            OTGHSULPILPEN: u1,
            padding0: u1,
        }), base_address + 0x50);

        /// address: 0x40023854
        /// AHB2 peripheral clock enable in low power
        /// mode register
        pub const AHB2LPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Camera interface enable during Sleep
            /// mode
            DCMILPEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Cryptography modules clock enable during
            /// Sleep mode
            CRYPLPEN: u1,
            /// Hash modules clock enable during Sleep
            /// mode
            HASHLPEN: u1,
            /// Random number generator clock enable
            /// during Sleep mode
            RNGLPEN: u1,
            /// USB OTG FS clock enable during Sleep
            /// mode
            OTGFSLPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x54);

        /// address: 0x40023858
        /// AHB3 peripheral clock enable in low power
        /// mode register
        pub const AHB3LPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flexible memory controller module clock
            /// enable during Sleep mode
            FMCLPEN: u1,
            /// Quand SPI memory controller clock enable
            /// during Sleep mode
            QSPILPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x58);

        /// address: 0x40023860
        /// APB1 peripheral clock enable in low power
        /// mode register
        pub const APB1LPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 clock enable during Sleep
            /// mode
            TIM2LPEN: u1,
            /// TIM3 clock enable during Sleep
            /// mode
            TIM3LPEN: u1,
            /// TIM4 clock enable during Sleep
            /// mode
            TIM4LPEN: u1,
            /// TIM5 clock enable during Sleep
            /// mode
            TIM5LPEN: u1,
            /// TIM6 clock enable during Sleep
            /// mode
            TIM6LPEN: u1,
            /// TIM7 clock enable during Sleep
            /// mode
            TIM7LPEN: u1,
            /// TIM12 clock enable during Sleep
            /// mode
            TIM12LPEN: u1,
            /// TIM13 clock enable during Sleep
            /// mode
            TIM13LPEN: u1,
            /// TIM14 clock enable during Sleep
            /// mode
            TIM14LPEN: u1,
            /// low power timer 1 clock enable during
            /// Sleep mode
            LPTIM1LPEN: u1,
            reserved0: u1,
            /// Window watchdog clock enable during
            /// Sleep mode
            WWDGLPEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// SPI2 clock enable during Sleep
            /// mode
            SPI2LPEN: u1,
            /// SPI3 clock enable during Sleep
            /// mode
            SPI3LPEN: u1,
            /// SPDIF-RX clock enable during sleep
            /// mode
            SPDIFRXLPEN: u1,
            /// USART2 clock enable during Sleep
            /// mode
            USART2LPEN: u1,
            /// USART3 clock enable during Sleep
            /// mode
            USART3LPEN: u1,
            /// UART4 clock enable during Sleep
            /// mode
            UART4LPEN: u1,
            /// UART5 clock enable during Sleep
            /// mode
            UART5LPEN: u1,
            /// I2C1 clock enable during Sleep
            /// mode
            I2C1LPEN: u1,
            /// I2C2 clock enable during Sleep
            /// mode
            I2C2LPEN: u1,
            /// I2C3 clock enable during Sleep
            /// mode
            I2C3LPEN: u1,
            /// I2C4 clock enable during Sleep
            /// mode
            I2C4LPEN: u1,
            /// CAN 1 clock enable during Sleep
            /// mode
            CAN1LPEN: u1,
            /// CAN 2 clock enable during Sleep
            /// mode
            CAN2LPEN: u1,
            /// HDMI-CEN clock enable during Sleep
            /// mode
            CECLPEN: u1,
            /// Power interface clock enable during
            /// Sleep mode
            PWRLPEN: u1,
            /// DAC interface clock enable during Sleep
            /// mode
            DACLPEN: u1,
            /// UART7 clock enable during Sleep
            /// mode
            UART7LPEN: u1,
            /// UART8 clock enable during Sleep
            /// mode
            UART8LPEN: u1,
        }), base_address + 0x60);

        /// address: 0x40023864
        /// APB2 peripheral clock enabled in low power
        /// mode register
        pub const APB2LPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1 clock enable during Sleep
            /// mode
            TIM1LPEN: u1,
            /// TIM8 clock enable during Sleep
            /// mode
            TIM8LPEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// USART1 clock enable during Sleep
            /// mode
            USART1LPEN: u1,
            /// USART6 clock enable during Sleep
            /// mode
            USART6LPEN: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC1 clock enable during Sleep
            /// mode
            ADC1LPEN: u1,
            /// ADC2 clock enable during Sleep
            /// mode
            ADC2LPEN: u1,
            /// ADC 3 clock enable during Sleep
            /// mode
            ADC3LPEN: u1,
            /// SDMMC1 clock enable during Sleep
            /// mode
            SDMMC1LPEN: u1,
            /// SPI 1 clock enable during Sleep
            /// mode
            SPI1LPEN: u1,
            /// SPI 4 clock enable during Sleep
            /// mode
            SPI4LPEN: u1,
            /// System configuration controller clock
            /// enable during Sleep mode
            SYSCFGLPEN: u1,
            reserved4: u1,
            /// TIM9 clock enable during sleep
            /// mode
            TIM9LPEN: u1,
            /// TIM10 clock enable during Sleep
            /// mode
            TIM10LPEN: u1,
            /// TIM11 clock enable during Sleep
            /// mode
            TIM11LPEN: u1,
            reserved5: u1,
            /// SPI 5 clock enable during Sleep
            /// mode
            SPI5LPEN: u1,
            /// SPI 6 clock enable during Sleep
            /// mode
            SPI6LPEN: u1,
            /// SAI1 clock enable during sleep
            /// mode
            SAI1LPEN: u1,
            /// SAI2 clock enable during sleep
            /// mode
            SAI2LPEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// LTDC clock enable during sleep
            /// mode
            LTDCLPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x64);

        /// address: 0x40023870
        /// Backup domain control register
        pub const BDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External low-speed oscillator
            /// enable
            LSEON: u1,
            /// External low-speed oscillator
            /// ready
            LSERDY: u1,
            /// External low-speed oscillator
            /// bypass
            LSEBYP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// RTC clock source selection
            RTCSEL0: u1,
            /// RTC clock source selection
            RTCSEL1: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// RTC clock enable
            RTCEN: u1,
            /// Backup domain software
            /// reset
            BDRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x70);

        /// address: 0x40023874
        /// clock control & status
        /// register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal low-speed oscillator
            /// enable
            LSION: u1,
            /// Internal low-speed oscillator
            /// ready
            LSIRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Remove reset flag
            RMVF: u1,
            /// BOR reset flag
            BORRSTF: u1,
            /// PIN reset flag
            PADRSTF: u1,
            /// POR/PDR reset flag
            PORRSTF: u1,
            /// Software reset flag
            SFTRSTF: u1,
            /// Independent watchdog reset
            /// flag
            WDGRSTF: u1,
            /// Window watchdog reset flag
            WWDGRSTF: u1,
            /// Low-power reset flag
            LPWRRSTF: u1,
        }), base_address + 0x74);

        /// address: 0x40023880
        /// spread spectrum clock generation
        /// register
        pub const SSCGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Modulation period
            MODPER: u13,
            /// Incrementation step
            INCSTEP: u15,
            reserved0: u1,
            reserved1: u1,
            /// Spread Select
            SPREADSEL: u1,
            /// Spread spectrum modulation
            /// enable
            SSCGEN: u1,
        }), base_address + 0x80);

        /// address: 0x40023884
        /// PLLI2S configuration register
        pub const PLLI2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// PLLI2S multiplication factor for
            /// VCO
            PLLI2SN: u9,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// PLLI2S division factor for SAI1
            /// clock
            PLLI2SQ: u4,
            /// PLLI2S division factor for I2S
            /// clocks
            PLLI2SR: u3,
            padding0: u1,
        }), base_address + 0x84);

        /// address: 0x40023888
        /// PLL configuration register
        pub const PLLSAICFGR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// PLLSAI division factor for
            /// VCO
            PLLSAIN: u9,
            reserved6: u1,
            /// PLLSAI division factor for 48MHz
            /// clock
            PLLSAIP: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// PLLSAI division factor for SAI
            /// clock
            PLLSAIQ: u4,
            /// PLLSAI division factor for LCD
            /// clock
            PLLSAIR: u3,
            padding0: u1,
        }), base_address + 0x88);

        /// address: 0x4002388c
        /// dedicated clocks configuration
        /// register
        pub const DKCFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLLI2S division factor for SAI1
            /// clock
            PLLI2SDIV: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLLSAI division factor for SAI1
            /// clock
            PLLSAIDIVQ: u5,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// division factor for
            /// LCD_CLK
            PLLSAIDIVR: u2,
            reserved6: u1,
            reserved7: u1,
            /// SAI1 clock source
            /// selection
            SAI1SEL: u2,
            /// SAI2 clock source
            /// selection
            SAI2SEL: u2,
            /// Timers clocks prescalers
            /// selection
            TIMPRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8c);

        /// address: 0x40023890
        /// dedicated clocks configuration
        /// register
        pub const DKCFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART 1 clock source
            /// selection
            USART1SEL: u2,
            /// USART 2 clock source
            /// selection
            USART2SEL: u2,
            /// USART 3 clock source
            /// selection
            USART3SEL: u2,
            /// UART 4 clock source
            /// selection
            UART4SEL: u2,
            /// UART 5 clock source
            /// selection
            UART5SEL: u2,
            /// USART 6 clock source
            /// selection
            USART6SEL: u2,
            /// UART 7 clock source
            /// selection
            UART7SEL: u2,
            /// UART 8 clock source
            /// selection
            UART8SEL: u2,
            /// I2C1 clock source
            /// selection
            I2C1SEL: u2,
            /// I2C2 clock source
            /// selection
            I2C2SEL: u2,
            /// I2C3 clock source
            /// selection
            I2C3SEL: u2,
            /// I2C4 clock source
            /// selection
            I2C4SEL: u2,
            /// Low power timer 1 clock source
            /// selection
            LPTIM1SEL: u2,
            /// HDMI-CEC clock source
            /// selection
            CECSEL: u1,
            /// 48MHz clock source
            /// selection
            CK48MSEL: u1,
            /// SDMMC1 clock source
            /// selection
            SDMMC1SEL: u1,
            /// SDMMC2 clock source
            /// selection
            SDMMC2SEL: u1,
            /// DSI clock source selection
            DSISEL: u1,
            padding0: u1,
        }), base_address + 0x90);
    };

    /// General-purpose I/Os
    pub const GPIOD = struct {
        pub const base_address = 0x40020c00;

        /// address: 0x40020c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40020c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40020c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x40020c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40020c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40020c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40020c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x40020c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40020c20
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40020c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40020c28
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOC = struct {
        pub const base_address = 0x40020800;

        /// address: 0x40020800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40020804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40020808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002080c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40020810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40020814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40020818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002081c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40020820
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40020824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40020828
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOK = struct {
        pub const base_address = 0x40022800;

        /// address: 0x40022800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40022804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40022808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002280c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40022810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40022814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40022818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002281c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40022820
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40022824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40022828
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOJ = struct {
        pub const base_address = 0x40022400;

        /// address: 0x40022400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40022404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40022408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002240c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40022410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40022414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40022418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002241c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40022420
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40022424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40022428
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOI = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40022004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40022008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002200c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40022010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40022014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40022018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002201c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40022020
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40022024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40022028
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOH = struct {
        pub const base_address = 0x40021c00;

        /// address: 0x40021c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40021c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40021c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x40021c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40021c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40021c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40021c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x40021c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40021c20
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40021c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40021c28
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOG = struct {
        pub const base_address = 0x40021800;

        /// address: 0x40021800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40021804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40021808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002180c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40021810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40021814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40021818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002181c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40021820
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40021824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40021828
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOF = struct {
        pub const base_address = 0x40021400;

        /// address: 0x40021400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40021404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40021408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002140c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40021410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40021414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40021418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002141c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40021420
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40021424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40021428
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOE = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40021008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002100c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40021010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40021014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40021018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// GPIO alternate function
        /// lowregister
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40021024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40021028
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D Reset bit 0
            BR0: u1,
            /// Port D Reset bit 1
            BR1: u1,
            /// Port D Reset bit 2
            BR2: u1,
            /// Port D Reset bit 3
            BR3: u1,
            /// Port D Reset bit 4
            BR4: u1,
            /// Port D Reset bit 5
            BR5: u1,
            /// Port D Reset bit 6
            BR6: u1,
            /// Port D Reset bit 7
            BR7: u1,
            /// Port D Reset bit 8
            BR8: u1,
            /// Port D Reset bit 9
            BR9: u1,
            /// Port D Reset bit 10
            BR10: u1,
            /// Port D Reset bit 11
            BR11: u1,
            /// Port D Reset bit 12
            BR12: u1,
            /// Port D Reset bit 13
            BR13: u1,
            /// Port D Reset bit 14
            BR14: u1,
            /// Port D Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// General-purpose I/Os
    pub const GPIOB = struct {
        pub const base_address = 0x40020400;

        /// address: 0x40020400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40020404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40020408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002040c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40020410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40020414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40020418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002041c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40020420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40020424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40020428
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port B Reset bit 0
            BR0: u1,
            /// Port B Reset bit 1
            BR1: u1,
            /// Port B Reset bit 2
            BR2: u1,
            /// Port B Reset bit 3
            BR3: u1,
            /// Port B Reset bit 4
            BR4: u1,
            /// Port B Reset bit 5
            BR5: u1,
            /// Port B Reset bit 6
            BR6: u1,
            /// Port B Reset bit 7
            BR7: u1,
            /// Port B Reset bit 8
            BR8: u1,
            /// Port B Reset bit 9
            BR9: u1,
            /// Port B Reset bit 10
            BR10: u1,
            /// Port B Reset bit 11
            BR11: u1,
            /// Port B Reset bit 12
            BR12: u1,
            /// Port B Reset bit 13
            BR13: u1,
            /// Port B Reset bit 14
            BR14: u1,
            /// Port B Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40020018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4002001c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Reset bit 0
            BR0: u1,
            /// Port A Reset bit 1
            BR1: u1,
            /// Port A Reset bit 2
            BR2: u1,
            /// Port A Reset bit 3
            BR3: u1,
            /// Port A Reset bit 4
            BR4: u1,
            /// Port A Reset bit 5
            BR5: u1,
            /// Port A Reset bit 6
            BR6: u1,
            /// Port A Reset bit 7
            BR7: u1,
            /// Port A Reset bit 8
            BR8: u1,
            /// Port A Reset bit 9
            BR9: u1,
            /// Port A Reset bit 10
            BR10: u1,
            /// Port A Reset bit 11
            BR11: u1,
            /// Port A Reset bit 12
            BR12: u1,
            /// Port A Reset bit 13
            BR13: u1,
            /// Port A Reset bit 14
            BR14: u1,
            /// Port A Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// System configuration controller
    pub const SYSCFG = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// memory remap register
        pub const MEMRM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory mapping selection
            MEM_MODE: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Flash bank mode selection
            FB_MODE: u1,
            reserved5: u1,
            /// FMC memory mapping swap
            SWP_FMC: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// peripheral mode configuration
        /// register
        pub const PMC = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// ADC1DC2
            ADC1DC2: u1,
            /// ADC2DC2
            ADC2DC2: u1,
            /// ADC3DC2
            ADC3DC2: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Ethernet PHY interface
            /// selection
            MII_RMII_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40013808
        /// external interrupt configuration register
        /// 1
        pub const EXTICR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI0: u4,
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI1: u4,
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI2: u4,
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI3: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// external interrupt configuration register
        /// 2
        pub const EXTICR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI4: u4,
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI5: u4,
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI6: u4,
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI7: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// external interrupt configuration register
        /// 3
        pub const EXTICR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 8 to
            /// 11)
            EXTI8: u4,
            /// EXTI x configuration (x = 8 to
            /// 11)
            EXTI9: u4,
            /// EXTI10
            EXTI10: u4,
            /// EXTI x configuration (x = 8 to
            /// 11)
            EXTI11: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// external interrupt configuration register
        /// 4
        pub const EXTICR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 12 to
            /// 15)
            EXTI12: u4,
            /// EXTI x configuration (x = 12 to
            /// 15)
            EXTI13: u4,
            /// EXTI x configuration (x = 12 to
            /// 15)
            EXTI14: u4,
            /// EXTI x configuration (x = 12 to
            /// 15)
            EXTI15: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013820
        /// Compensation cell control
        /// register
        pub const CMPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compensation cell
            /// power-down
            CMP_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// READY
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x20);
    };

    /// Serial peripheral interface
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// Frame format error
            FRE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO Transmission Level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001301c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            /// Asynchronous start enable
            ASTRTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x40013020
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// Frame format error
            FRE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO Transmission Level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000381c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            /// Asynchronous start enable
            ASTRTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x40003820
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI4 = struct {
        pub const base_address = 0x40013400;

        /// address: 0x40013400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013408
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// Frame format error
            FRE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO Transmission Level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001340c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013410
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013414
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013418
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001341c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            /// Asynchronous start enable
            ASTRTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x40013420
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI5 = struct {
        pub const base_address = 0x40015000;

        /// address: 0x40015000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40015004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40015008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// Frame format error
            FRE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO Transmission Level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001500c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40015010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40015014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40015018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001501c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            /// Asynchronous start enable
            ASTRTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x40015020
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI3 = struct {
        pub const base_address = 0x40003c00;

        /// address: 0x40003c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003c08
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// Frame format error
            FRE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO Transmission Level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x40003c0c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003c10
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003c14
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003c18
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40003c1c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            /// Asynchronous start enable
            ASTRTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x40003c20
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI6 = struct {
        pub const base_address = 0x40015400;

        /// address: 0x40015400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40015404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40015408
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// Frame format error
            FRE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO Transmission Level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001540c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40015410
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40015414
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40015418
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001541c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            /// Asynchronous start enable
            ASTRTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x40015420
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };

    /// Analog-to-digital converter
    pub const ADC1 = struct {
        pub const base_address = 0x40012000;

        /// address: 0x40012000
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog flag
            AWD: u1,
            /// Regular channel end of
            /// conversion
            EOC: u1,
            /// Injected channel end of
            /// conversion
            JEOC: u1,
            /// Injected channel start
            /// flag
            JSTRT: u1,
            /// Regular channel start flag
            STRT: u1,
            /// Overrun
            OVR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);

        /// address: 0x40012004
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            /// bits
            AWDCH: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Interrupt enable for injected
            /// channels
            JEOCIE: u1,
            /// Scan mode
            SCAN: u1,
            /// Enable the watchdog on a single channel
            /// in scan mode
            AWDSGL: u1,
            /// Automatic injected group
            /// conversion
            JAUTO: u1,
            /// Discontinuous mode on regular
            /// channels
            DISCEN: u1,
            /// Discontinuous mode on injected
            /// channels
            JDISCEN: u1,
            /// Discontinuous mode channel
            /// count
            DISCNUM: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Analog watchdog enable on injected
            /// channels
            JAWDEN: u1,
            /// Analog watchdog enable on regular
            /// channels
            AWDEN: u1,
            /// Resolution
            RES: u2,
            /// Overrun interrupt enable
            OVRIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40012008
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// A/D Converter ON / OFF
            ADON: u1,
            /// Continuous conversion
            CONT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Direct memory access mode (for single
            /// ADC mode)
            DMA: u1,
            /// DMA disable selection (for single ADC
            /// mode)
            DDS: u1,
            /// End of conversion
            /// selection
            EOCS: u1,
            /// Data alignment
            ALIGN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// External event select for injected
            /// group
            JEXTSEL: u4,
            /// External trigger enable for injected
            /// channels
            JEXTEN: u2,
            /// Start conversion of injected
            /// channels
            JSWSTART: u1,
            reserved10: u1,
            /// External event select for regular
            /// group
            EXTSEL: u4,
            /// External trigger enable for regular
            /// channels
            EXTEN: u2,
            /// Start conversion of regular
            /// channels
            SWSTART: u1,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x4001200c
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample time bits
            SMPx_x: u32,
        }), base_address + 0xc);

        /// address: 0x40012010
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample time bits
            SMPx_x: u32,
        }), base_address + 0x10);

        /// address: 0x40012014
        /// injected channel data offset register
        /// x
        pub const JOFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012018
        /// injected channel data offset register
        /// x
        pub const JOFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001201c
        /// injected channel data offset register
        /// x
        pub const JOFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012020
        /// injected channel data offset register
        /// x
        pub const JOFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET4: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012024
        /// watchdog higher threshold
        /// register
        pub const HTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x40012028
        /// watchdog lower threshold
        /// register
        pub const LTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x4001202c
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            SQ13: u5,
            /// 14th conversion in regular
            /// sequence
            SQ14: u5,
            /// 15th conversion in regular
            /// sequence
            SQ15: u5,
            /// 16th conversion in regular
            /// sequence
            SQ16: u5,
            /// Regular channel sequence
            /// length
            L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012030
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            SQ7: u5,
            /// 8th conversion in regular
            /// sequence
            SQ8: u5,
            /// 9th conversion in regular
            /// sequence
            SQ9: u5,
            /// 10th conversion in regular
            /// sequence
            SQ10: u5,
            /// 11th conversion in regular
            /// sequence
            SQ11: u5,
            /// 12th conversion in regular
            /// sequence
            SQ12: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012034
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            SQ1: u5,
            /// 2nd conversion in regular
            /// sequence
            SQ2: u5,
            /// 3rd conversion in regular
            /// sequence
            SQ3: u5,
            /// 4th conversion in regular
            /// sequence
            SQ4: u5,
            /// 5th conversion in regular
            /// sequence
            SQ5: u5,
            /// 6th conversion in regular
            /// sequence
            SQ6: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012038
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in injected
            /// sequence
            JSQ1: u5,
            /// 2nd conversion in injected
            /// sequence
            JSQ2: u5,
            /// 3rd conversion in injected
            /// sequence
            JSQ3: u5,
            /// 4th conversion in injected
            /// sequence
            JSQ4: u5,
            /// Injected sequence length
            JL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001203c
        /// injected data register x
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012040
        /// injected data register x
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012044
        /// injected data register x
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012048
        /// injected data register x
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001204c
        /// regular data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const ADC2 = struct {
        pub const base_address = 0x40012100;

        /// address: 0x40012100
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog flag
            AWD: u1,
            /// Regular channel end of
            /// conversion
            EOC: u1,
            /// Injected channel end of
            /// conversion
            JEOC: u1,
            /// Injected channel start
            /// flag
            JSTRT: u1,
            /// Regular channel start flag
            STRT: u1,
            /// Overrun
            OVR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);

        /// address: 0x40012104
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            /// bits
            AWDCH: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Interrupt enable for injected
            /// channels
            JEOCIE: u1,
            /// Scan mode
            SCAN: u1,
            /// Enable the watchdog on a single channel
            /// in scan mode
            AWDSGL: u1,
            /// Automatic injected group
            /// conversion
            JAUTO: u1,
            /// Discontinuous mode on regular
            /// channels
            DISCEN: u1,
            /// Discontinuous mode on injected
            /// channels
            JDISCEN: u1,
            /// Discontinuous mode channel
            /// count
            DISCNUM: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Analog watchdog enable on injected
            /// channels
            JAWDEN: u1,
            /// Analog watchdog enable on regular
            /// channels
            AWDEN: u1,
            /// Resolution
            RES: u2,
            /// Overrun interrupt enable
            OVRIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40012108
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// A/D Converter ON / OFF
            ADON: u1,
            /// Continuous conversion
            CONT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Direct memory access mode (for single
            /// ADC mode)
            DMA: u1,
            /// DMA disable selection (for single ADC
            /// mode)
            DDS: u1,
            /// End of conversion
            /// selection
            EOCS: u1,
            /// Data alignment
            ALIGN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// External event select for injected
            /// group
            JEXTSEL: u4,
            /// External trigger enable for injected
            /// channels
            JEXTEN: u2,
            /// Start conversion of injected
            /// channels
            JSWSTART: u1,
            reserved10: u1,
            /// External event select for regular
            /// group
            EXTSEL: u4,
            /// External trigger enable for regular
            /// channels
            EXTEN: u2,
            /// Start conversion of regular
            /// channels
            SWSTART: u1,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x4001210c
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample time bits
            SMPx_x: u32,
        }), base_address + 0xc);

        /// address: 0x40012110
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample time bits
            SMPx_x: u32,
        }), base_address + 0x10);

        /// address: 0x40012114
        /// injected channel data offset register
        /// x
        pub const JOFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012118
        /// injected channel data offset register
        /// x
        pub const JOFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001211c
        /// injected channel data offset register
        /// x
        pub const JOFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012120
        /// injected channel data offset register
        /// x
        pub const JOFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET4: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012124
        /// watchdog higher threshold
        /// register
        pub const HTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x40012128
        /// watchdog lower threshold
        /// register
        pub const LTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x4001212c
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            SQ13: u5,
            /// 14th conversion in regular
            /// sequence
            SQ14: u5,
            /// 15th conversion in regular
            /// sequence
            SQ15: u5,
            /// 16th conversion in regular
            /// sequence
            SQ16: u5,
            /// Regular channel sequence
            /// length
            L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012130
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            SQ7: u5,
            /// 8th conversion in regular
            /// sequence
            SQ8: u5,
            /// 9th conversion in regular
            /// sequence
            SQ9: u5,
            /// 10th conversion in regular
            /// sequence
            SQ10: u5,
            /// 11th conversion in regular
            /// sequence
            SQ11: u5,
            /// 12th conversion in regular
            /// sequence
            SQ12: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012134
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            SQ1: u5,
            /// 2nd conversion in regular
            /// sequence
            SQ2: u5,
            /// 3rd conversion in regular
            /// sequence
            SQ3: u5,
            /// 4th conversion in regular
            /// sequence
            SQ4: u5,
            /// 5th conversion in regular
            /// sequence
            SQ5: u5,
            /// 6th conversion in regular
            /// sequence
            SQ6: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012138
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in injected
            /// sequence
            JSQ1: u5,
            /// 2nd conversion in injected
            /// sequence
            JSQ2: u5,
            /// 3rd conversion in injected
            /// sequence
            JSQ3: u5,
            /// 4th conversion in injected
            /// sequence
            JSQ4: u5,
            /// Injected sequence length
            JL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001213c
        /// injected data register x
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012140
        /// injected data register x
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012144
        /// injected data register x
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012148
        /// injected data register x
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001214c
        /// regular data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const ADC3 = struct {
        pub const base_address = 0x40012200;

        /// address: 0x40012200
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog flag
            AWD: u1,
            /// Regular channel end of
            /// conversion
            EOC: u1,
            /// Injected channel end of
            /// conversion
            JEOC: u1,
            /// Injected channel start
            /// flag
            JSTRT: u1,
            /// Regular channel start flag
            STRT: u1,
            /// Overrun
            OVR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);

        /// address: 0x40012204
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            /// bits
            AWDCH: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Interrupt enable for injected
            /// channels
            JEOCIE: u1,
            /// Scan mode
            SCAN: u1,
            /// Enable the watchdog on a single channel
            /// in scan mode
            AWDSGL: u1,
            /// Automatic injected group
            /// conversion
            JAUTO: u1,
            /// Discontinuous mode on regular
            /// channels
            DISCEN: u1,
            /// Discontinuous mode on injected
            /// channels
            JDISCEN: u1,
            /// Discontinuous mode channel
            /// count
            DISCNUM: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Analog watchdog enable on injected
            /// channels
            JAWDEN: u1,
            /// Analog watchdog enable on regular
            /// channels
            AWDEN: u1,
            /// Resolution
            RES: u2,
            /// Overrun interrupt enable
            OVRIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40012208
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// A/D Converter ON / OFF
            ADON: u1,
            /// Continuous conversion
            CONT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Direct memory access mode (for single
            /// ADC mode)
            DMA: u1,
            /// DMA disable selection (for single ADC
            /// mode)
            DDS: u1,
            /// End of conversion
            /// selection
            EOCS: u1,
            /// Data alignment
            ALIGN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// External event select for injected
            /// group
            JEXTSEL: u4,
            /// External trigger enable for injected
            /// channels
            JEXTEN: u2,
            /// Start conversion of injected
            /// channels
            JSWSTART: u1,
            reserved10: u1,
            /// External event select for regular
            /// group
            EXTSEL: u4,
            /// External trigger enable for regular
            /// channels
            EXTEN: u2,
            /// Start conversion of regular
            /// channels
            SWSTART: u1,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x4001220c
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample time bits
            SMPx_x: u32,
        }), base_address + 0xc);

        /// address: 0x40012210
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample time bits
            SMPx_x: u32,
        }), base_address + 0x10);

        /// address: 0x40012214
        /// injected channel data offset register
        /// x
        pub const JOFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012218
        /// injected channel data offset register
        /// x
        pub const JOFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001221c
        /// injected channel data offset register
        /// x
        pub const JOFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012220
        /// injected channel data offset register
        /// x
        pub const JOFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET4: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012224
        /// watchdog higher threshold
        /// register
        pub const HTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x40012228
        /// watchdog lower threshold
        /// register
        pub const LTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x4001222c
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            SQ13: u5,
            /// 14th conversion in regular
            /// sequence
            SQ14: u5,
            /// 15th conversion in regular
            /// sequence
            SQ15: u5,
            /// 16th conversion in regular
            /// sequence
            SQ16: u5,
            /// Regular channel sequence
            /// length
            L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012230
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            SQ7: u5,
            /// 8th conversion in regular
            /// sequence
            SQ8: u5,
            /// 9th conversion in regular
            /// sequence
            SQ9: u5,
            /// 10th conversion in regular
            /// sequence
            SQ10: u5,
            /// 11th conversion in regular
            /// sequence
            SQ11: u5,
            /// 12th conversion in regular
            /// sequence
            SQ12: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012234
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            SQ1: u5,
            /// 2nd conversion in regular
            /// sequence
            SQ2: u5,
            /// 3rd conversion in regular
            /// sequence
            SQ3: u5,
            /// 4th conversion in regular
            /// sequence
            SQ4: u5,
            /// 5th conversion in regular
            /// sequence
            SQ5: u5,
            /// 6th conversion in regular
            /// sequence
            SQ6: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012238
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in injected
            /// sequence
            JSQ1: u5,
            /// 2nd conversion in injected
            /// sequence
            JSQ2: u5,
            /// 3rd conversion in injected
            /// sequence
            JSQ3: u5,
            /// 4th conversion in injected
            /// sequence
            JSQ4: u5,
            /// Injected sequence length
            JL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001223c
        /// injected data register x
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012240
        /// injected data register x
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012244
        /// injected data register x
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012248
        /// injected data register x
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001224c
        /// regular data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };

    /// Common ADC registers
    pub const ADC_Common = struct {
        pub const base_address = 0x40012300;

        /// address: 0x40012300
        /// ADC Common status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD1
            AWD1: u1,
            /// EOC1
            EOC1: u1,
            /// JEOC1
            JEOC1: u1,
            /// JSTRT1
            JSTRT1: u1,
            /// STRT1
            STRT1: u1,
            /// OVR1
            OVR1: u1,
            reserved0: u1,
            reserved1: u1,
            /// AWD2
            AWD2: u1,
            /// EOC2
            EOC2: u1,
            /// JEOC2
            JEOC2: u1,
            /// JSTRT2
            JSTRT2: u1,
            /// STRT2
            STRT2: u1,
            /// OVR2
            OVR2: u1,
            reserved2: u1,
            reserved3: u1,
            /// AWD3
            AWD3: u1,
            /// EOC3
            EOC3: u1,
            /// JEOC3
            JEOC3: u1,
            /// JSTRT3
            JSTRT3: u1,
            /// STRT3
            STRT3: u1,
            /// OVR3
            OVR3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x0);

        /// address: 0x40012304
        /// ADC common control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MULTI
            MULTI: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DELAY
            DELAY: u4,
            reserved3: u1,
            /// DDS
            DDS: u1,
            /// DMA
            DMA: u2,
            /// ADCPRE
            ADCPRE: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// VBATE
            VBATE: u1,
            /// TSVREFE
            TSVREFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012308
        /// ADC common regular data register for dual
        /// and triple modes
        pub const CDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA1
            DATA1: u16,
            /// DATA2
            DATA2: u16,
        }), base_address + 0x8);
    };

    /// Digital-to-analog converter
    pub const DAC = struct {
        pub const base_address = 0x40007400;

        /// address: 0x40007400
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 enable
            EN1: u1,
            /// DAC channel1 output buffer
            /// disable
            BOFF1: u1,
            /// DAC channel1 trigger
            /// enable
            TEN1: u1,
            /// DAC channel1 trigger
            /// selection
            TSEL1: u3,
            /// DAC channel1 noise/triangle wave
            /// generation enable
            WAVE1: u2,
            /// DAC channel1 mask/amplitude
            /// selector
            MAMP1: u4,
            /// DAC channel1 DMA enable
            DMAEN1: u1,
            /// DAC channel1 DMA Underrun Interrupt
            /// enable
            DMAUDRIE1: u1,
            reserved0: u1,
            reserved1: u1,
            /// DAC channel2 enable
            EN2: u1,
            /// DAC channel2 output buffer
            /// disable
            BOFF2: u1,
            /// DAC channel2 trigger
            /// enable
            TEN2: u1,
            /// DAC channel2 trigger
            /// selection
            TSEL2: u3,
            /// DAC channel2 noise/triangle wave
            /// generation enable
            WAVE2: u2,
            /// DAC channel2 mask/amplitude
            /// selector
            MAMP2: u4,
            /// DAC channel2 DMA enable
            DMAEN2: u1,
            /// DAC channel2 DMA underrun interrupt
            /// enable
            DMAUDRIE2: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x40007404
        /// software trigger register
        pub const SWTRIGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 software
            /// trigger
            SWTRIG1: u1,
            /// DAC channel2 software
            /// trigger
            SWTRIG2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40007408
        /// channel1 12-bit right-aligned data holding
        /// register
        pub const DHR12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000740c
        /// channel1 12-bit left aligned data holding
        /// register
        pub const DHR12L1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007410
        /// channel1 8-bit right aligned data holding
        /// register
        pub const DHR8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x40007414
        /// channel2 12-bit right aligned data holding
        /// register
        pub const DHR12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40007418
        /// channel2 12-bit left aligned data holding
        /// register
        pub const DHR12L2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000741c
        /// channel2 8-bit right-aligned data holding
        /// register
        pub const DHR8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x40007420
        /// Dual DAC 12-bit right-aligned data holding
        /// register
        pub const DHR12RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40007424
        /// DUAL DAC 12-bit left aligned data holding
        /// register
        pub const DHR12LD = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
        }), base_address + 0x24);

        /// address: 0x40007428
        /// DUAL DAC 8-bit right aligned data holding
        /// register
        pub const DHR8RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000742c
        /// channel1 data output register
        pub const DOR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 data output
            DACC1DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40007430
        /// channel2 data output register
        pub const DOR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 data output
            DACC2DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x30);

        /// address: 0x40007434
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// DAC channel1 DMA underrun
            /// flag
            DMAUDR1: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// DAC channel2 DMA underrun
            /// flag
            DMAUDR2: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);
    };

    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// power control register
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power deep sleep
            LPDS: u1,
            /// Power down deepsleep
            PDDS: u1,
            reserved0: u1,
            /// Clear standby flag
            CSBF: u1,
            /// Power voltage detector
            /// enable
            PVDE: u1,
            /// PVD level selection
            PLS: u3,
            /// Disable backup domain write
            /// protection
            DBP: u1,
            /// Flash power down in Stop
            /// mode
            FPDS: u1,
            /// Low-power regulator in deepsleep
            /// under-drive mode
            LPUDS: u1,
            /// Main regulator in deepsleep under-drive
            /// mode
            MRUDS: u1,
            reserved1: u1,
            /// ADCDC1
            ADCDC1: u1,
            /// Regulator voltage scaling output
            /// selection
            VOS: u2,
            /// Over-drive enable
            ODEN: u1,
            /// Over-drive switching
            /// enabled
            ODSWEN: u1,
            /// Under-drive enable in stop
            /// mode
            UDEN: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// power control/status register
        pub const CSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup internal flag
            WUIF: u1,
            /// Standby flag
            SBF: u1,
            /// PVD output
            PVDO: u1,
            /// Backup regulator ready
            BRR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Backup regulator enable
            BRE: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Regulator voltage scaling output
            /// selection ready bit
            VOSRDY: u1,
            reserved9: u1,
            /// Over-drive mode ready
            ODRDY: u1,
            /// Over-drive mode switching
            /// ready
            ODSWRDY: u1,
            /// Under-drive ready flag
            UDRDY: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0x40007008
        /// power control register
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear Wakeup Pin flag for
            /// PA0
            CWUPF1: u1,
            /// Clear Wakeup Pin flag for
            /// PA2
            CWUPF2: u1,
            /// Clear Wakeup Pin flag for
            /// PC1
            CWUPF3: u1,
            /// Clear Wakeup Pin flag for
            /// PC13
            CWUPF4: u1,
            /// Clear Wakeup Pin flag for
            /// PI8
            CWUPF5: u1,
            /// Clear Wakeup Pin flag for
            /// PI11
            CWUPF6: u1,
            reserved0: u1,
            reserved1: u1,
            /// Wakeup pin polarity bit for
            /// PA0
            WUPP1: u1,
            /// Wakeup pin polarity bit for
            /// PA2
            WUPP2: u1,
            /// Wakeup pin polarity bit for
            /// PC1
            WUPP3: u1,
            /// Wakeup pin polarity bit for
            /// PC13
            WUPP4: u1,
            /// Wakeup pin polarity bit for
            /// PI8
            WUPP5: u1,
            /// Wakeup pin polarity bit for
            /// PI11
            WUPP6: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x8);

        /// address: 0x4000700c
        /// power control/status register
        pub const CSR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Pin flag for PA0
            WUPF1: u1,
            /// Wakeup Pin flag for PA2
            WUPF2: u1,
            /// Wakeup Pin flag for PC1
            WUPF3: u1,
            /// Wakeup Pin flag for PC13
            WUPF4: u1,
            /// Wakeup Pin flag for PI8
            WUPF5: u1,
            /// Wakeup Pin flag for PI11
            WUPF6: u1,
            reserved0: u1,
            reserved1: u1,
            /// Enable Wakeup pin for PA0
            EWUP1: u1,
            /// Enable Wakeup pin for PA2
            EWUP2: u1,
            /// Enable Wakeup pin for PC1
            EWUP3: u1,
            /// Enable Wakeup pin for PC13
            EWUP4: u1,
            /// Enable Wakeup pin for PI8
            EWUP5: u1,
            /// Enable Wakeup pin for PI11
            EWUP6: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);
    };

    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const KR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value (write only, read
            /// 0000h)
            KEY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register
        pub const PR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register
        pub const RLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload
            /// value
            RL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value
            /// update
            PVU: u1,
            /// Watchdog counter reload value
            /// update
            RVU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40003010
        /// Window register
        pub const WINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter window
            /// value
            WIN: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x10);
    };

    /// Window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter (MSB to LSB)
            T: u7,
            /// Activation bit
            WDGA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        pub const CFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7,
            /// Timer base
            WDGTB0: u1,
            /// Timer base
            WDGTB1: u1,
            /// Early wakeup interrupt
            EWI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt
            /// flag
            EWIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Advanced-timers
    pub const TIM1 = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved0: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40010018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40010018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4001001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40010020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40010024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40010028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40010034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40010038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4001003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40010040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40010048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40010030
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40010044
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            /// Break 2 filter
            BK2F: u4,
            /// Break 2 enable
            BK2E: u1,
            /// Break 2 polarity
            BK2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x40010054
        /// capture/compare mode register 3 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Output Compare 5 mode
            OC5M3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Output Compare 6 mode
            OC6M3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40010058
        /// capture/compare register 5
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 5 value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x4001005c
        /// capture/compare register 6
        pub const CRR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 6 value
            CCR6: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40010060
        /// alternate function option register
        /// 1
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// BRK DFSDM_BREAK[0] enable
            BKDFBKE: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x60);

        /// address: 0x40010064
        /// alternate function option register
        /// 2
        pub const AF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK2 BKIN input enable
            BK2INE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// BRK2 DFSDM_BREAK enable
            BK2DFBKE: u1,
            /// BRK2 BKIN2 input polarity
            BK2INP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x64);
    };
    pub const TIM8 = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40010404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40010408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40010410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved0: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40010414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40010418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40010418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4001041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40010420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40010424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40010428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40010434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40010438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4001043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40010440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40010448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40010430
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40010444
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            /// Break 2 filter
            BK2F: u4,
            /// Break 2 enable
            BK2E: u1,
            /// Break 2 polarity
            BK2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x40010454
        /// capture/compare mode register 3 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Output Compare 5 mode
            OC5M3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Output Compare 6 mode
            OC6M3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40010458
        /// capture/compare register 5
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 5 value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x4001045c
        /// capture/compare register 6
        pub const CRR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 6 value
            CCR6: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40010460
        /// alternate function option register
        /// 1
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// BRK DFSDM_BREAK[0] enable
            BKDFBKE: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x60);

        /// address: 0x40010464
        /// alternate function option register
        /// 2
        pub const AF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK2 BKIN input enable
            BK2INE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// BRK2 DFSDM_BREAK enable
            BK2DFBKE: u1,
            /// BRK2 BKIN2 input polarity
            BK2INP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x64);
    };

    /// General purpose timers
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC1S
            CC1S: u2,
            /// OC1FE
            OC1FE: u1,
            /// OC1PE
            OC1PE: u1,
            /// OC1M
            OC1M: u3,
            /// OC1CE
            OC1CE: u1,
            /// CC2S
            CC2S: u2,
            /// OC2FE
            OC2FE: u1,
            /// OC2PE
            OC2PE: u1,
            /// OC2M
            OC2M: u3,
            /// OC2CE
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC3S
            CC3S: u2,
            /// OC3FE
            OC3FE: u1,
            /// OC3PE
            OC3PE: u1,
            /// OC3M
            OC3M: u3,
            /// OC3CE
            OC3CE: u1,
            /// CC4S
            CC4S: u2,
            /// OC4FE
            OC4FE: u1,
            /// OC4PE
            OC4PE: u1,
            /// OC4M
            OC4M: u3,
            /// O24CE
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1
            /// value
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2
            /// value
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000050
        /// TIM2 option register 1
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal trigger 1 remap
            ITR1_RMP: u1,
            /// External trigger remap
            ETR1_RMP: u1,
            /// Input Capture 4 remap
            TI4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x50);

        /// address: 0x40000060
        /// TIM2 option register 2
        pub const OR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ETR source selection
            ETRSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60);
    };

    /// General purpose timers
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC1S
            CC1S: u2,
            /// OC1FE
            OC1FE: u1,
            /// OC1PE
            OC1PE: u1,
            /// OC1M
            OC1M: u3,
            /// OC1CE
            OC1CE: u1,
            /// CC2S
            CC2S: u2,
            /// OC2FE
            OC2FE: u1,
            /// OC2PE
            OC2PE: u1,
            /// OC2M
            OC2M: u3,
            /// OC2CE
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC3S
            CC3S: u2,
            /// OC3FE
            OC3FE: u1,
            /// OC3PE
            OC3PE: u1,
            /// OC3M
            OC3M: u3,
            /// OC3CE
            OC3CE: u1,
            /// CC4S
            CC4S: u2,
            /// OC4FE
            OC4FE: u1,
            /// OC4PE
            OC4PE: u1,
            /// OC4M
            OC4M: u3,
            /// O24CE
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1
            /// value
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2
            /// value
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000450
        /// TIM3 option register 1
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Capture 1 remap
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);

        /// address: 0x40000460
        /// TIM3 option register 2
        pub const OR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ETR source selection
            ETRSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60);
    };

    /// General purpose timers
    pub const TIM4 = struct {
        pub const base_address = 0x40000800;

        /// address: 0x40000800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000080c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000818
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC1S
            CC1S: u2,
            /// OC1FE
            OC1FE: u1,
            /// OC1PE
            OC1PE: u1,
            /// OC1M
            OC1M: u3,
            /// OC1CE
            OC1CE: u1,
            /// CC2S
            CC2S: u2,
            /// OC2FE
            OC2FE: u1,
            /// OC2PE
            OC2PE: u1,
            /// OC2M
            OC2M: u3,
            /// OC2CE
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC3S
            CC3S: u2,
            /// OC3FE
            OC3FE: u1,
            /// OC3PE
            OC3PE: u1,
            /// OC3M
            OC3M: u3,
            /// OC3CE
            OC3CE: u1,
            /// CC4S
            CC4S: u2,
            /// OC4FE
            OC4FE: u1,
            /// OC4PE
            OC4PE: u1,
            /// OC4M
            OC4M: u3,
            /// O24CE
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000824
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000082c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1
            /// value
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000838
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2
            /// value
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000083c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000840
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000848
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000084c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const TIM5 = struct {
        pub const base_address = 0x40000c00;

        /// address: 0x40000c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40000c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC1S
            CC1S: u2,
            /// OC1FE
            OC1FE: u1,
            /// OC1PE
            OC1PE: u1,
            /// OC1M
            OC1M: u3,
            /// OC1CE
            OC1CE: u1,
            /// CC2S
            CC2S: u2,
            /// OC2FE
            OC2FE: u1,
            /// OC2PE
            OC2PE: u1,
            /// OC2M
            OC2M: u3,
            /// OC2CE
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000c1c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC3S
            CC3S: u2,
            /// OC3FE
            OC3FE: u1,
            /// OC3PE
            OC3PE: u1,
            /// OC3M
            OC3M: u3,
            /// OC3CE
            OC3CE: u1,
            /// CC4S
            CC4S: u2,
            /// OC4FE
            OC4FE: u1,
            /// OC4PE
            OC4PE: u1,
            /// OC4M
            OC4M: u3,
            /// O24CE
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000c1c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000c24
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40000c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1
            /// value
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2
            /// value
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x40000c3c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000c40
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000c48
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x40000c4c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };

    /// General purpose timers
    pub const TIM9 = struct {
        pub const base_address = 0x40014000;

        /// address: 0x40014000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40014008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x4001400c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt enable
            TIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x40014010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40014014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40014018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40014018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40014020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40014024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40014028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001402c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);
    };
    pub const TIM12 = struct {
        pub const base_address = 0x40001800;

        /// address: 0x40001800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40001808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x4000180c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt enable
            TIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x40001810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40001814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40001818
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40001818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40001820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40001824
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000182c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40001834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40001838
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);
    };

    /// General-purpose-timers
    pub const TIM10 = struct {
        pub const base_address = 0x40014400;

        /// address: 0x40014400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x4001440c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40014410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40014418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40014418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40014428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001442c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x40014450
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM11 Input 1 remapping
            /// capability
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);
    };
    pub const TIM11 = struct {
        pub const base_address = 0x40014800;

        /// address: 0x40014800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x4001480c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40014810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40014818
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40014818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014824
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40014828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001482c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x40014850
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM11 Input 1 remapping
            /// capability
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);
    };
    pub const TIM13 = struct {
        pub const base_address = 0x40001c00;

        /// address: 0x40001c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40001c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40001c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40001c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40001c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40001c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40001c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40001c24
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40001c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40001c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40001c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x40001c50
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM11 Input 1 remapping
            /// capability
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);
    };
    pub const TIM14 = struct {
        pub const base_address = 0x40002000;

        /// address: 0x40002000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x4000200c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40002010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40002014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40002018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40002018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40002020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40002024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40002028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000202c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40002034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40002008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x40002050
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM11 Input 1 remapping
            /// capability
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);
    };

    /// Basic timers
    pub const TIM6 = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000100c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000102c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };
    pub const TIM7 = struct {
        pub const base_address = 0x40001400;

        /// address: 0x40001400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000140c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000142c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };

    /// Ethernet: media access control
    /// (MAC)
    pub const Ethernet_MAC = struct {
        pub const base_address = 0x40028000;

        /// address: 0x40028000
        /// Ethernet MAC configuration
        /// register
        pub const MACCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// RE
            RE: u1,
            /// TE
            TE: u1,
            /// DC
            DC: u1,
            /// BL
            BL: u2,
            /// APCS
            APCS: u1,
            reserved2: u1,
            /// RD
            RD: u1,
            /// IPCO
            IPCO: u1,
            /// DM
            DM: u1,
            /// LM
            LM: u1,
            /// ROD
            ROD: u1,
            /// FES
            FES: u1,
            reserved3: u1,
            /// CSD
            CSD: u1,
            /// IFG
            IFG: u3,
            reserved4: u1,
            reserved5: u1,
            /// JD
            JD: u1,
            /// WD
            WD: u1,
            reserved6: u1,
            /// CSTF
            CSTF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40028004
        /// Ethernet MAC frame filter
        /// register
        pub const MACFFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PM
            PM: u1,
            /// HU
            HU: u1,
            /// HM
            HM: u1,
            /// DAIF
            DAIF: u1,
            /// RAM
            RAM: u1,
            /// BFD
            BFD: u1,
            /// PCF
            PCF: u1,
            /// SAIF
            SAIF: u1,
            /// SAF
            SAF: u1,
            /// HPF
            HPF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// RA
            RA: u1,
        }), base_address + 0x4);

        /// address: 0x40028008
        /// Ethernet MAC hash table high
        /// register
        pub const MACHTHR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HTH
            HTH: u32,
        }), base_address + 0x8);

        /// address: 0x4002800c
        /// Ethernet MAC hash table low
        /// register
        pub const MACHTLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HTL
            HTL: u32,
        }), base_address + 0xc);

        /// address: 0x40028010
        /// Ethernet MAC MII address
        /// register
        pub const MACMIIAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MB
            MB: u1,
            /// MW
            MW: u1,
            /// CR
            CR: u3,
            reserved0: u1,
            /// MR
            MR: u5,
            /// PA
            PA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40028014
        /// Ethernet MAC MII data register
        pub const MACMIIDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TD
            TD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40028018
        /// Ethernet MAC flow control
        /// register
        pub const MACFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FCB
            FCB: u1,
            /// TFCE
            TFCE: u1,
            /// RFCE
            RFCE: u1,
            /// UPFD
            UPFD: u1,
            /// PLT
            PLT: u2,
            reserved0: u1,
            /// ZQPD
            ZQPD: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// PT
            PT: u16,
        }), base_address + 0x18);

        /// address: 0x4002801c
        /// Ethernet MAC VLAN tag register
        pub const MACVLANTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// VLANTI
            VLANTI: u16,
            /// VLANTC
            VLANTC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x4002802c
        /// Ethernet MAC PMT control and status
        /// register
        pub const MACPMTCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD
            PD: u1,
            /// MPE
            MPE: u1,
            /// WFE
            WFE: u1,
            reserved0: u1,
            reserved1: u1,
            /// MPR
            MPR: u1,
            /// WFR
            WFR: u1,
            reserved2: u1,
            reserved3: u1,
            /// GU
            GU: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// WFFRPR
            WFFRPR: u1,
        }), base_address + 0x2c);

        /// address: 0x40028034
        /// Ethernet MAC debug register
        pub const MACDBGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CR
            CR: u1,
            /// CSR
            CSR: u1,
            /// ROR
            ROR: u1,
            /// MCF
            MCF: u1,
            /// MCP
            MCP: u1,
            /// MCFHP
            MCFHP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x34);

        /// address: 0x40028038
        /// Ethernet MAC interrupt status
        /// register
        pub const MACSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PMTS
            PMTS: u1,
            /// MMCS
            MMCS: u1,
            /// MMCRS
            MMCRS: u1,
            /// MMCTS
            MMCTS: u1,
            reserved3: u1,
            reserved4: u1,
            /// TSTS
            TSTS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x38);

        /// address: 0x4002803c
        /// Ethernet MAC interrupt mask
        /// register
        pub const MACIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PMTIM
            PMTIM: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// TSTIM
            TSTIM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x3c);

        /// address: 0x40028040
        /// Ethernet MAC address 0 high
        /// register
        pub const MACA0HR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MAC address0 high
            MACA0H: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Always 1
            MO: u1,
        }), base_address + 0x40);

        /// address: 0x40028044
        /// Ethernet MAC address 0 low
        /// register
        pub const MACA0LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0
            MACA0L: u32,
        }), base_address + 0x44);

        /// address: 0x40028048
        /// Ethernet MAC address 1 high
        /// register
        pub const MACA1HR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MACA1H
            MACA1H: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// MBC
            MBC: u6,
            /// SA
            SA: u1,
            /// AE
            AE: u1,
        }), base_address + 0x48);

        /// address: 0x4002804c
        /// Ethernet MAC address1 low
        /// register
        pub const MACA1LR = @intToPtr(*volatile u32, base_address + 0x4c);

        /// address: 0x40028050
        /// Ethernet MAC address 2 high
        /// register
        pub const MACA2HR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MAC2AH
            MAC2AH: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// MBC
            MBC: u6,
            /// SA
            SA: u1,
            /// AE
            AE: u1,
        }), base_address + 0x50);

        /// address: 0x40028054
        /// Ethernet MAC address 2 low
        /// register
        pub const MACA2LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MACA2L
            MACA2L: u31,
            padding0: u1,
        }), base_address + 0x54);

        /// address: 0x40028058
        /// Ethernet MAC address 3 high
        /// register
        pub const MACA3HR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MACA3H
            MACA3H: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// MBC
            MBC: u6,
            /// SA
            SA: u1,
            /// AE
            AE: u1,
        }), base_address + 0x58);

        /// address: 0x4002805c
        /// Ethernet MAC address 3 low
        /// register
        pub const MACA3LR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBCA3L
            MBCA3L: u32,
        }), base_address + 0x5c);

        /// address: 0x40028060
        /// Ethernet MAC remote wakeup frame filter
        /// register
        pub const MACRWUFFER = @intToPtr(*volatile u32, base_address + 0x60);
    };

    /// Cryptographic processor
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent Data register
        pub const IDR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x8);

        /// address: 0x4002300c
        /// Initial CRC value
        pub const INIT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programmable initial CRC
            /// value
            CRC_INIT: u32,
        }), base_address + 0xc);

        /// address: 0x40023010
        /// CRC polynomial
        pub const POL = @intToPtr(*volatile u32, base_address + 0x10);
    };

    /// Controller area network
    pub const CAN1 = struct {
        pub const base_address = 0x40006400;

        /// address: 0x40006400
        /// master control register
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INRQ
            INRQ: u1,
            /// SLEEP
            SLEEP: u1,
            /// TXFP
            TXFP: u1,
            /// RFLM
            RFLM: u1,
            /// NART
            NART: u1,
            /// AWUM
            AWUM: u1,
            /// ABOM
            ABOM: u1,
            /// TTCM
            TTCM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RESET
            RESET: u1,
            /// DBF
            DBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006404
        /// master status register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INAK
            INAK: u1,
            /// SLAK
            SLAK: u1,
            /// ERRI
            ERRI: u1,
            /// WKUI
            WKUI: u1,
            /// SLAKI
            SLAKI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TXM
            TXM: u1,
            /// RXM
            RXM: u1,
            /// SAMP
            SAMP: u1,
            /// RX
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006408
        /// transmit status register
        pub const TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RQCP0
            RQCP0: u1,
            /// TXOK0
            TXOK0: u1,
            /// ALST0
            ALST0: u1,
            /// TERR0
            TERR0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ABRQ0
            ABRQ0: u1,
            /// RQCP1
            RQCP1: u1,
            /// TXOK1
            TXOK1: u1,
            /// ALST1
            ALST1: u1,
            /// TERR1
            TERR1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ABRQ1
            ABRQ1: u1,
            /// RQCP2
            RQCP2: u1,
            /// TXOK2
            TXOK2: u1,
            /// ALST2
            ALST2: u1,
            /// TERR2
            TERR2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ABRQ2
            ABRQ2: u1,
            /// CODE
            CODE: u2,
            /// Lowest priority flag for mailbox
            /// 0
            TME0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            TME1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            TME2: u1,
            /// Lowest priority flag for mailbox
            /// 0
            LOW0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            LOW1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            LOW2: u1,
        }), base_address + 0x8);

        /// address: 0x4000640c
        /// receive FIFO 0 register
        pub const RF0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP0
            FMP0: u2,
            reserved0: u1,
            /// FULL0
            FULL0: u1,
            /// FOVR0
            FOVR0: u1,
            /// RFOM0
            RFOM0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006410
        /// receive FIFO 1 register
        pub const RF1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP1
            FMP1: u2,
            reserved0: u1,
            /// FULL1
            FULL1: u1,
            /// FOVR1
            FOVR1: u1,
            /// RFOM1
            RFOM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006414
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TMEIE
            TMEIE: u1,
            /// FMPIE0
            FMPIE0: u1,
            /// FFIE0
            FFIE0: u1,
            /// FOVIE0
            FOVIE0: u1,
            /// FMPIE1
            FMPIE1: u1,
            /// FFIE1
            FFIE1: u1,
            /// FOVIE1
            FOVIE1: u1,
            reserved0: u1,
            /// EWGIE
            EWGIE: u1,
            /// EPVIE
            EPVIE: u1,
            /// BOFIE
            BOFIE: u1,
            /// LECIE
            LECIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ERRIE
            ERRIE: u1,
            /// WKUIE
            WKUIE: u1,
            /// SLKIE
            SLKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006418
        /// interrupt enable register
        pub const ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EWGF
            EWGF: u1,
            /// EPVF
            EPVF: u1,
            /// BOFF
            BOFF: u1,
            reserved0: u1,
            /// LEC
            LEC: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TEC
            TEC: u8,
            /// REC
            REC: u8,
        }), base_address + 0x18);

        /// address: 0x4000641c
        /// bit timing register
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRP
            BRP: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TS1
            TS1: u4,
            /// TS2
            TS2: u3,
            reserved6: u1,
            /// SJW
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LBKM
            LBKM: u1,
            /// SILM
            SILM: u1,
        }), base_address + 0x1c);

        /// address: 0x40006580
        /// TX mailbox identifier register
        pub const TI0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x180);

        /// address: 0x40006584
        /// mailbox data length control and time stamp
        /// register
        pub const TDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x184);

        /// address: 0x40006588
        /// mailbox data low register
        pub const TDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x188);

        /// address: 0x4000658c
        /// mailbox data high register
        pub const TDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006590
        /// mailbox identifier register
        pub const TI1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x190);

        /// address: 0x40006594
        /// mailbox data length control and time stamp
        /// register
        pub const TDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x194);

        /// address: 0x40006598
        /// mailbox data low register
        pub const TDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x198);

        /// address: 0x4000659c
        /// mailbox data high register
        pub const TDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x19c);

        /// address: 0x400065a0
        /// mailbox identifier register
        pub const TI2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400065a4
        /// mailbox data length control and time stamp
        /// register
        pub const TDT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x1a4);

        /// address: 0x400065a8
        /// mailbox data low register
        pub const TDL2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400065ac
        /// mailbox data high register
        pub const TDH2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400065b0
        /// receive FIFO mailbox identifier
        /// register
        pub const RI0R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400065b4
        /// mailbox data high register
        pub const RDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1b4);

        /// address: 0x400065b8
        /// mailbox data high register
        pub const RDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400065bc
        /// receive FIFO mailbox data high
        /// register
        pub const RDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400065c0
        /// mailbox data high register
        pub const RI1R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400065c4
        /// mailbox data high register
        pub const RDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1c4);

        /// address: 0x400065c8
        /// mailbox data high register
        pub const RDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400065cc
        /// mailbox data high register
        pub const RDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006600
        /// filter master register
        pub const FMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FINIT
            FINIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// CAN2SB
            CAN2SB: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40006604
        /// filter mode register
        pub const FM1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FBM0: u1,
            /// Filter mode
            FBM1: u1,
            /// Filter mode
            FBM2: u1,
            /// Filter mode
            FBM3: u1,
            /// Filter mode
            FBM4: u1,
            /// Filter mode
            FBM5: u1,
            /// Filter mode
            FBM6: u1,
            /// Filter mode
            FBM7: u1,
            /// Filter mode
            FBM8: u1,
            /// Filter mode
            FBM9: u1,
            /// Filter mode
            FBM10: u1,
            /// Filter mode
            FBM11: u1,
            /// Filter mode
            FBM12: u1,
            /// Filter mode
            FBM13: u1,
            /// Filter mode
            FBM14: u1,
            /// Filter mode
            FBM15: u1,
            /// Filter mode
            FBM16: u1,
            /// Filter mode
            FBM17: u1,
            /// Filter mode
            FBM18: u1,
            /// Filter mode
            FBM19: u1,
            /// Filter mode
            FBM20: u1,
            /// Filter mode
            FBM21: u1,
            /// Filter mode
            FBM22: u1,
            /// Filter mode
            FBM23: u1,
            /// Filter mode
            FBM24: u1,
            /// Filter mode
            FBM25: u1,
            /// Filter mode
            FBM26: u1,
            /// Filter mode
            FBM27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x204);

        /// address: 0x4000660c
        /// filter scale register
        pub const FS1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FSC0: u1,
            /// Filter scale configuration
            FSC1: u1,
            /// Filter scale configuration
            FSC2: u1,
            /// Filter scale configuration
            FSC3: u1,
            /// Filter scale configuration
            FSC4: u1,
            /// Filter scale configuration
            FSC5: u1,
            /// Filter scale configuration
            FSC6: u1,
            /// Filter scale configuration
            FSC7: u1,
            /// Filter scale configuration
            FSC8: u1,
            /// Filter scale configuration
            FSC9: u1,
            /// Filter scale configuration
            FSC10: u1,
            /// Filter scale configuration
            FSC11: u1,
            /// Filter scale configuration
            FSC12: u1,
            /// Filter scale configuration
            FSC13: u1,
            /// Filter scale configuration
            FSC14: u1,
            /// Filter scale configuration
            FSC15: u1,
            /// Filter scale configuration
            FSC16: u1,
            /// Filter scale configuration
            FSC17: u1,
            /// Filter scale configuration
            FSC18: u1,
            /// Filter scale configuration
            FSC19: u1,
            /// Filter scale configuration
            FSC20: u1,
            /// Filter scale configuration
            FSC21: u1,
            /// Filter scale configuration
            FSC22: u1,
            /// Filter scale configuration
            FSC23: u1,
            /// Filter scale configuration
            FSC24: u1,
            /// Filter scale configuration
            FSC25: u1,
            /// Filter scale configuration
            FSC26: u1,
            /// Filter scale configuration
            FSC27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20c);

        /// address: 0x40006614
        /// filter FIFO assignment
        /// register
        pub const FFA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter FIFO assignment for filter
            /// 0
            FFA0: u1,
            /// Filter FIFO assignment for filter
            /// 1
            FFA1: u1,
            /// Filter FIFO assignment for filter
            /// 2
            FFA2: u1,
            /// Filter FIFO assignment for filter
            /// 3
            FFA3: u1,
            /// Filter FIFO assignment for filter
            /// 4
            FFA4: u1,
            /// Filter FIFO assignment for filter
            /// 5
            FFA5: u1,
            /// Filter FIFO assignment for filter
            /// 6
            FFA6: u1,
            /// Filter FIFO assignment for filter
            /// 7
            FFA7: u1,
            /// Filter FIFO assignment for filter
            /// 8
            FFA8: u1,
            /// Filter FIFO assignment for filter
            /// 9
            FFA9: u1,
            /// Filter FIFO assignment for filter
            /// 10
            FFA10: u1,
            /// Filter FIFO assignment for filter
            /// 11
            FFA11: u1,
            /// Filter FIFO assignment for filter
            /// 12
            FFA12: u1,
            /// Filter FIFO assignment for filter
            /// 13
            FFA13: u1,
            /// Filter FIFO assignment for filter
            /// 14
            FFA14: u1,
            /// Filter FIFO assignment for filter
            /// 15
            FFA15: u1,
            /// Filter FIFO assignment for filter
            /// 16
            FFA16: u1,
            /// Filter FIFO assignment for filter
            /// 17
            FFA17: u1,
            /// Filter FIFO assignment for filter
            /// 18
            FFA18: u1,
            /// Filter FIFO assignment for filter
            /// 19
            FFA19: u1,
            /// Filter FIFO assignment for filter
            /// 20
            FFA20: u1,
            /// Filter FIFO assignment for filter
            /// 21
            FFA21: u1,
            /// Filter FIFO assignment for filter
            /// 22
            FFA22: u1,
            /// Filter FIFO assignment for filter
            /// 23
            FFA23: u1,
            /// Filter FIFO assignment for filter
            /// 24
            FFA24: u1,
            /// Filter FIFO assignment for filter
            /// 25
            FFA25: u1,
            /// Filter FIFO assignment for filter
            /// 26
            FFA26: u1,
            /// Filter FIFO assignment for filter
            /// 27
            FFA27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x214);

        /// address: 0x4000661c
        /// filter activation register
        pub const FA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter active
            FACT0: u1,
            /// Filter active
            FACT1: u1,
            /// Filter active
            FACT2: u1,
            /// Filter active
            FACT3: u1,
            /// Filter active
            FACT4: u1,
            /// Filter active
            FACT5: u1,
            /// Filter active
            FACT6: u1,
            /// Filter active
            FACT7: u1,
            /// Filter active
            FACT8: u1,
            /// Filter active
            FACT9: u1,
            /// Filter active
            FACT10: u1,
            /// Filter active
            FACT11: u1,
            /// Filter active
            FACT12: u1,
            /// Filter active
            FACT13: u1,
            /// Filter active
            FACT14: u1,
            /// Filter active
            FACT15: u1,
            /// Filter active
            FACT16: u1,
            /// Filter active
            FACT17: u1,
            /// Filter active
            FACT18: u1,
            /// Filter active
            FACT19: u1,
            /// Filter active
            FACT20: u1,
            /// Filter active
            FACT21: u1,
            /// Filter active
            FACT22: u1,
            /// Filter active
            FACT23: u1,
            /// Filter active
            FACT24: u1,
            /// Filter active
            FACT25: u1,
            /// Filter active
            FACT26: u1,
            /// Filter active
            FACT27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x21c);

        /// address: 0x40006640
        /// Filter bank 0 register 1
        pub const F0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x240);

        /// address: 0x40006644
        /// Filter bank 0 register 2
        pub const F0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x244);

        /// address: 0x40006648
        /// Filter bank 1 register 1
        pub const F1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x248);

        /// address: 0x4000664c
        /// Filter bank 1 register 2
        pub const F1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006650
        /// Filter bank 2 register 1
        pub const F2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x250);

        /// address: 0x40006654
        /// Filter bank 2 register 2
        pub const F2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x254);

        /// address: 0x40006658
        /// Filter bank 3 register 1
        pub const F3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x258);

        /// address: 0x4000665c
        /// Filter bank 3 register 2
        pub const F3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006660
        /// Filter bank 4 register 1
        pub const F4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x260);

        /// address: 0x40006664
        /// Filter bank 4 register 2
        pub const F4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x264);

        /// address: 0x40006668
        /// Filter bank 5 register 1
        pub const F5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x268);

        /// address: 0x4000666c
        /// Filter bank 5 register 2
        pub const F5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006670
        /// Filter bank 6 register 1
        pub const F6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x270);

        /// address: 0x40006674
        /// Filter bank 6 register 2
        pub const F6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x274);

        /// address: 0x40006678
        /// Filter bank 7 register 1
        pub const F7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x278);

        /// address: 0x4000667c
        /// Filter bank 7 register 2
        pub const F7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006680
        /// Filter bank 8 register 1
        pub const F8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x280);

        /// address: 0x40006684
        /// Filter bank 8 register 2
        pub const F8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x284);

        /// address: 0x40006688
        /// Filter bank 9 register 1
        pub const F9R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x288);

        /// address: 0x4000668c
        /// Filter bank 9 register 2
        pub const F9R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006690
        /// Filter bank 10 register 1
        pub const F10R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x290);

        /// address: 0x40006694
        /// Filter bank 10 register 2
        pub const F10R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x294);

        /// address: 0x40006698
        /// Filter bank 11 register 1
        pub const F11R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x298);

        /// address: 0x4000669c
        /// Filter bank 11 register 2
        pub const F11R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x29c);

        /// address: 0x400066a0
        /// Filter bank 4 register 1
        pub const F12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a0);

        /// address: 0x400066a4
        /// Filter bank 12 register 2
        pub const F12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a4);

        /// address: 0x400066a8
        /// Filter bank 13 register 1
        pub const F13R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a8);

        /// address: 0x400066ac
        /// Filter bank 13 register 2
        pub const F13R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ac);

        /// address: 0x400066b0
        /// Filter bank 14 register 1
        pub const F14R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b0);

        /// address: 0x400066b4
        /// Filter bank 14 register 2
        pub const F14R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b4);

        /// address: 0x400066b8
        /// Filter bank 15 register 1
        pub const F15R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b8);

        /// address: 0x400066bc
        /// Filter bank 15 register 2
        pub const F15R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2bc);

        /// address: 0x400066c0
        /// Filter bank 16 register 1
        pub const F16R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c0);

        /// address: 0x400066c4
        /// Filter bank 16 register 2
        pub const F16R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c4);

        /// address: 0x400066c8
        /// Filter bank 17 register 1
        pub const F17R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c8);

        /// address: 0x400066cc
        /// Filter bank 17 register 2
        pub const F17R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2cc);

        /// address: 0x400066d0
        /// Filter bank 18 register 1
        pub const F18R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d0);

        /// address: 0x400066d4
        /// Filter bank 18 register 2
        pub const F18R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d4);

        /// address: 0x400066d8
        /// Filter bank 19 register 1
        pub const F19R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d8);

        /// address: 0x400066dc
        /// Filter bank 19 register 2
        pub const F19R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2dc);

        /// address: 0x400066e0
        /// Filter bank 20 register 1
        pub const F20R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e0);

        /// address: 0x400066e4
        /// Filter bank 20 register 2
        pub const F20R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e4);

        /// address: 0x400066e8
        /// Filter bank 21 register 1
        pub const F21R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e8);

        /// address: 0x400066ec
        /// Filter bank 21 register 2
        pub const F21R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ec);

        /// address: 0x400066f0
        /// Filter bank 22 register 1
        pub const F22R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f0);

        /// address: 0x400066f4
        /// Filter bank 22 register 2
        pub const F22R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f4);

        /// address: 0x400066f8
        /// Filter bank 23 register 1
        pub const F23R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f8);

        /// address: 0x400066fc
        /// Filter bank 23 register 2
        pub const F23R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40006700
        /// Filter bank 24 register 1
        pub const F24R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x300);

        /// address: 0x40006704
        /// Filter bank 24 register 2
        pub const F24R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x304);

        /// address: 0x40006708
        /// Filter bank 25 register 1
        pub const F25R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x308);

        /// address: 0x4000670c
        /// Filter bank 25 register 2
        pub const F25R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x30c);

        /// address: 0x40006710
        /// Filter bank 26 register 1
        pub const F26R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x310);

        /// address: 0x40006714
        /// Filter bank 26 register 2
        pub const F26R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x314);

        /// address: 0x40006718
        /// Filter bank 27 register 1
        pub const F27R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x318);

        /// address: 0x4000671c
        /// Filter bank 27 register 2
        pub const F27R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x31c);
    };
    pub const CAN2 = struct {
        pub const base_address = 0x40006800;

        /// address: 0x40006800
        /// master control register
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INRQ
            INRQ: u1,
            /// SLEEP
            SLEEP: u1,
            /// TXFP
            TXFP: u1,
            /// RFLM
            RFLM: u1,
            /// NART
            NART: u1,
            /// AWUM
            AWUM: u1,
            /// ABOM
            ABOM: u1,
            /// TTCM
            TTCM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RESET
            RESET: u1,
            /// DBF
            DBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006804
        /// master status register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INAK
            INAK: u1,
            /// SLAK
            SLAK: u1,
            /// ERRI
            ERRI: u1,
            /// WKUI
            WKUI: u1,
            /// SLAKI
            SLAKI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TXM
            TXM: u1,
            /// RXM
            RXM: u1,
            /// SAMP
            SAMP: u1,
            /// RX
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006808
        /// transmit status register
        pub const TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RQCP0
            RQCP0: u1,
            /// TXOK0
            TXOK0: u1,
            /// ALST0
            ALST0: u1,
            /// TERR0
            TERR0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ABRQ0
            ABRQ0: u1,
            /// RQCP1
            RQCP1: u1,
            /// TXOK1
            TXOK1: u1,
            /// ALST1
            ALST1: u1,
            /// TERR1
            TERR1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ABRQ1
            ABRQ1: u1,
            /// RQCP2
            RQCP2: u1,
            /// TXOK2
            TXOK2: u1,
            /// ALST2
            ALST2: u1,
            /// TERR2
            TERR2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ABRQ2
            ABRQ2: u1,
            /// CODE
            CODE: u2,
            /// Lowest priority flag for mailbox
            /// 0
            TME0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            TME1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            TME2: u1,
            /// Lowest priority flag for mailbox
            /// 0
            LOW0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            LOW1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            LOW2: u1,
        }), base_address + 0x8);

        /// address: 0x4000680c
        /// receive FIFO 0 register
        pub const RF0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP0
            FMP0: u2,
            reserved0: u1,
            /// FULL0
            FULL0: u1,
            /// FOVR0
            FOVR0: u1,
            /// RFOM0
            RFOM0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006810
        /// receive FIFO 1 register
        pub const RF1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP1
            FMP1: u2,
            reserved0: u1,
            /// FULL1
            FULL1: u1,
            /// FOVR1
            FOVR1: u1,
            /// RFOM1
            RFOM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006814
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TMEIE
            TMEIE: u1,
            /// FMPIE0
            FMPIE0: u1,
            /// FFIE0
            FFIE0: u1,
            /// FOVIE0
            FOVIE0: u1,
            /// FMPIE1
            FMPIE1: u1,
            /// FFIE1
            FFIE1: u1,
            /// FOVIE1
            FOVIE1: u1,
            reserved0: u1,
            /// EWGIE
            EWGIE: u1,
            /// EPVIE
            EPVIE: u1,
            /// BOFIE
            BOFIE: u1,
            /// LECIE
            LECIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ERRIE
            ERRIE: u1,
            /// WKUIE
            WKUIE: u1,
            /// SLKIE
            SLKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006818
        /// interrupt enable register
        pub const ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EWGF
            EWGF: u1,
            /// EPVF
            EPVF: u1,
            /// BOFF
            BOFF: u1,
            reserved0: u1,
            /// LEC
            LEC: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TEC
            TEC: u8,
            /// REC
            REC: u8,
        }), base_address + 0x18);

        /// address: 0x4000681c
        /// bit timing register
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRP
            BRP: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TS1
            TS1: u4,
            /// TS2
            TS2: u3,
            reserved6: u1,
            /// SJW
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LBKM
            LBKM: u1,
            /// SILM
            SILM: u1,
        }), base_address + 0x1c);

        /// address: 0x40006980
        /// TX mailbox identifier register
        pub const TI0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x180);

        /// address: 0x40006984
        /// mailbox data length control and time stamp
        /// register
        pub const TDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x184);

        /// address: 0x40006988
        /// mailbox data low register
        pub const TDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x188);

        /// address: 0x4000698c
        /// mailbox data high register
        pub const TDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006990
        /// mailbox identifier register
        pub const TI1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x190);

        /// address: 0x40006994
        /// mailbox data length control and time stamp
        /// register
        pub const TDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x194);

        /// address: 0x40006998
        /// mailbox data low register
        pub const TDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x198);

        /// address: 0x4000699c
        /// mailbox data high register
        pub const TDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x19c);

        /// address: 0x400069a0
        /// mailbox identifier register
        pub const TI2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400069a4
        /// mailbox data length control and time stamp
        /// register
        pub const TDT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x1a4);

        /// address: 0x400069a8
        /// mailbox data low register
        pub const TDL2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400069ac
        /// mailbox data high register
        pub const TDH2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400069b0
        /// receive FIFO mailbox identifier
        /// register
        pub const RI0R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400069b4
        /// mailbox data high register
        pub const RDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1b4);

        /// address: 0x400069b8
        /// mailbox data high register
        pub const RDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400069bc
        /// receive FIFO mailbox data high
        /// register
        pub const RDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400069c0
        /// mailbox data high register
        pub const RI1R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400069c4
        /// mailbox data high register
        pub const RDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1c4);

        /// address: 0x400069c8
        /// mailbox data high register
        pub const RDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400069cc
        /// mailbox data high register
        pub const RDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006a00
        /// filter master register
        pub const FMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FINIT
            FINIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// CAN2SB
            CAN2SB: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40006a04
        /// filter mode register
        pub const FM1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FBM0: u1,
            /// Filter mode
            FBM1: u1,
            /// Filter mode
            FBM2: u1,
            /// Filter mode
            FBM3: u1,
            /// Filter mode
            FBM4: u1,
            /// Filter mode
            FBM5: u1,
            /// Filter mode
            FBM6: u1,
            /// Filter mode
            FBM7: u1,
            /// Filter mode
            FBM8: u1,
            /// Filter mode
            FBM9: u1,
            /// Filter mode
            FBM10: u1,
            /// Filter mode
            FBM11: u1,
            /// Filter mode
            FBM12: u1,
            /// Filter mode
            FBM13: u1,
            /// Filter mode
            FBM14: u1,
            /// Filter mode
            FBM15: u1,
            /// Filter mode
            FBM16: u1,
            /// Filter mode
            FBM17: u1,
            /// Filter mode
            FBM18: u1,
            /// Filter mode
            FBM19: u1,
            /// Filter mode
            FBM20: u1,
            /// Filter mode
            FBM21: u1,
            /// Filter mode
            FBM22: u1,
            /// Filter mode
            FBM23: u1,
            /// Filter mode
            FBM24: u1,
            /// Filter mode
            FBM25: u1,
            /// Filter mode
            FBM26: u1,
            /// Filter mode
            FBM27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x204);

        /// address: 0x40006a0c
        /// filter scale register
        pub const FS1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FSC0: u1,
            /// Filter scale configuration
            FSC1: u1,
            /// Filter scale configuration
            FSC2: u1,
            /// Filter scale configuration
            FSC3: u1,
            /// Filter scale configuration
            FSC4: u1,
            /// Filter scale configuration
            FSC5: u1,
            /// Filter scale configuration
            FSC6: u1,
            /// Filter scale configuration
            FSC7: u1,
            /// Filter scale configuration
            FSC8: u1,
            /// Filter scale configuration
            FSC9: u1,
            /// Filter scale configuration
            FSC10: u1,
            /// Filter scale configuration
            FSC11: u1,
            /// Filter scale configuration
            FSC12: u1,
            /// Filter scale configuration
            FSC13: u1,
            /// Filter scale configuration
            FSC14: u1,
            /// Filter scale configuration
            FSC15: u1,
            /// Filter scale configuration
            FSC16: u1,
            /// Filter scale configuration
            FSC17: u1,
            /// Filter scale configuration
            FSC18: u1,
            /// Filter scale configuration
            FSC19: u1,
            /// Filter scale configuration
            FSC20: u1,
            /// Filter scale configuration
            FSC21: u1,
            /// Filter scale configuration
            FSC22: u1,
            /// Filter scale configuration
            FSC23: u1,
            /// Filter scale configuration
            FSC24: u1,
            /// Filter scale configuration
            FSC25: u1,
            /// Filter scale configuration
            FSC26: u1,
            /// Filter scale configuration
            FSC27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20c);

        /// address: 0x40006a14
        /// filter FIFO assignment
        /// register
        pub const FFA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter FIFO assignment for filter
            /// 0
            FFA0: u1,
            /// Filter FIFO assignment for filter
            /// 1
            FFA1: u1,
            /// Filter FIFO assignment for filter
            /// 2
            FFA2: u1,
            /// Filter FIFO assignment for filter
            /// 3
            FFA3: u1,
            /// Filter FIFO assignment for filter
            /// 4
            FFA4: u1,
            /// Filter FIFO assignment for filter
            /// 5
            FFA5: u1,
            /// Filter FIFO assignment for filter
            /// 6
            FFA6: u1,
            /// Filter FIFO assignment for filter
            /// 7
            FFA7: u1,
            /// Filter FIFO assignment for filter
            /// 8
            FFA8: u1,
            /// Filter FIFO assignment for filter
            /// 9
            FFA9: u1,
            /// Filter FIFO assignment for filter
            /// 10
            FFA10: u1,
            /// Filter FIFO assignment for filter
            /// 11
            FFA11: u1,
            /// Filter FIFO assignment for filter
            /// 12
            FFA12: u1,
            /// Filter FIFO assignment for filter
            /// 13
            FFA13: u1,
            /// Filter FIFO assignment for filter
            /// 14
            FFA14: u1,
            /// Filter FIFO assignment for filter
            /// 15
            FFA15: u1,
            /// Filter FIFO assignment for filter
            /// 16
            FFA16: u1,
            /// Filter FIFO assignment for filter
            /// 17
            FFA17: u1,
            /// Filter FIFO assignment for filter
            /// 18
            FFA18: u1,
            /// Filter FIFO assignment for filter
            /// 19
            FFA19: u1,
            /// Filter FIFO assignment for filter
            /// 20
            FFA20: u1,
            /// Filter FIFO assignment for filter
            /// 21
            FFA21: u1,
            /// Filter FIFO assignment for filter
            /// 22
            FFA22: u1,
            /// Filter FIFO assignment for filter
            /// 23
            FFA23: u1,
            /// Filter FIFO assignment for filter
            /// 24
            FFA24: u1,
            /// Filter FIFO assignment for filter
            /// 25
            FFA25: u1,
            /// Filter FIFO assignment for filter
            /// 26
            FFA26: u1,
            /// Filter FIFO assignment for filter
            /// 27
            FFA27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x214);

        /// address: 0x40006a1c
        /// filter activation register
        pub const FA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter active
            FACT0: u1,
            /// Filter active
            FACT1: u1,
            /// Filter active
            FACT2: u1,
            /// Filter active
            FACT3: u1,
            /// Filter active
            FACT4: u1,
            /// Filter active
            FACT5: u1,
            /// Filter active
            FACT6: u1,
            /// Filter active
            FACT7: u1,
            /// Filter active
            FACT8: u1,
            /// Filter active
            FACT9: u1,
            /// Filter active
            FACT10: u1,
            /// Filter active
            FACT11: u1,
            /// Filter active
            FACT12: u1,
            /// Filter active
            FACT13: u1,
            /// Filter active
            FACT14: u1,
            /// Filter active
            FACT15: u1,
            /// Filter active
            FACT16: u1,
            /// Filter active
            FACT17: u1,
            /// Filter active
            FACT18: u1,
            /// Filter active
            FACT19: u1,
            /// Filter active
            FACT20: u1,
            /// Filter active
            FACT21: u1,
            /// Filter active
            FACT22: u1,
            /// Filter active
            FACT23: u1,
            /// Filter active
            FACT24: u1,
            /// Filter active
            FACT25: u1,
            /// Filter active
            FACT26: u1,
            /// Filter active
            FACT27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x21c);

        /// address: 0x40006a40
        /// Filter bank 0 register 1
        pub const F0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x240);

        /// address: 0x40006a44
        /// Filter bank 0 register 2
        pub const F0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x244);

        /// address: 0x40006a48
        /// Filter bank 1 register 1
        pub const F1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x248);

        /// address: 0x40006a4c
        /// Filter bank 1 register 2
        pub const F1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006a50
        /// Filter bank 2 register 1
        pub const F2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x250);

        /// address: 0x40006a54
        /// Filter bank 2 register 2
        pub const F2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x254);

        /// address: 0x40006a58
        /// Filter bank 3 register 1
        pub const F3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x258);

        /// address: 0x40006a5c
        /// Filter bank 3 register 2
        pub const F3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006a60
        /// Filter bank 4 register 1
        pub const F4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x260);

        /// address: 0x40006a64
        /// Filter bank 4 register 2
        pub const F4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x264);

        /// address: 0x40006a68
        /// Filter bank 5 register 1
        pub const F5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x268);

        /// address: 0x40006a6c
        /// Filter bank 5 register 2
        pub const F5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006a70
        /// Filter bank 6 register 1
        pub const F6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x270);

        /// address: 0x40006a74
        /// Filter bank 6 register 2
        pub const F6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x274);

        /// address: 0x40006a78
        /// Filter bank 7 register 1
        pub const F7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x278);

        /// address: 0x40006a7c
        /// Filter bank 7 register 2
        pub const F7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006a80
        /// Filter bank 8 register 1
        pub const F8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x280);

        /// address: 0x40006a84
        /// Filter bank 8 register 2
        pub const F8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x284);

        /// address: 0x40006a88
        /// Filter bank 9 register 1
        pub const F9R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x288);

        /// address: 0x40006a8c
        /// Filter bank 9 register 2
        pub const F9R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006a90
        /// Filter bank 10 register 1
        pub const F10R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x290);

        /// address: 0x40006a94
        /// Filter bank 10 register 2
        pub const F10R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x294);

        /// address: 0x40006a98
        /// Filter bank 11 register 1
        pub const F11R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x298);

        /// address: 0x40006a9c
        /// Filter bank 11 register 2
        pub const F11R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x29c);

        /// address: 0x40006aa0
        /// Filter bank 4 register 1
        pub const F12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a0);

        /// address: 0x40006aa4
        /// Filter bank 12 register 2
        pub const F12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a4);

        /// address: 0x40006aa8
        /// Filter bank 13 register 1
        pub const F13R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a8);

        /// address: 0x40006aac
        /// Filter bank 13 register 2
        pub const F13R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ac);

        /// address: 0x40006ab0
        /// Filter bank 14 register 1
        pub const F14R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b0);

        /// address: 0x40006ab4
        /// Filter bank 14 register 2
        pub const F14R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b4);

        /// address: 0x40006ab8
        /// Filter bank 15 register 1
        pub const F15R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b8);

        /// address: 0x40006abc
        /// Filter bank 15 register 2
        pub const F15R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2bc);

        /// address: 0x40006ac0
        /// Filter bank 16 register 1
        pub const F16R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c0);

        /// address: 0x40006ac4
        /// Filter bank 16 register 2
        pub const F16R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c4);

        /// address: 0x40006ac8
        /// Filter bank 17 register 1
        pub const F17R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c8);

        /// address: 0x40006acc
        /// Filter bank 17 register 2
        pub const F17R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2cc);

        /// address: 0x40006ad0
        /// Filter bank 18 register 1
        pub const F18R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d0);

        /// address: 0x40006ad4
        /// Filter bank 18 register 2
        pub const F18R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d4);

        /// address: 0x40006ad8
        /// Filter bank 19 register 1
        pub const F19R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d8);

        /// address: 0x40006adc
        /// Filter bank 19 register 2
        pub const F19R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2dc);

        /// address: 0x40006ae0
        /// Filter bank 20 register 1
        pub const F20R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e0);

        /// address: 0x40006ae4
        /// Filter bank 20 register 2
        pub const F20R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e4);

        /// address: 0x40006ae8
        /// Filter bank 21 register 1
        pub const F21R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e8);

        /// address: 0x40006aec
        /// Filter bank 21 register 2
        pub const F21R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ec);

        /// address: 0x40006af0
        /// Filter bank 22 register 1
        pub const F22R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f0);

        /// address: 0x40006af4
        /// Filter bank 22 register 2
        pub const F22R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f4);

        /// address: 0x40006af8
        /// Filter bank 23 register 1
        pub const F23R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f8);

        /// address: 0x40006afc
        /// Filter bank 23 register 2
        pub const F23R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40006b00
        /// Filter bank 24 register 1
        pub const F24R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x300);

        /// address: 0x40006b04
        /// Filter bank 24 register 2
        pub const F24R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x304);

        /// address: 0x40006b08
        /// Filter bank 25 register 1
        pub const F25R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x308);

        /// address: 0x40006b0c
        /// Filter bank 25 register 2
        pub const F25R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x30c);

        /// address: 0x40006b10
        /// Filter bank 26 register 1
        pub const F26R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x310);

        /// address: 0x40006b14
        /// Filter bank 26 register 2
        pub const F26R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x314);

        /// address: 0x40006b18
        /// Filter bank 27 register 1
        pub const F27R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x318);

        /// address: 0x40006b1c
        /// Filter bank 27 register 2
        pub const F27R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x31c);
    };
    pub const CAN3 = struct {
        pub const base_address = 0x40003400;

        /// address: 0x40003400
        /// master control register
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INRQ
            INRQ: u1,
            /// SLEEP
            SLEEP: u1,
            /// TXFP
            TXFP: u1,
            /// RFLM
            RFLM: u1,
            /// NART
            NART: u1,
            /// AWUM
            AWUM: u1,
            /// ABOM
            ABOM: u1,
            /// TTCM
            TTCM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RESET
            RESET: u1,
            /// DBF
            DBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40003404
        /// master status register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INAK
            INAK: u1,
            /// SLAK
            SLAK: u1,
            /// ERRI
            ERRI: u1,
            /// WKUI
            WKUI: u1,
            /// SLAKI
            SLAKI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TXM
            TXM: u1,
            /// RXM
            RXM: u1,
            /// SAMP
            SAMP: u1,
            /// RX
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40003408
        /// transmit status register
        pub const TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RQCP0
            RQCP0: u1,
            /// TXOK0
            TXOK0: u1,
            /// ALST0
            ALST0: u1,
            /// TERR0
            TERR0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ABRQ0
            ABRQ0: u1,
            /// RQCP1
            RQCP1: u1,
            /// TXOK1
            TXOK1: u1,
            /// ALST1
            ALST1: u1,
            /// TERR1
            TERR1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ABRQ1
            ABRQ1: u1,
            /// RQCP2
            RQCP2: u1,
            /// TXOK2
            TXOK2: u1,
            /// ALST2
            ALST2: u1,
            /// TERR2
            TERR2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ABRQ2
            ABRQ2: u1,
            /// CODE
            CODE: u2,
            /// Lowest priority flag for mailbox
            /// 0
            TME0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            TME1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            TME2: u1,
            /// Lowest priority flag for mailbox
            /// 0
            LOW0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            LOW1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            LOW2: u1,
        }), base_address + 0x8);

        /// address: 0x4000340c
        /// receive FIFO 0 register
        pub const RF0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP0
            FMP0: u2,
            reserved0: u1,
            /// FULL0
            FULL0: u1,
            /// FOVR0
            FOVR0: u1,
            /// RFOM0
            RFOM0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40003410
        /// receive FIFO 1 register
        pub const RF1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP1
            FMP1: u2,
            reserved0: u1,
            /// FULL1
            FULL1: u1,
            /// FOVR1
            FOVR1: u1,
            /// RFOM1
            RFOM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40003414
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TMEIE
            TMEIE: u1,
            /// FMPIE0
            FMPIE0: u1,
            /// FFIE0
            FFIE0: u1,
            /// FOVIE0
            FOVIE0: u1,
            /// FMPIE1
            FMPIE1: u1,
            /// FFIE1
            FFIE1: u1,
            /// FOVIE1
            FOVIE1: u1,
            reserved0: u1,
            /// EWGIE
            EWGIE: u1,
            /// EPVIE
            EPVIE: u1,
            /// BOFIE
            BOFIE: u1,
            /// LECIE
            LECIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ERRIE
            ERRIE: u1,
            /// WKUIE
            WKUIE: u1,
            /// SLKIE
            SLKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40003418
        /// interrupt enable register
        pub const ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EWGF
            EWGF: u1,
            /// EPVF
            EPVF: u1,
            /// BOFF
            BOFF: u1,
            reserved0: u1,
            /// LEC
            LEC: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TEC
            TEC: u8,
            /// REC
            REC: u8,
        }), base_address + 0x18);

        /// address: 0x4000341c
        /// bit timing register
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRP
            BRP: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TS1
            TS1: u4,
            /// TS2
            TS2: u3,
            reserved6: u1,
            /// SJW
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LBKM
            LBKM: u1,
            /// SILM
            SILM: u1,
        }), base_address + 0x1c);

        /// address: 0x40003580
        /// TX mailbox identifier register
        pub const TI0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x180);

        /// address: 0x40003584
        /// mailbox data length control and time stamp
        /// register
        pub const TDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x184);

        /// address: 0x40003588
        /// mailbox data low register
        pub const TDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x188);

        /// address: 0x4000358c
        /// mailbox data high register
        pub const TDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x18c);

        /// address: 0x40003590
        /// mailbox identifier register
        pub const TI1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x190);

        /// address: 0x40003594
        /// mailbox data length control and time stamp
        /// register
        pub const TDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x194);

        /// address: 0x40003598
        /// mailbox data low register
        pub const TDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x198);

        /// address: 0x4000359c
        /// mailbox data high register
        pub const TDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x19c);

        /// address: 0x400035a0
        /// mailbox identifier register
        pub const TI2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400035a4
        /// mailbox data length control and time stamp
        /// register
        pub const TDT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x1a4);

        /// address: 0x400035a8
        /// mailbox data low register
        pub const TDL2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400035ac
        /// mailbox data high register
        pub const TDH2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400035b0
        /// receive FIFO mailbox identifier
        /// register
        pub const RI0R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400035b4
        /// mailbox data high register
        pub const RDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1b4);

        /// address: 0x400035b8
        /// mailbox data high register
        pub const RDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400035bc
        /// receive FIFO mailbox data high
        /// register
        pub const RDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400035c0
        /// mailbox data high register
        pub const RI1R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400035c4
        /// mailbox data high register
        pub const RDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1c4);

        /// address: 0x400035c8
        /// mailbox data high register
        pub const RDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400035cc
        /// mailbox data high register
        pub const RDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40003600
        /// filter master register
        pub const FMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FINIT
            FINIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// CAN2SB
            CAN2SB: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40003604
        /// filter mode register
        pub const FM1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FBM0: u1,
            /// Filter mode
            FBM1: u1,
            /// Filter mode
            FBM2: u1,
            /// Filter mode
            FBM3: u1,
            /// Filter mode
            FBM4: u1,
            /// Filter mode
            FBM5: u1,
            /// Filter mode
            FBM6: u1,
            /// Filter mode
            FBM7: u1,
            /// Filter mode
            FBM8: u1,
            /// Filter mode
            FBM9: u1,
            /// Filter mode
            FBM10: u1,
            /// Filter mode
            FBM11: u1,
            /// Filter mode
            FBM12: u1,
            /// Filter mode
            FBM13: u1,
            /// Filter mode
            FBM14: u1,
            /// Filter mode
            FBM15: u1,
            /// Filter mode
            FBM16: u1,
            /// Filter mode
            FBM17: u1,
            /// Filter mode
            FBM18: u1,
            /// Filter mode
            FBM19: u1,
            /// Filter mode
            FBM20: u1,
            /// Filter mode
            FBM21: u1,
            /// Filter mode
            FBM22: u1,
            /// Filter mode
            FBM23: u1,
            /// Filter mode
            FBM24: u1,
            /// Filter mode
            FBM25: u1,
            /// Filter mode
            FBM26: u1,
            /// Filter mode
            FBM27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x204);

        /// address: 0x4000360c
        /// filter scale register
        pub const FS1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FSC0: u1,
            /// Filter scale configuration
            FSC1: u1,
            /// Filter scale configuration
            FSC2: u1,
            /// Filter scale configuration
            FSC3: u1,
            /// Filter scale configuration
            FSC4: u1,
            /// Filter scale configuration
            FSC5: u1,
            /// Filter scale configuration
            FSC6: u1,
            /// Filter scale configuration
            FSC7: u1,
            /// Filter scale configuration
            FSC8: u1,
            /// Filter scale configuration
            FSC9: u1,
            /// Filter scale configuration
            FSC10: u1,
            /// Filter scale configuration
            FSC11: u1,
            /// Filter scale configuration
            FSC12: u1,
            /// Filter scale configuration
            FSC13: u1,
            /// Filter scale configuration
            FSC14: u1,
            /// Filter scale configuration
            FSC15: u1,
            /// Filter scale configuration
            FSC16: u1,
            /// Filter scale configuration
            FSC17: u1,
            /// Filter scale configuration
            FSC18: u1,
            /// Filter scale configuration
            FSC19: u1,
            /// Filter scale configuration
            FSC20: u1,
            /// Filter scale configuration
            FSC21: u1,
            /// Filter scale configuration
            FSC22: u1,
            /// Filter scale configuration
            FSC23: u1,
            /// Filter scale configuration
            FSC24: u1,
            /// Filter scale configuration
            FSC25: u1,
            /// Filter scale configuration
            FSC26: u1,
            /// Filter scale configuration
            FSC27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20c);

        /// address: 0x40003614
        /// filter FIFO assignment
        /// register
        pub const FFA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter FIFO assignment for filter
            /// 0
            FFA0: u1,
            /// Filter FIFO assignment for filter
            /// 1
            FFA1: u1,
            /// Filter FIFO assignment for filter
            /// 2
            FFA2: u1,
            /// Filter FIFO assignment for filter
            /// 3
            FFA3: u1,
            /// Filter FIFO assignment for filter
            /// 4
            FFA4: u1,
            /// Filter FIFO assignment for filter
            /// 5
            FFA5: u1,
            /// Filter FIFO assignment for filter
            /// 6
            FFA6: u1,
            /// Filter FIFO assignment for filter
            /// 7
            FFA7: u1,
            /// Filter FIFO assignment for filter
            /// 8
            FFA8: u1,
            /// Filter FIFO assignment for filter
            /// 9
            FFA9: u1,
            /// Filter FIFO assignment for filter
            /// 10
            FFA10: u1,
            /// Filter FIFO assignment for filter
            /// 11
            FFA11: u1,
            /// Filter FIFO assignment for filter
            /// 12
            FFA12: u1,
            /// Filter FIFO assignment for filter
            /// 13
            FFA13: u1,
            /// Filter FIFO assignment for filter
            /// 14
            FFA14: u1,
            /// Filter FIFO assignment for filter
            /// 15
            FFA15: u1,
            /// Filter FIFO assignment for filter
            /// 16
            FFA16: u1,
            /// Filter FIFO assignment for filter
            /// 17
            FFA17: u1,
            /// Filter FIFO assignment for filter
            /// 18
            FFA18: u1,
            /// Filter FIFO assignment for filter
            /// 19
            FFA19: u1,
            /// Filter FIFO assignment for filter
            /// 20
            FFA20: u1,
            /// Filter FIFO assignment for filter
            /// 21
            FFA21: u1,
            /// Filter FIFO assignment for filter
            /// 22
            FFA22: u1,
            /// Filter FIFO assignment for filter
            /// 23
            FFA23: u1,
            /// Filter FIFO assignment for filter
            /// 24
            FFA24: u1,
            /// Filter FIFO assignment for filter
            /// 25
            FFA25: u1,
            /// Filter FIFO assignment for filter
            /// 26
            FFA26: u1,
            /// Filter FIFO assignment for filter
            /// 27
            FFA27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x214);

        /// address: 0x4000361c
        /// filter activation register
        pub const FA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter active
            FACT0: u1,
            /// Filter active
            FACT1: u1,
            /// Filter active
            FACT2: u1,
            /// Filter active
            FACT3: u1,
            /// Filter active
            FACT4: u1,
            /// Filter active
            FACT5: u1,
            /// Filter active
            FACT6: u1,
            /// Filter active
            FACT7: u1,
            /// Filter active
            FACT8: u1,
            /// Filter active
            FACT9: u1,
            /// Filter active
            FACT10: u1,
            /// Filter active
            FACT11: u1,
            /// Filter active
            FACT12: u1,
            /// Filter active
            FACT13: u1,
            /// Filter active
            FACT14: u1,
            /// Filter active
            FACT15: u1,
            /// Filter active
            FACT16: u1,
            /// Filter active
            FACT17: u1,
            /// Filter active
            FACT18: u1,
            /// Filter active
            FACT19: u1,
            /// Filter active
            FACT20: u1,
            /// Filter active
            FACT21: u1,
            /// Filter active
            FACT22: u1,
            /// Filter active
            FACT23: u1,
            /// Filter active
            FACT24: u1,
            /// Filter active
            FACT25: u1,
            /// Filter active
            FACT26: u1,
            /// Filter active
            FACT27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x21c);

        /// address: 0x40003640
        /// Filter bank 0 register 1
        pub const F0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x240);

        /// address: 0x40003644
        /// Filter bank 0 register 2
        pub const F0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x244);

        /// address: 0x40003648
        /// Filter bank 1 register 1
        pub const F1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x248);

        /// address: 0x4000364c
        /// Filter bank 1 register 2
        pub const F1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x24c);

        /// address: 0x40003650
        /// Filter bank 2 register 1
        pub const F2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x250);

        /// address: 0x40003654
        /// Filter bank 2 register 2
        pub const F2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x254);

        /// address: 0x40003658
        /// Filter bank 3 register 1
        pub const F3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x258);

        /// address: 0x4000365c
        /// Filter bank 3 register 2
        pub const F3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x25c);

        /// address: 0x40003660
        /// Filter bank 4 register 1
        pub const F4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x260);

        /// address: 0x40003664
        /// Filter bank 4 register 2
        pub const F4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x264);

        /// address: 0x40003668
        /// Filter bank 5 register 1
        pub const F5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x268);

        /// address: 0x4000366c
        /// Filter bank 5 register 2
        pub const F5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x26c);

        /// address: 0x40003670
        /// Filter bank 6 register 1
        pub const F6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x270);

        /// address: 0x40003674
        /// Filter bank 6 register 2
        pub const F6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x274);

        /// address: 0x40003678
        /// Filter bank 7 register 1
        pub const F7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x278);

        /// address: 0x4000367c
        /// Filter bank 7 register 2
        pub const F7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x27c);

        /// address: 0x40003680
        /// Filter bank 8 register 1
        pub const F8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x280);

        /// address: 0x40003684
        /// Filter bank 8 register 2
        pub const F8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x284);

        /// address: 0x40003688
        /// Filter bank 9 register 1
        pub const F9R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x288);

        /// address: 0x4000368c
        /// Filter bank 9 register 2
        pub const F9R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x28c);

        /// address: 0x40003690
        /// Filter bank 10 register 1
        pub const F10R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x290);

        /// address: 0x40003694
        /// Filter bank 10 register 2
        pub const F10R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x294);

        /// address: 0x40003698
        /// Filter bank 11 register 1
        pub const F11R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x298);

        /// address: 0x4000369c
        /// Filter bank 11 register 2
        pub const F11R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x29c);

        /// address: 0x400036a0
        /// Filter bank 4 register 1
        pub const F12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a0);

        /// address: 0x400036a4
        /// Filter bank 12 register 2
        pub const F12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a4);

        /// address: 0x400036a8
        /// Filter bank 13 register 1
        pub const F13R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a8);

        /// address: 0x400036ac
        /// Filter bank 13 register 2
        pub const F13R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ac);

        /// address: 0x400036b0
        /// Filter bank 14 register 1
        pub const F14R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b0);

        /// address: 0x400036b4
        /// Filter bank 14 register 2
        pub const F14R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b4);

        /// address: 0x400036b8
        /// Filter bank 15 register 1
        pub const F15R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b8);

        /// address: 0x400036bc
        /// Filter bank 15 register 2
        pub const F15R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2bc);

        /// address: 0x400036c0
        /// Filter bank 16 register 1
        pub const F16R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c0);

        /// address: 0x400036c4
        /// Filter bank 16 register 2
        pub const F16R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c4);

        /// address: 0x400036c8
        /// Filter bank 17 register 1
        pub const F17R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c8);

        /// address: 0x400036cc
        /// Filter bank 17 register 2
        pub const F17R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2cc);

        /// address: 0x400036d0
        /// Filter bank 18 register 1
        pub const F18R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d0);

        /// address: 0x400036d4
        /// Filter bank 18 register 2
        pub const F18R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d4);

        /// address: 0x400036d8
        /// Filter bank 19 register 1
        pub const F19R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d8);

        /// address: 0x400036dc
        /// Filter bank 19 register 2
        pub const F19R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2dc);

        /// address: 0x400036e0
        /// Filter bank 20 register 1
        pub const F20R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e0);

        /// address: 0x400036e4
        /// Filter bank 20 register 2
        pub const F20R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e4);

        /// address: 0x400036e8
        /// Filter bank 21 register 1
        pub const F21R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e8);

        /// address: 0x400036ec
        /// Filter bank 21 register 2
        pub const F21R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ec);

        /// address: 0x400036f0
        /// Filter bank 22 register 1
        pub const F22R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f0);

        /// address: 0x400036f4
        /// Filter bank 22 register 2
        pub const F22R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f4);

        /// address: 0x400036f8
        /// Filter bank 23 register 1
        pub const F23R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f8);

        /// address: 0x400036fc
        /// Filter bank 23 register 2
        pub const F23R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40003700
        /// Filter bank 24 register 1
        pub const F24R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x300);

        /// address: 0x40003704
        /// Filter bank 24 register 2
        pub const F24R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x304);

        /// address: 0x40003708
        /// Filter bank 25 register 1
        pub const F25R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x308);

        /// address: 0x4000370c
        /// Filter bank 25 register 2
        pub const F25R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x30c);

        /// address: 0x40003710
        /// Filter bank 26 register 1
        pub const F26R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x310);

        /// address: 0x40003714
        /// Filter bank 26 register 2
        pub const F26R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x314);

        /// address: 0x40003718
        /// Filter bank 27 register 1
        pub const F27R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x318);

        /// address: 0x4000371c
        /// Filter bank 27 register 2
        pub const F27R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x31c);
    };

    /// FLASH
    pub const Flash = struct {
        pub const base_address = 0x40023c00;

        /// address: 0x40023c00
        /// Flash access control register
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Latency
            LATENCY: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Prefetch enable
            PRFTEN: u1,
            /// ART Accelerator Enable
            ARTEN: u1,
            reserved4: u1,
            /// ART Accelerator reset
            ARTRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40023c04
        /// Flash key register
        pub const KEYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FPEC key
            KEY: u32,
        }), base_address + 0x4);

        /// address: 0x40023c08
        /// Flash option key register
        pub const OPTKEYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Option byte key
            OPTKEY: u32,
        }), base_address + 0x8);

        /// address: 0x40023c0c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of operation
            EOP: u1,
            /// Operation error
            OPERR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Write protection error
            WRPERR: u1,
            /// Programming alignment
            /// error
            PGAERR: u1,
            /// Programming parallelism
            /// error
            PGPERR: u1,
            /// Programming sequence error
            PGSERR: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Busy
            BSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);

        /// address: 0x40023c10
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programming
            PG: u1,
            /// Sector Erase
            SER: u1,
            /// Mass Erase of sectors 0 to
            /// 11
            MER: u1,
            /// Sector number
            SNB: u5,
            /// Program size
            PSIZE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Mass Erase of sectors 12 to
            /// 23
            MER1: u1,
            /// Start
            STRT: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// End of operation interrupt
            /// enable
            EOPIE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Lock
            LOCK: u1,
        }), base_address + 0x10);

        /// address: 0x40023c14
        /// Flash option control register
        pub const OPTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Option lock
            OPTLOCK: u1,
            /// Option start
            OPTSTRT: u1,
            /// BOR reset Level
            BOR_LEV: u2,
            /// User option bytes
            WWDG_SW: u1,
            /// User option bytes
            IWDG_SW: u1,
            /// User option bytes
            nRST_STOP: u1,
            /// User option bytes
            nRST_STDBY: u1,
            /// Read protect
            RDP: u8,
            /// Not write protect
            nWRP: u12,
            /// Dual Boot mode (valid only when
            /// nDBANK=0)
            nDBOOT: u1,
            /// Not dual bank mode
            nDBANK: u1,
            /// Independent watchdog counter freeze in
            /// standby mode
            IWDG_STDBY: u1,
            /// Independent watchdog counter freeze in
            /// Stop mode
            IWDG_STOP: u1,
        }), base_address + 0x14);

        /// address: 0x40023c18
        /// Flash option control register
        /// 1
        pub const OPTCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Boot base address when Boot pin
            /// =0
            BOOT_ADD0: u16,
            /// Boot base address when Boot pin
            /// =1
            BOOT_ADD1: u16,
        }), base_address + 0x18);
    };

    /// External interrupt/event
    /// controller
    pub const EXTI = struct {
        pub const base_address = 0x40013c00;

        /// address: 0x40013c00
        /// Interrupt mask register
        /// (EXTI_IMR)
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on line 0
            MR0: u1,
            /// Interrupt Mask on line 1
            MR1: u1,
            /// Interrupt Mask on line 2
            MR2: u1,
            /// Interrupt Mask on line 3
            MR3: u1,
            /// Interrupt Mask on line 4
            MR4: u1,
            /// Interrupt Mask on line 5
            MR5: u1,
            /// Interrupt Mask on line 6
            MR6: u1,
            /// Interrupt Mask on line 7
            MR7: u1,
            /// Interrupt Mask on line 8
            MR8: u1,
            /// Interrupt Mask on line 9
            MR9: u1,
            /// Interrupt Mask on line 10
            MR10: u1,
            /// Interrupt Mask on line 11
            MR11: u1,
            /// Interrupt Mask on line 12
            MR12: u1,
            /// Interrupt Mask on line 13
            MR13: u1,
            /// Interrupt Mask on line 14
            MR14: u1,
            /// Interrupt Mask on line 15
            MR15: u1,
            /// Interrupt Mask on line 16
            MR16: u1,
            /// Interrupt Mask on line 17
            MR17: u1,
            /// Interrupt Mask on line 18
            MR18: u1,
            /// Interrupt Mask on line 19
            MR19: u1,
            /// Interrupt Mask on line 20
            MR20: u1,
            /// Interrupt Mask on line 21
            MR21: u1,
            /// Interrupt Mask on line 22
            MR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x0);

        /// address: 0x40013c04
        /// Event mask register (EXTI_EMR)
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event Mask on line 0
            MR0: u1,
            /// Event Mask on line 1
            MR1: u1,
            /// Event Mask on line 2
            MR2: u1,
            /// Event Mask on line 3
            MR3: u1,
            /// Event Mask on line 4
            MR4: u1,
            /// Event Mask on line 5
            MR5: u1,
            /// Event Mask on line 6
            MR6: u1,
            /// Event Mask on line 7
            MR7: u1,
            /// Event Mask on line 8
            MR8: u1,
            /// Event Mask on line 9
            MR9: u1,
            /// Event Mask on line 10
            MR10: u1,
            /// Event Mask on line 11
            MR11: u1,
            /// Event Mask on line 12
            MR12: u1,
            /// Event Mask on line 13
            MR13: u1,
            /// Event Mask on line 14
            MR14: u1,
            /// Event Mask on line 15
            MR15: u1,
            /// Event Mask on line 16
            MR16: u1,
            /// Event Mask on line 17
            MR17: u1,
            /// Event Mask on line 18
            MR18: u1,
            /// Event Mask on line 19
            MR19: u1,
            /// Event Mask on line 20
            MR20: u1,
            /// Event Mask on line 21
            MR21: u1,
            /// Event Mask on line 22
            MR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x4);

        /// address: 0x40013c08
        /// Rising Trigger selection register
        /// (EXTI_RTSR)
        pub const RTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration of
            /// line 0
            TR0: u1,
            /// Rising trigger event configuration of
            /// line 1
            TR1: u1,
            /// Rising trigger event configuration of
            /// line 2
            TR2: u1,
            /// Rising trigger event configuration of
            /// line 3
            TR3: u1,
            /// Rising trigger event configuration of
            /// line 4
            TR4: u1,
            /// Rising trigger event configuration of
            /// line 5
            TR5: u1,
            /// Rising trigger event configuration of
            /// line 6
            TR6: u1,
            /// Rising trigger event configuration of
            /// line 7
            TR7: u1,
            /// Rising trigger event configuration of
            /// line 8
            TR8: u1,
            /// Rising trigger event configuration of
            /// line 9
            TR9: u1,
            /// Rising trigger event configuration of
            /// line 10
            TR10: u1,
            /// Rising trigger event configuration of
            /// line 11
            TR11: u1,
            /// Rising trigger event configuration of
            /// line 12
            TR12: u1,
            /// Rising trigger event configuration of
            /// line 13
            TR13: u1,
            /// Rising trigger event configuration of
            /// line 14
            TR14: u1,
            /// Rising trigger event configuration of
            /// line 15
            TR15: u1,
            /// Rising trigger event configuration of
            /// line 16
            TR16: u1,
            /// Rising trigger event configuration of
            /// line 17
            TR17: u1,
            /// Rising trigger event configuration of
            /// line 18
            TR18: u1,
            /// Rising trigger event configuration of
            /// line 19
            TR19: u1,
            /// Rising trigger event configuration of
            /// line 20
            TR20: u1,
            /// Rising trigger event configuration of
            /// line 21
            TR21: u1,
            /// Rising trigger event configuration of
            /// line 22
            TR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x40013c0c
        /// Falling Trigger selection register
        /// (EXTI_FTSR)
        pub const FTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration of
            /// line 0
            TR0: u1,
            /// Falling trigger event configuration of
            /// line 1
            TR1: u1,
            /// Falling trigger event configuration of
            /// line 2
            TR2: u1,
            /// Falling trigger event configuration of
            /// line 3
            TR3: u1,
            /// Falling trigger event configuration of
            /// line 4
            TR4: u1,
            /// Falling trigger event configuration of
            /// line 5
            TR5: u1,
            /// Falling trigger event configuration of
            /// line 6
            TR6: u1,
            /// Falling trigger event configuration of
            /// line 7
            TR7: u1,
            /// Falling trigger event configuration of
            /// line 8
            TR8: u1,
            /// Falling trigger event configuration of
            /// line 9
            TR9: u1,
            /// Falling trigger event configuration of
            /// line 10
            TR10: u1,
            /// Falling trigger event configuration of
            /// line 11
            TR11: u1,
            /// Falling trigger event configuration of
            /// line 12
            TR12: u1,
            /// Falling trigger event configuration of
            /// line 13
            TR13: u1,
            /// Falling trigger event configuration of
            /// line 14
            TR14: u1,
            /// Falling trigger event configuration of
            /// line 15
            TR15: u1,
            /// Falling trigger event configuration of
            /// line 16
            TR16: u1,
            /// Falling trigger event configuration of
            /// line 17
            TR17: u1,
            /// Falling trigger event configuration of
            /// line 18
            TR18: u1,
            /// Falling trigger event configuration of
            /// line 19
            TR19: u1,
            /// Falling trigger event configuration of
            /// line 20
            TR20: u1,
            /// Falling trigger event configuration of
            /// line 21
            TR21: u1,
            /// Falling trigger event configuration of
            /// line 22
            TR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xc);

        /// address: 0x40013c10
        /// Software interrupt event register
        /// (EXTI_SWIER)
        pub const SWIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Interrupt on line
            /// 0
            SWIER0: u1,
            /// Software Interrupt on line
            /// 1
            SWIER1: u1,
            /// Software Interrupt on line
            /// 2
            SWIER2: u1,
            /// Software Interrupt on line
            /// 3
            SWIER3: u1,
            /// Software Interrupt on line
            /// 4
            SWIER4: u1,
            /// Software Interrupt on line
            /// 5
            SWIER5: u1,
            /// Software Interrupt on line
            /// 6
            SWIER6: u1,
            /// Software Interrupt on line
            /// 7
            SWIER7: u1,
            /// Software Interrupt on line
            /// 8
            SWIER8: u1,
            /// Software Interrupt on line
            /// 9
            SWIER9: u1,
            /// Software Interrupt on line
            /// 10
            SWIER10: u1,
            /// Software Interrupt on line
            /// 11
            SWIER11: u1,
            /// Software Interrupt on line
            /// 12
            SWIER12: u1,
            /// Software Interrupt on line
            /// 13
            SWIER13: u1,
            /// Software Interrupt on line
            /// 14
            SWIER14: u1,
            /// Software Interrupt on line
            /// 15
            SWIER15: u1,
            /// Software Interrupt on line
            /// 16
            SWIER16: u1,
            /// Software Interrupt on line
            /// 17
            SWIER17: u1,
            /// Software Interrupt on line
            /// 18
            SWIER18: u1,
            /// Software Interrupt on line
            /// 19
            SWIER19: u1,
            /// Software Interrupt on line
            /// 20
            SWIER20: u1,
            /// Software Interrupt on line
            /// 21
            SWIER21: u1,
            /// Software Interrupt on line
            /// 22
            SWIER22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40013c14
        /// Pending register (EXTI_PR)
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending bit 0
            PR0: u1,
            /// Pending bit 1
            PR1: u1,
            /// Pending bit 2
            PR2: u1,
            /// Pending bit 3
            PR3: u1,
            /// Pending bit 4
            PR4: u1,
            /// Pending bit 5
            PR5: u1,
            /// Pending bit 6
            PR6: u1,
            /// Pending bit 7
            PR7: u1,
            /// Pending bit 8
            PR8: u1,
            /// Pending bit 9
            PR9: u1,
            /// Pending bit 10
            PR10: u1,
            /// Pending bit 11
            PR11: u1,
            /// Pending bit 12
            PR12: u1,
            /// Pending bit 13
            PR13: u1,
            /// Pending bit 14
            PR14: u1,
            /// Pending bit 15
            PR15: u1,
            /// Pending bit 16
            PR16: u1,
            /// Pending bit 17
            PR17: u1,
            /// Pending bit 18
            PR18: u1,
            /// Pending bit 19
            PR19: u1,
            /// Pending bit 20
            PR20: u1,
            /// Pending bit 21
            PR21: u1,
            /// Pending bit 22
            PR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);
    };

    /// LCD-TFT Controller
    pub const LTCD = struct {
        pub const base_address = 0x40016800;

        /// address: 0x40016808
        /// Synchronization Size Configuration
        /// Register
        pub const SSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Synchronization Height (in
            /// units of horizontal scan line)
            VSH: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Horizontal Synchronization Width (in
            /// units of pixel clock period)
            HSW: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x8);

        /// address: 0x4001680c
        /// Back Porch Configuration
        /// Register
        pub const BPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Accumulated Vertical back porch (in
            /// units of horizontal scan line)
            AVBP: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Accumulated Horizontal back porch (in
            /// units of pixel clock period)
            AHBP: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xc);

        /// address: 0x40016810
        /// Active Width Configuration
        /// Register
        pub const AWCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Accumulated Active Height (in units of
            /// horizontal scan line)
            AAH: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// AAV
            AAV: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x10);

        /// address: 0x40016814
        /// Total Width Configuration
        /// Register
        pub const TWCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Total Height (in units of horizontal
            /// scan line)
            TOTALH: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Total Width (in units of pixel clock
            /// period)
            TOTALW: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x14);

        /// address: 0x40016818
        /// Global Control Register
        pub const GCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LCD-TFT controller enable
            /// bit
            LTDCEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Dither Blue Width
            DBW: u3,
            reserved3: u1,
            /// Dither Green Width
            DGW: u3,
            reserved4: u1,
            /// Dither Red Width
            DRW: u3,
            reserved5: u1,
            /// Dither Enable
            DEN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Pixel Clock Polarity
            PCPOL: u1,
            /// Data Enable Polarity
            DEPOL: u1,
            /// Vertical Synchronization
            /// Polarity
            VSPOL: u1,
            /// Horizontal Synchronization
            /// Polarity
            HSPOL: u1,
        }), base_address + 0x18);

        /// address: 0x40016824
        /// Shadow Reload Configuration
        /// Register
        pub const SRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Immediate Reload
            IMR: u1,
            /// Vertical Blanking Reload
            VBR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x24);

        /// address: 0x4001682c
        /// Background Color Configuration
        /// Register
        pub const BCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Background Color Red value
            BC: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40016834
        /// Interrupt Enable Register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line Interrupt Enable
            LIE: u1,
            /// FIFO Underrun Interrupt
            /// Enable
            FUIE: u1,
            /// Transfer Error Interrupt
            /// Enable
            TERRIE: u1,
            /// Register Reload interrupt
            /// enable
            RRIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x34);

        /// address: 0x40016838
        /// Interrupt Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line Interrupt flag
            LIF: u1,
            /// FIFO Underrun Interrupt
            /// flag
            FUIF: u1,
            /// Transfer Error interrupt
            /// flag
            TERRIF: u1,
            /// Register Reload Interrupt
            /// Flag
            RRIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x38);

        /// address: 0x4001683c
        /// Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clears the Line Interrupt
            /// Flag
            CLIF: u1,
            /// Clears the FIFO Underrun Interrupt
            /// flag
            CFUIF: u1,
            /// Clears the Transfer Error Interrupt
            /// Flag
            CTERRIF: u1,
            /// Clears Register Reload Interrupt
            /// Flag
            CRRIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x3c);

        /// address: 0x40016840
        /// Line Interrupt Position Configuration
        /// Register
        pub const LIPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line Interrupt Position
            LIPOS: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x40);

        /// address: 0x40016844
        /// Current Position Status
        /// Register
        pub const CPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Y Position
            CYPOS: u16,
            /// Current X Position
            CXPOS: u16,
        }), base_address + 0x44);

        /// address: 0x40016848
        /// Current Display Status
        /// Register
        pub const CDSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Data Enable display
            /// Status
            VDES: u1,
            /// Horizontal Data Enable display
            /// Status
            HDES: u1,
            /// Vertical Synchronization display
            /// Status
            VSYNCS: u1,
            /// Horizontal Synchronization display
            /// Status
            HSYNCS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x48);

        /// address: 0x40016884
        /// Layerx Control Register
        pub const L1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Layer Enable
            LEN: u1,
            /// Color Keying Enable
            COLKEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Color Look-Up Table Enable
            CLUTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x84);

        /// address: 0x40016888
        /// Layerx Window Horizontal Position
        /// Configuration Register
        pub const L1WHPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Window Horizontal Start
            /// Position
            WHSTPOS: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Window Horizontal Stop
            /// Position
            WHSPPOS: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x88);

        /// address: 0x4001688c
        /// Layerx Window Vertical Position
        /// Configuration Register
        pub const L1WVPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Window Vertical Start
            /// Position
            WVSTPOS: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Window Vertical Stop
            /// Position
            WVSPPOS: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x8c);

        /// address: 0x40016890
        /// Layerx Color Keying Configuration
        /// Register
        pub const L1CKCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Key Blue value
            CKBLUE: u8,
            /// Color Key Green value
            CKGREEN: u8,
            /// Color Key Red value
            CKRED: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x90);

        /// address: 0x40016894
        /// Layerx Pixel Format Configuration
        /// Register
        pub const L1PFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pixel Format
            PF: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x94);

        /// address: 0x40016898
        /// Layerx Constant Alpha Configuration
        /// Register
        pub const L1CACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Constant Alpha
            CONSTA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x98);

        /// address: 0x4001689c
        /// Layerx Default Color Configuration
        /// Register
        pub const L1DCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Default Color Blue
            DCBLUE: u8,
            /// Default Color Green
            DCGREEN: u8,
            /// Default Color Red
            DCRED: u8,
            /// Default Color Alpha
            DCALPHA: u8,
        }), base_address + 0x9c);

        /// address: 0x400168a0
        /// Layerx Blending Factors Configuration
        /// Register
        pub const L1BFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blending Factor 2
            BF2: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Blending Factor 1
            BF1: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0xa0);

        /// address: 0x400168ac
        /// Layerx Color Frame Buffer Address
        /// Register
        pub const L1CFBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Frame Buffer Start
            /// Address
            CFBADD: u32,
        }), base_address + 0xac);

        /// address: 0x400168b0
        /// Layerx Color Frame Buffer Length
        /// Register
        pub const L1CFBLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Frame Buffer Line
            /// Length
            CFBLL: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Color Frame Buffer Pitch in
            /// bytes
            CFBP: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xb0);

        /// address: 0x400168b4
        /// Layerx ColorFrame Buffer Line Number
        /// Register
        pub const L1CFBLNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame Buffer Line Number
            CFBLNBR: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0xb4);

        /// address: 0x400168c4
        /// Layerx CLUT Write Register
        pub const L1CLUTWR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blue value
            BLUE: u8,
            /// Green value
            GREEN: u8,
            /// Red value
            RED: u8,
            /// CLUT Address
            CLUTADD: u8,
        }), base_address + 0xc4);

        /// address: 0x40016904
        /// Layerx Control Register
        pub const L2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Layer Enable
            LEN: u1,
            /// Color Keying Enable
            COLKEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Color Look-Up Table Enable
            CLUTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x104);

        /// address: 0x40016908
        /// Layerx Window Horizontal Position
        /// Configuration Register
        pub const L2WHPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Window Horizontal Start
            /// Position
            WHSTPOS: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Window Horizontal Stop
            /// Position
            WHSPPOS: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x108);

        /// address: 0x4001690c
        /// Layerx Window Vertical Position
        /// Configuration Register
        pub const L2WVPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Window Vertical Start
            /// Position
            WVSTPOS: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Window Vertical Stop
            /// Position
            WVSPPOS: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x10c);

        /// address: 0x40016910
        /// Layerx Color Keying Configuration
        /// Register
        pub const L2CKCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Key Blue value
            CKBLUE: u8,
            /// Color Key Green value
            CKGREEN: u7,
            /// Color Key Red value
            CKRED: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x110);

        /// address: 0x40016914
        /// Layerx Pixel Format Configuration
        /// Register
        pub const L2PFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pixel Format
            PF: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x114);

        /// address: 0x40016918
        /// Layerx Constant Alpha Configuration
        /// Register
        pub const L2CACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Constant Alpha
            CONSTA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x118);

        /// address: 0x4001691c
        /// Layerx Default Color Configuration
        /// Register
        pub const L2DCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Default Color Blue
            DCBLUE: u8,
            /// Default Color Green
            DCGREEN: u8,
            /// Default Color Red
            DCRED: u8,
            /// Default Color Alpha
            DCALPHA: u8,
        }), base_address + 0x11c);

        /// address: 0x40016920
        /// Layerx Blending Factors Configuration
        /// Register
        pub const L2BFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blending Factor 2
            BF2: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Blending Factor 1
            BF1: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x120);

        /// address: 0x4001692c
        /// Layerx Color Frame Buffer Address
        /// Register
        pub const L2CFBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Frame Buffer Start
            /// Address
            CFBADD: u32,
        }), base_address + 0x12c);

        /// address: 0x40016930
        /// Layerx Color Frame Buffer Length
        /// Register
        pub const L2CFBLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Frame Buffer Line
            /// Length
            CFBLL: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Color Frame Buffer Pitch in
            /// bytes
            CFBP: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x130);

        /// address: 0x40016934
        /// Layerx ColorFrame Buffer Line Number
        /// Register
        pub const L2CFBLNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame Buffer Line Number
            CFBLNBR: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x134);

        /// address: 0x40016944
        /// Layerx CLUT Write Register
        pub const L2CLUTWR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blue value
            BLUE: u8,
            /// Green value
            GREEN: u8,
            /// Red value
            RED: u8,
            /// CLUT Address
            CLUTADD: u8,
        }), base_address + 0x144);
    };

    /// Serial audio interface
    pub const SAI1 = struct {
        pub const base_address = 0x40015800;

        /// address: 0x40015824
        /// BConfiguration register 1
        pub const BCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio block mode
            MODE: u2,
            /// Protocol configuration
            PRTCFG: u2,
            reserved0: u1,
            /// Data size
            DS: u3,
            /// Least significant bit
            /// first
            LSBFIRST: u1,
            /// Clock strobing edge
            CKSTR: u1,
            /// Synchronization enable
            SYNCEN: u2,
            /// Mono mode
            MONO: u1,
            /// Output drive
            OutDri: u1,
            reserved1: u1,
            reserved2: u1,
            /// Audio block B enable
            SAIBEN: u1,
            /// DMA enable
            DMAEN: u1,
            reserved3: u1,
            /// No divider
            NODIV: u1,
            /// Master clock divider
            MCKDIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x40015828
        /// BConfiguration register 2
        pub const BCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold
            FTH: u3,
            /// FIFO flush
            FFLUS: u1,
            /// Tristate management on data
            /// line
            TRIS: u1,
            /// Mute
            MUTE: u1,
            /// Mute value
            MUTEVAL: u1,
            /// Mute counter
            MUTECN: u6,
            /// Complement bit
            CPL: u1,
            /// Companding mode
            COMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4001582c
        /// BFRCR
        pub const BFRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame length
            FRL: u8,
            /// Frame synchronization active level
            /// length
            FSALL: u7,
            reserved0: u1,
            /// Frame synchronization
            /// definition
            FSDEF: u1,
            /// Frame synchronization
            /// polarity
            FSPOL: u1,
            /// Frame synchronization
            /// offset
            FSOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2c);

        /// address: 0x40015830
        /// BSlot register
        pub const BSLOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// First bit offset
            FBOFF: u5,
            reserved0: u1,
            /// Slot size
            SLOTSZ: u2,
            /// Number of slots in an audio
            /// frame
            NBSLOT: u4,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Slot enable
            SLOTEN: u16,
        }), base_address + 0x30);

        /// address: 0x40015834
        /// BInterrupt mask register2
        pub const BIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun/underrun interrupt
            /// enable
            OVRUDRIE: u1,
            /// Mute detection interrupt
            /// enable
            MUTEDET: u1,
            /// Wrong clock configuration interrupt
            /// enable
            WCKCFG: u1,
            /// FIFO request interrupt
            /// enable
            FREQIE: u1,
            /// Codec not ready interrupt
            /// enable
            CNRDYIE: u1,
            /// Anticipated frame synchronization
            /// detection interrupt enable
            AFSDETIE: u1,
            /// Late frame synchronization detection
            /// interrupt enable
            LFSDETIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x34);

        /// address: 0x40015838
        /// BStatus register
        pub const BSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun / underrun
            OVRUDR: u1,
            /// Mute detection
            MUTEDET: u1,
            /// Wrong clock configuration
            /// flag
            WCKCFG: u1,
            /// FIFO request
            FREQ: u1,
            /// Codec not ready
            CNRDY: u1,
            /// Anticipated frame synchronization
            /// detection
            AFSDET: u1,
            /// Late frame synchronization
            /// detection
            LFSDET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// FIFO level threshold
            FLVL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x38);

        /// address: 0x4001583c
        /// BClear flag register
        pub const BCLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear overrun / underrun
            OVRUDR: u1,
            /// Mute detection flag
            MUTEDET: u1,
            /// Clear wrong clock configuration
            /// flag
            WCKCFG: u1,
            reserved0: u1,
            /// Clear codec not ready flag
            CNRDY: u1,
            /// Clear anticipated frame synchronization
            /// detection flag
            CAFSDET: u1,
            /// Clear late frame synchronization
            /// detection flag
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x3c);

        /// address: 0x40015840
        /// BData register
        pub const BDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x40);

        /// address: 0x40015804
        /// AConfiguration register 1
        pub const ACR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio block mode
            MODE: u2,
            /// Protocol configuration
            PRTCFG: u2,
            reserved0: u1,
            /// Data size
            DS: u3,
            /// Least significant bit
            /// first
            LSBFIRST: u1,
            /// Clock strobing edge
            CKSTR: u1,
            /// Synchronization enable
            SYNCEN: u2,
            /// Mono mode
            MONO: u1,
            /// Output drive
            OutDri: u1,
            reserved1: u1,
            reserved2: u1,
            /// Audio block A enable
            SAIAEN: u1,
            /// DMA enable
            DMAEN: u1,
            reserved3: u1,
            /// No divider
            NODIV: u1,
            /// Master clock divider
            MCKDIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40015808
        /// AConfiguration register 2
        pub const ACR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold
            FTH: u3,
            /// FIFO flush
            FFLUS: u1,
            /// Tristate management on data
            /// line
            TRIS: u1,
            /// Mute
            MUTE: u1,
            /// Mute value
            MUTEVAL: u1,
            /// Mute counter
            MUTECN: u6,
            /// Complement bit
            CPL: u1,
            /// Companding mode
            COMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001580c
        /// AFRCR
        pub const AFRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame length
            FRL: u8,
            /// Frame synchronization active level
            /// length
            FSALL: u7,
            reserved0: u1,
            /// Frame synchronization
            /// definition
            FSDEF: u1,
            /// Frame synchronization
            /// polarity
            FSPOL: u1,
            /// Frame synchronization
            /// offset
            FSOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x40015810
        /// ASlot register
        pub const ASLOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// First bit offset
            FBOFF: u5,
            reserved0: u1,
            /// Slot size
            SLOTSZ: u2,
            /// Number of slots in an audio
            /// frame
            NBSLOT: u4,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Slot enable
            SLOTEN: u16,
        }), base_address + 0x10);

        /// address: 0x40015814
        /// AInterrupt mask register2
        pub const AIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun/underrun interrupt
            /// enable
            OVRUDRIE: u1,
            /// Mute detection interrupt
            /// enable
            MUTEDET: u1,
            /// Wrong clock configuration interrupt
            /// enable
            WCKCFG: u1,
            /// FIFO request interrupt
            /// enable
            FREQIE: u1,
            /// Codec not ready interrupt
            /// enable
            CNRDYIE: u1,
            /// Anticipated frame synchronization
            /// detection interrupt enable
            AFSDETIE: u1,
            /// Late frame synchronization detection
            /// interrupt enable
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40015818
        /// AStatus register
        pub const ASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun / underrun
            OVRUDR: u1,
            /// Mute detection
            MUTEDET: u1,
            /// Wrong clock configuration flag. This bit
            /// is read only.
            WCKCFG: u1,
            /// FIFO request
            FREQ: u1,
            /// Codec not ready
            CNRDY: u1,
            /// Anticipated frame synchronization
            /// detection
            AFSDET: u1,
            /// Late frame synchronization
            /// detection
            LFSDET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// FIFO level threshold
            FLVL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x18);

        /// address: 0x4001581c
        /// AClear flag register
        pub const ACLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear overrun / underrun
            OVRUDR: u1,
            /// Mute detection flag
            MUTEDET: u1,
            /// Clear wrong clock configuration
            /// flag
            WCKCFG: u1,
            reserved0: u1,
            /// Clear codec not ready flag
            CNRDY: u1,
            /// Clear anticipated frame synchronization
            /// detection flag.
            CAFSDET: u1,
            /// Clear late frame synchronization
            /// detection flag
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1c);

        /// address: 0x40015820
        /// AData register
        pub const ADR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x20);

        /// address: 0x40015800
        /// Global configuration register
        pub const GCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronization inputs
            SYNCIN: u2,
            reserved0: u1,
            reserved1: u1,
            /// Synchronization outputs
            SYNCOUT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);
    };
    pub const SAI2 = struct {
        pub const base_address = 0x40015c00;

        /// address: 0x40015c24
        /// BConfiguration register 1
        pub const BCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio block mode
            MODE: u2,
            /// Protocol configuration
            PRTCFG: u2,
            reserved0: u1,
            /// Data size
            DS: u3,
            /// Least significant bit
            /// first
            LSBFIRST: u1,
            /// Clock strobing edge
            CKSTR: u1,
            /// Synchronization enable
            SYNCEN: u2,
            /// Mono mode
            MONO: u1,
            /// Output drive
            OutDri: u1,
            reserved1: u1,
            reserved2: u1,
            /// Audio block B enable
            SAIBEN: u1,
            /// DMA enable
            DMAEN: u1,
            reserved3: u1,
            /// No divider
            NODIV: u1,
            /// Master clock divider
            MCKDIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x40015c28
        /// BConfiguration register 2
        pub const BCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold
            FTH: u3,
            /// FIFO flush
            FFLUS: u1,
            /// Tristate management on data
            /// line
            TRIS: u1,
            /// Mute
            MUTE: u1,
            /// Mute value
            MUTEVAL: u1,
            /// Mute counter
            MUTECN: u6,
            /// Complement bit
            CPL: u1,
            /// Companding mode
            COMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x40015c2c
        /// BFRCR
        pub const BFRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame length
            FRL: u8,
            /// Frame synchronization active level
            /// length
            FSALL: u7,
            reserved0: u1,
            /// Frame synchronization
            /// definition
            FSDEF: u1,
            /// Frame synchronization
            /// polarity
            FSPOL: u1,
            /// Frame synchronization
            /// offset
            FSOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2c);

        /// address: 0x40015c30
        /// BSlot register
        pub const BSLOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// First bit offset
            FBOFF: u5,
            reserved0: u1,
            /// Slot size
            SLOTSZ: u2,
            /// Number of slots in an audio
            /// frame
            NBSLOT: u4,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Slot enable
            SLOTEN: u16,
        }), base_address + 0x30);

        /// address: 0x40015c34
        /// BInterrupt mask register2
        pub const BIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun/underrun interrupt
            /// enable
            OVRUDRIE: u1,
            /// Mute detection interrupt
            /// enable
            MUTEDET: u1,
            /// Wrong clock configuration interrupt
            /// enable
            WCKCFG: u1,
            /// FIFO request interrupt
            /// enable
            FREQIE: u1,
            /// Codec not ready interrupt
            /// enable
            CNRDYIE: u1,
            /// Anticipated frame synchronization
            /// detection interrupt enable
            AFSDETIE: u1,
            /// Late frame synchronization detection
            /// interrupt enable
            LFSDETIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x34);

        /// address: 0x40015c38
        /// BStatus register
        pub const BSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun / underrun
            OVRUDR: u1,
            /// Mute detection
            MUTEDET: u1,
            /// Wrong clock configuration
            /// flag
            WCKCFG: u1,
            /// FIFO request
            FREQ: u1,
            /// Codec not ready
            CNRDY: u1,
            /// Anticipated frame synchronization
            /// detection
            AFSDET: u1,
            /// Late frame synchronization
            /// detection
            LFSDET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// FIFO level threshold
            FLVL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x38);

        /// address: 0x40015c3c
        /// BClear flag register
        pub const BCLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear overrun / underrun
            OVRUDR: u1,
            /// Mute detection flag
            MUTEDET: u1,
            /// Clear wrong clock configuration
            /// flag
            WCKCFG: u1,
            reserved0: u1,
            /// Clear codec not ready flag
            CNRDY: u1,
            /// Clear anticipated frame synchronization
            /// detection flag
            CAFSDET: u1,
            /// Clear late frame synchronization
            /// detection flag
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x3c);

        /// address: 0x40015c40
        /// BData register
        pub const BDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x40);

        /// address: 0x40015c04
        /// AConfiguration register 1
        pub const ACR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio block mode
            MODE: u2,
            /// Protocol configuration
            PRTCFG: u2,
            reserved0: u1,
            /// Data size
            DS: u3,
            /// Least significant bit
            /// first
            LSBFIRST: u1,
            /// Clock strobing edge
            CKSTR: u1,
            /// Synchronization enable
            SYNCEN: u2,
            /// Mono mode
            MONO: u1,
            /// Output drive
            OutDri: u1,
            reserved1: u1,
            reserved2: u1,
            /// Audio block A enable
            SAIAEN: u1,
            /// DMA enable
            DMAEN: u1,
            reserved3: u1,
            /// No divider
            NODIV: u1,
            /// Master clock divider
            MCKDIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40015c08
        /// AConfiguration register 2
        pub const ACR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold
            FTH: u3,
            /// FIFO flush
            FFLUS: u1,
            /// Tristate management on data
            /// line
            TRIS: u1,
            /// Mute
            MUTE: u1,
            /// Mute value
            MUTEVAL: u1,
            /// Mute counter
            MUTECN: u6,
            /// Complement bit
            CPL: u1,
            /// Companding mode
            COMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40015c0c
        /// AFRCR
        pub const AFRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame length
            FRL: u8,
            /// Frame synchronization active level
            /// length
            FSALL: u7,
            reserved0: u1,
            /// Frame synchronization
            /// definition
            FSDEF: u1,
            /// Frame synchronization
            /// polarity
            FSPOL: u1,
            /// Frame synchronization
            /// offset
            FSOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x40015c10
        /// ASlot register
        pub const ASLOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// First bit offset
            FBOFF: u5,
            reserved0: u1,
            /// Slot size
            SLOTSZ: u2,
            /// Number of slots in an audio
            /// frame
            NBSLOT: u4,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Slot enable
            SLOTEN: u16,
        }), base_address + 0x10);

        /// address: 0x40015c14
        /// AInterrupt mask register2
        pub const AIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun/underrun interrupt
            /// enable
            OVRUDRIE: u1,
            /// Mute detection interrupt
            /// enable
            MUTEDET: u1,
            /// Wrong clock configuration interrupt
            /// enable
            WCKCFG: u1,
            /// FIFO request interrupt
            /// enable
            FREQIE: u1,
            /// Codec not ready interrupt
            /// enable
            CNRDYIE: u1,
            /// Anticipated frame synchronization
            /// detection interrupt enable
            AFSDETIE: u1,
            /// Late frame synchronization detection
            /// interrupt enable
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40015c18
        /// AStatus register
        pub const ASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun / underrun
            OVRUDR: u1,
            /// Mute detection
            MUTEDET: u1,
            /// Wrong clock configuration flag. This bit
            /// is read only.
            WCKCFG: u1,
            /// FIFO request
            FREQ: u1,
            /// Codec not ready
            CNRDY: u1,
            /// Anticipated frame synchronization
            /// detection
            AFSDET: u1,
            /// Late frame synchronization
            /// detection
            LFSDET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// FIFO level threshold
            FLVL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x18);

        /// address: 0x40015c1c
        /// AClear flag register
        pub const ACLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear overrun / underrun
            OVRUDR: u1,
            /// Mute detection flag
            MUTEDET: u1,
            /// Clear wrong clock configuration
            /// flag
            WCKCFG: u1,
            reserved0: u1,
            /// Clear codec not ready flag
            CNRDY: u1,
            /// Clear anticipated frame synchronization
            /// detection flag.
            CAFSDET: u1,
            /// Clear late frame synchronization
            /// detection flag
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1c);

        /// address: 0x40015c20
        /// AData register
        pub const ADR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x20);

        /// address: 0x40015c00
        /// Global configuration register
        pub const GCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronization inputs
            SYNCIN: u2,
            reserved0: u1,
            reserved1: u1,
            /// Synchronization outputs
            SYNCOUT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);
    };

    /// DMA2D controller
    pub const DMA2D = struct {
        pub const base_address = 0x4002b000;

        /// address: 0x4002b000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start
            START: u1,
            /// Suspend
            SUSP: u1,
            /// Abort
            ABORT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Transfer watermark interrupt
            /// enable
            TWIE: u1,
            /// CLUT access error interrupt
            /// enable
            CAEIE: u1,
            /// CLUT transfer complete interrupt
            /// enable
            CTCIE: u1,
            /// Configuration Error Interrupt
            /// Enable
            CEIE: u1,
            reserved5: u1,
            reserved6: u1,
            /// DMA2D mode
            MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x0);

        /// address: 0x4002b004
        /// Interrupt Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer error interrupt
            /// flag
            TEIF: u1,
            /// Transfer complete interrupt
            /// flag
            TCIF: u1,
            /// Transfer watermark interrupt
            /// flag
            TWIF: u1,
            /// CLUT access error interrupt
            /// flag
            CAEIF: u1,
            /// CLUT transfer complete interrupt
            /// flag
            CTCIF: u1,
            /// Configuration error interrupt
            /// flag
            CEIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x4);

        /// address: 0x4002b008
        /// interrupt flag clear register
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear Transfer error interrupt
            /// flag
            CTEIF: u1,
            /// Clear transfer complete interrupt
            /// flag
            CTCIF: u1,
            /// Clear transfer watermark interrupt
            /// flag
            CTWIF: u1,
            /// Clear CLUT access error interrupt
            /// flag
            CAECIF: u1,
            /// Clear CLUT transfer complete interrupt
            /// flag
            CCTCIF: u1,
            /// Clear configuration error interrupt
            /// flag
            CCEIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8);

        /// address: 0x4002b00c
        /// foreground memory address
        /// register
        pub const FGMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0xc);

        /// address: 0x4002b010
        /// foreground offset register
        pub const FGOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line offset
            LO: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x10);

        /// address: 0x4002b014
        /// background memory address
        /// register
        pub const BGMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002b018
        /// background offset register
        pub const BGOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line offset
            LO: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x18);

        /// address: 0x4002b01c
        /// foreground PFC control
        /// register
        pub const FGPFCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color mode
            CM: u4,
            /// CLUT color mode
            CCM: u1,
            /// Start
            START: u1,
            reserved0: u1,
            reserved1: u1,
            /// CLUT size
            CS: u8,
            /// Alpha mode
            AM: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Alpha value
            ALPHA: u8,
        }), base_address + 0x1c);

        /// address: 0x4002b020
        /// foreground color register
        pub const FGCOLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blue Value
            BLUE: u8,
            /// Green Value
            GREEN: u8,
            /// Red Value
            RED: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x20);

        /// address: 0x4002b024
        /// background PFC control
        /// register
        pub const BGPFCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color mode
            CM: u4,
            /// CLUT Color mode
            CCM: u1,
            /// Start
            START: u1,
            reserved0: u1,
            reserved1: u1,
            /// CLUT size
            CS: u8,
            /// Alpha mode
            AM: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Alpha value
            ALPHA: u8,
        }), base_address + 0x24);

        /// address: 0x4002b028
        /// background color register
        pub const BGCOLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blue Value
            BLUE: u8,
            /// Green Value
            GREEN: u8,
            /// Red Value
            RED: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x4002b02c
        /// foreground CLUT memory address
        /// register
        pub const FGCMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory Address
            MA: u32,
        }), base_address + 0x2c);

        /// address: 0x4002b030
        /// background CLUT memory address
        /// register
        pub const BGCMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x30);

        /// address: 0x4002b034
        /// output PFC control register
        pub const OPFCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color mode
            CM: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x34);

        /// address: 0x4002b038
        /// output color register
        pub const OCOLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Blue Value
            BLUE: u8,
            /// Green Value
            GREEN: u8,
            /// Red Value
            RED: u8,
            /// Alpha Channel Value
            APLHA: u8,
        }), base_address + 0x38);

        /// address: 0x4002b03c
        /// output memory address register
        pub const OMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory Address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x4002b040
        /// output offset register
        pub const OOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line Offset
            LO: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x40);

        /// address: 0x4002b044
        /// number of line register
        pub const NLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of lines
            NL: u16,
            /// Pixel per lines
            PL: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x44);

        /// address: 0x4002b048
        /// line watermark register
        pub const LWR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line watermark
            LW: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002b04c
        /// AHB master timer configuration
        /// register
        pub const AMTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Dead Time
            DT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x4002b400
        /// FGCLUT
        pub const FGCLUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// BLUE
            BLUE: u8,
            /// GREEN
            GREEN: u8,
            /// RED
            RED: u8,
            /// APLHA
            APLHA: u8,
        }), base_address + 0x400);

        /// address: 0x4002b800
        /// BGCLUT
        pub const BGCLUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// BLUE
            BLUE: u8,
            /// GREEN
            GREEN: u8,
            /// RED
            RED: u8,
            /// APLHA
            APLHA: u8,
        }), base_address + 0x800);
    };

    /// QuadSPI interface
    pub const QUADSPI = struct {
        pub const base_address = 0xa0001000;

        /// address: 0xa0001000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            EN: u1,
            /// Abort request
            ABORT: u1,
            /// DMA enable
            DMAEN: u1,
            /// Timeout counter enable
            TCEN: u1,
            /// Sample shift
            SSHIFT: u1,
            reserved0: u1,
            /// Dual-flash mode
            DFM: u1,
            /// FLASH memory selection
            FSEL: u1,
            /// IFO threshold level
            FTHRES: u5,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// FIFO threshold interrupt
            /// enable
            FTIE: u1,
            /// Status match interrupt
            /// enable
            SMIE: u1,
            /// TimeOut interrupt enable
            TOIE: u1,
            reserved4: u1,
            /// Automatic poll mode stop
            APMS: u1,
            /// Polling match mode
            PMM: u1,
            /// Clock prescaler
            PRESCALER: u8,
        }), base_address + 0x0);

        /// address: 0xa0001004
        /// device configuration register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Mode 0 / mode 3
            CKMODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Chip select high time
            CSHT: u3,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// FLASH memory size
            FSIZE: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x4);

        /// address: 0xa0001008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer error flag
            TEF: u1,
            /// Transfer complete flag
            TCF: u1,
            /// FIFO threshold flag
            FTF: u1,
            /// Status match flag
            SMF: u1,
            /// Timeout flag
            TOF: u1,
            /// Busy
            BUSY: u1,
            reserved0: u1,
            reserved1: u1,
            /// FIFO level
            FLEVEL: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0xa000100c
        /// flag clear register
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear transfer error flag
            CTEF: u1,
            /// Clear transfer complete
            /// flag
            CTCF: u1,
            reserved0: u1,
            /// Clear status match flag
            CSMF: u1,
            /// Clear timeout flag
            CTOF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xc);

        /// address: 0xa0001010
        /// data length register
        pub const DLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length
            DL: u32,
        }), base_address + 0x10);

        /// address: 0xa0001014
        /// communication configuration
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Instruction
            INSTRUCTION: u8,
            /// Instruction mode
            IMODE: u2,
            /// Address mode
            ADMODE: u2,
            /// Address size
            ADSIZE: u2,
            /// Alternate bytes mode
            ABMODE: u2,
            /// Alternate bytes size
            ABSIZE: u2,
            /// Number of dummy cycles
            DCYC: u5,
            reserved0: u1,
            /// Data mode
            DMODE: u2,
            /// Functional mode
            FMODE: u2,
            /// Send instruction only once
            /// mode
            SIOO: u1,
            reserved1: u1,
            /// DDR hold half cycle
            DHHC: u1,
            /// Double data rate mode
            DDRM: u1,
        }), base_address + 0x14);

        /// address: 0xa0001018
        /// address register
        pub const AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address
            ADDRESS: u32,
        }), base_address + 0x18);

        /// address: 0xa000101c
        /// ABR
        pub const ABR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ALTERNATE
            ALTERNATE: u32,
        }), base_address + 0x1c);

        /// address: 0xa0001020
        /// data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x20);

        /// address: 0xa0001024
        /// polling status mask register
        pub const PSMKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status mask
            MASK: u32,
        }), base_address + 0x24);

        /// address: 0xa0001028
        /// polling status match register
        pub const PSMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status match
            MATCH: u32,
        }), base_address + 0x28);

        /// address: 0xa000102c
        /// polling interval register
        pub const PIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Polling interval
            INTERVAL: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0xa0001030
        /// low-power timeout register
        pub const LPTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout period
            TIMEOUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);
    };

    /// HDMI-CEC controller
    pub const CEC = struct {
        pub const base_address = 0x40006c00;

        /// address: 0x40006c00
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CEC Enable
            CECEN: u1,
            /// Tx start of message
            TXSOM: u1,
            /// Tx End Of Message
            TXEOM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40006c04
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Signal Free Time
            SFT: u3,
            /// Rx-Tolerance
            RXTOL: u1,
            /// Rx-stop on bit rising
            /// error
            BRESTP: u1,
            /// Generate error-bit on bit rising
            /// error
            BREGEN: u1,
            /// Generate Error-Bit on Long Bit Period
            /// Error
            LBPEGEN: u1,
            /// Avoid Error-Bit Generation in
            /// Broadcast
            BRDNOGEN: u1,
            /// SFT Option Bit
            SFTOP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Own addresses
            /// configuration
            OAR: u15,
            /// Listen mode
            LSTN: u1,
        }), base_address + 0x4);

        /// address: 0x40006c08
        /// Tx data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Data register
            TXD: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40006c0c
        /// Rx Data Register
        pub const RXDR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xc);

        /// address: 0x40006c10
        /// Interrupt and Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx-Byte Received
            RXBR: u1,
            /// End Of Reception
            RXEND: u1,
            /// Rx-Overrun
            RXOVR: u1,
            /// Rx-Bit rising error
            BRE: u1,
            /// Rx-Short Bit period error
            SBPE: u1,
            /// Rx-Long Bit Period Error
            LBPE: u1,
            /// Rx-Missing Acknowledge
            RXACKE: u1,
            /// Arbitration Lost
            ARBLST: u1,
            /// Tx-Byte Request
            TXBR: u1,
            /// End of Transmission
            TXEND: u1,
            /// Tx-Buffer Underrun
            TXUDR: u1,
            /// Tx-Error
            TXERR: u1,
            /// Tx-Missing acknowledge
            /// error
            TXACKE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40006c14
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx-Byte Received Interrupt
            /// Enable
            RXBRIE: u1,
            /// End Of Reception Interrupt
            /// Enable
            RXENDIE: u1,
            /// Rx-Buffer Overrun Interrupt
            /// Enable
            RXOVRIE: u1,
            /// Bit Rising Error Interrupt
            /// Enable
            BREIE: u1,
            /// Short Bit Period Error Interrupt
            /// Enable
            SBPEIE: u1,
            /// Long Bit Period Error Interrupt
            /// Enable
            LBPEIE: u1,
            /// Rx-Missing Acknowledge Error Interrupt
            /// Enable
            RXACKIE: u1,
            /// Arbitration Lost Interrupt
            /// Enable
            ARBLSTIE: u1,
            /// Tx-Byte Request Interrupt
            /// Enable
            TXBRIE: u1,
            /// Tx-End of message interrupt
            /// enable
            TXENDIE: u1,
            /// Tx-Underrun interrupt
            /// enable
            TXUDRIE: u1,
            /// Tx-Error Interrupt Enable
            TXERRIE: u1,
            /// Tx-Missing Acknowledge Error Interrupt
            /// Enable
            TXACKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x14);
    };

    /// Receiver Interface
    pub const SPDIFRX = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004000
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral Block Enable
            SPDIFEN: u2,
            /// Receiver DMA ENable for data
            /// flow
            RXDMAEN: u1,
            /// STerEO Mode
            RXSTEO: u1,
            /// RX Data format
            DRFMT: u2,
            /// Mask Parity error bit
            PMSK: u1,
            /// Mask of Validity bit
            VMSK: u1,
            /// Mask of channel status and user
            /// bits
            CUMSK: u1,
            /// Mask of Preamble Type bits
            PTMSK: u1,
            /// Control Buffer DMA ENable for control
            /// flow
            CBDMAEN: u1,
            /// Channel Selection
            CHSEL: u1,
            /// Maximum allowed re-tries during
            /// synchronization phase
            NBTR: u2,
            /// Wait For Activity
            WFA: u1,
            reserved0: u1,
            /// input selection
            INSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x0);

        /// address: 0x40004004
        /// Interrupt mask register
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Control Buffer Ready Interrupt
            /// Enable
            CSRNEIE: u1,
            /// Parity error interrupt
            /// enable
            PERRIE: u1,
            /// Overrun error Interrupt
            /// Enable
            OVRIE: u1,
            /// Synchronization Block Detected Interrupt
            /// Enable
            SBLKIE: u1,
            /// Synchronization Done
            SYNCDIE: u1,
            /// Serial Interface Error Interrupt
            /// Enable
            IFEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40004008
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Control Buffer register is not
            /// empty
            CSRNE: u1,
            /// Parity error
            PERR: u1,
            /// Overrun error
            OVR: u1,
            /// Synchronization Block
            /// Detected
            SBD: u1,
            /// Synchronization Done
            SYNCD: u1,
            /// Framing error
            FERR: u1,
            /// Synchronization error
            SERR: u1,
            /// Time-out error
            TERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Duration of 5 symbols counted with
            /// SPDIF_CLK
            WIDTH5: u15,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x4000400c
        /// Interrupt Flag Clear register
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clears the Parity error
            /// flag
            PERRCF: u1,
            /// Clears the Overrun error
            /// flag
            OVRCF: u1,
            /// Clears the Synchronization Block
            /// Detected flag
            SBDCF: u1,
            /// Clears the Synchronization Done
            /// flag
            SYNCDCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40004010
        /// Data input register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity Error bit
            DR: u24,
            /// Parity Error bit
            PE: u1,
            /// Validity bit
            V: u1,
            /// User bit
            U: u1,
            /// Channel Status bit
            C: u1,
            /// Preamble Type
            PT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40004014
        /// Channel Status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// User data information
            USR: u16,
            /// Channel A status
            /// information
            CS: u8,
            /// Start Of Block
            SOB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x14);

        /// address: 0x40004018
        /// Debug Information register
        pub const DIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Threshold HIGH
            THI: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Threshold LOW
            TLO: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x18);
    };

    /// Secure digital input/output
    /// interface
    pub const SDMMC1 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// power control register
        pub const POWER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWRCTRL
            PWRCTRL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x40012c04
        /// SDI clock control register
        pub const CLKCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock divide factor
            CLKDIV: u8,
            /// Clock enable bit
            CLKEN: u1,
            /// Power saving configuration
            /// bit
            PWRSAV: u1,
            /// Clock divider bypass enable
            /// bit
            BYPASS: u1,
            /// Wide bus mode enable bit
            WIDBUS: u2,
            /// SDIO_CK dephasing selection
            /// bit
            NEGEDGE: u1,
            /// HW Flow Control enable
            HWFC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40012c08
        /// argument register
        pub const ARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMDARG: u32,
        }), base_address + 0x8);

        /// address: 0x40012c0c
        /// command register
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command index
            CMDINDEX: u6,
            /// Wait for response bits
            WAITRESP: u2,
            /// CPSM waits for interrupt
            /// request
            WAITINT: u1,
            /// CPSM Waits for ends of data transfer
            /// (CmdPend internal signal)
            WAITPEND: u1,
            /// Command path state machine (CPSM) Enable
            /// bit
            CPSMEN: u1,
            /// SD I/O suspend command
            SDIOSuspend: u1,
            /// Enable CMD completion
            ENCMDcompl: u1,
            /// not Interrupt Enable
            nIEN: u1,
            /// CE-ATA command
            CE_ATACMD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40012c10
        /// command response register
        pub const RESPCMD = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x10);

        /// address: 0x40012c14
        /// response 1..4 register
        pub const RESP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS1: u32,
        }), base_address + 0x14);

        /// address: 0x40012c18
        /// response 1..4 register
        pub const RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS2: u32,
        }), base_address + 0x18);

        /// address: 0x40012c1c
        /// response 1..4 register
        pub const RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS3: u32,
        }), base_address + 0x1c);

        /// address: 0x40012c20
        /// response 1..4 register
        pub const RESP4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS4: u32,
        }), base_address + 0x20);

        /// address: 0x40012c24
        /// data timer register
        pub const DTIMER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data timeout period
            DATATIME: u32,
        }), base_address + 0x24);

        /// address: 0x40012c28
        /// data length register
        pub const DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length value
            DATALENGTH: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x28);

        /// address: 0x40012c2c
        /// data control register
        pub const DCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DTEN
            DTEN: u1,
            /// Data transfer direction
            /// selection
            DTDIR: u1,
            /// Data transfer mode selection 1: Stream
            /// or SDIO multibyte data transfer
            DTMODE: u1,
            /// DMA enable bit
            DMAEN: u1,
            /// Data block size
            DBLOCKSIZE: u4,
            /// Read wait start
            RWSTART: u1,
            /// Read wait stop
            RWSTOP: u1,
            /// Read wait mode
            RWMOD: u1,
            /// SD I/O enable functions
            SDIOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40012c30
        /// data counter register
        pub const DCOUNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data count value
            DATACOUNT: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x30);

        /// address: 0x40012c34
        /// status register
        pub const STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command response received (CRC check
            /// failed)
            CCRCFAIL: u1,
            /// Data block sent/received (CRC check
            /// failed)
            DCRCFAIL: u1,
            /// Command response timeout
            CTIMEOUT: u1,
            /// Data timeout
            DTIMEOUT: u1,
            /// Transmit FIFO underrun
            /// error
            TXUNDERR: u1,
            /// Received FIFO overrun
            /// error
            RXOVERR: u1,
            /// Command response received (CRC check
            /// passed)
            CMDREND: u1,
            /// Command sent (no response
            /// required)
            CMDSENT: u1,
            /// Data end (data counter, SDIDCOUNT, is
            /// zero)
            DATAEND: u1,
            /// Start bit not detected on all data
            /// signals in wide bus mode
            STBITERR: u1,
            /// Data block sent/received (CRC check
            /// passed)
            DBCKEND: u1,
            /// Command transfer in
            /// progress
            CMDACT: u1,
            /// Data transmit in progress
            TXACT: u1,
            /// Data receive in progress
            RXACT: u1,
            /// Transmit FIFO half empty: at least 8
            /// words can be written into the FIFO
            TXFIFOHE: u1,
            /// Receive FIFO half full: there are at
            /// least 8 words in the FIFO
            RXFIFOHF: u1,
            /// Transmit FIFO full
            TXFIFOF: u1,
            /// Receive FIFO full
            RXFIFOF: u1,
            /// Transmit FIFO empty
            TXFIFOE: u1,
            /// Receive FIFO empty
            RXFIFOE: u1,
            /// Data available in transmit
            /// FIFO
            TXDAVL: u1,
            /// Data available in receive
            /// FIFO
            RXDAVL: u1,
            /// SDIO interrupt received
            SDIOIT: u1,
            /// CE-ATA command completion signal
            /// received for CMD61
            CEATAEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x40012c38
        /// interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCRCFAIL flag clear bit
            CCRCFAILC: u1,
            /// DCRCFAIL flag clear bit
            DCRCFAILC: u1,
            /// CTIMEOUT flag clear bit
            CTIMEOUTC: u1,
            /// DTIMEOUT flag clear bit
            DTIMEOUTC: u1,
            /// TXUNDERR flag clear bit
            TXUNDERRC: u1,
            /// RXOVERR flag clear bit
            RXOVERRC: u1,
            /// CMDREND flag clear bit
            CMDRENDC: u1,
            /// CMDSENT flag clear bit
            CMDSENTC: u1,
            /// DATAEND flag clear bit
            DATAENDC: u1,
            /// STBITERR flag clear bit
            STBITERRC: u1,
            /// DBCKEND flag clear bit
            DBCKENDC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// SDIOIT flag clear bit
            SDIOITC: u1,
            /// CEATAEND flag clear bit
            CEATAENDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x38);

        /// address: 0x40012c3c
        /// mask register
        pub const MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command CRC fail interrupt
            /// enable
            CCRCFAILIE: u1,
            /// Data CRC fail interrupt
            /// enable
            DCRCFAILIE: u1,
            /// Command timeout interrupt
            /// enable
            CTIMEOUTIE: u1,
            /// Data timeout interrupt
            /// enable
            DTIMEOUTIE: u1,
            /// Tx FIFO underrun error interrupt
            /// enable
            TXUNDERRIE: u1,
            /// Rx FIFO overrun error interrupt
            /// enable
            RXOVERRIE: u1,
            /// Command response received interrupt
            /// enable
            CMDRENDIE: u1,
            /// Command sent interrupt
            /// enable
            CMDSENTIE: u1,
            /// Data end interrupt enable
            DATAENDIE: u1,
            /// Start bit error interrupt
            /// enable
            STBITERRIE: u1,
            /// Data block end interrupt
            /// enable
            DBCKENDIE: u1,
            /// Command acting interrupt
            /// enable
            CMDACTIE: u1,
            /// Data transmit acting interrupt
            /// enable
            TXACTIE: u1,
            /// Data receive acting interrupt
            /// enable
            RXACTIE: u1,
            /// Tx FIFO half empty interrupt
            /// enable
            TXFIFOHEIE: u1,
            /// Rx FIFO half full interrupt
            /// enable
            RXFIFOHFIE: u1,
            /// Tx FIFO full interrupt
            /// enable
            TXFIFOFIE: u1,
            /// Rx FIFO full interrupt
            /// enable
            RXFIFOFIE: u1,
            /// Tx FIFO empty interrupt
            /// enable
            TXFIFOEIE: u1,
            /// Rx FIFO empty interrupt
            /// enable
            RXFIFOEIE: u1,
            /// Data available in Tx FIFO interrupt
            /// enable
            TXDAVLIE: u1,
            /// Data available in Rx FIFO interrupt
            /// enable
            RXDAVLIE: u1,
            /// SDIO mode interrupt received interrupt
            /// enable
            SDIOITIE: u1,
            /// CE-ATA command completion signal
            /// received interrupt enable
            CEATAENDIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x3c);

        /// address: 0x40012c48
        /// FIFO counter register
        pub const FIFOCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remaining number of words to be written
            /// to or read from the FIFO
            FIFOCOUNT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x40012c80
        /// data FIFO register
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive and transmit FIFO
            /// data
            FIFOData: u32,
        }), base_address + 0x80);
    };
    pub const SDMMC2 = struct {
        pub const base_address = 0x40011c00;

        /// address: 0x40011c00
        /// power control register
        pub const POWER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWRCTRL
            PWRCTRL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x40011c04
        /// SDI clock control register
        pub const CLKCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock divide factor
            CLKDIV: u8,
            /// Clock enable bit
            CLKEN: u1,
            /// Power saving configuration
            /// bit
            PWRSAV: u1,
            /// Clock divider bypass enable
            /// bit
            BYPASS: u1,
            /// Wide bus mode enable bit
            WIDBUS: u2,
            /// SDIO_CK dephasing selection
            /// bit
            NEGEDGE: u1,
            /// HW Flow Control enable
            HWFC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40011c08
        /// argument register
        pub const ARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMDARG: u32,
        }), base_address + 0x8);

        /// address: 0x40011c0c
        /// command register
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command index
            CMDINDEX: u6,
            /// Wait for response bits
            WAITRESP: u2,
            /// CPSM waits for interrupt
            /// request
            WAITINT: u1,
            /// CPSM Waits for ends of data transfer
            /// (CmdPend internal signal)
            WAITPEND: u1,
            /// Command path state machine (CPSM) Enable
            /// bit
            CPSMEN: u1,
            /// SD I/O suspend command
            SDIOSuspend: u1,
            /// Enable CMD completion
            ENCMDcompl: u1,
            /// not Interrupt Enable
            nIEN: u1,
            /// CE-ATA command
            CE_ATACMD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40011c10
        /// command response register
        pub const RESPCMD = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x10);

        /// address: 0x40011c14
        /// response 1..4 register
        pub const RESP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS1: u32,
        }), base_address + 0x14);

        /// address: 0x40011c18
        /// response 1..4 register
        pub const RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS2: u32,
        }), base_address + 0x18);

        /// address: 0x40011c1c
        /// response 1..4 register
        pub const RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS3: u32,
        }), base_address + 0x1c);

        /// address: 0x40011c20
        /// response 1..4 register
        pub const RESP4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS4: u32,
        }), base_address + 0x20);

        /// address: 0x40011c24
        /// data timer register
        pub const DTIMER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data timeout period
            DATATIME: u32,
        }), base_address + 0x24);

        /// address: 0x40011c28
        /// data length register
        pub const DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length value
            DATALENGTH: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x28);

        /// address: 0x40011c2c
        /// data control register
        pub const DCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DTEN
            DTEN: u1,
            /// Data transfer direction
            /// selection
            DTDIR: u1,
            /// Data transfer mode selection 1: Stream
            /// or SDIO multibyte data transfer
            DTMODE: u1,
            /// DMA enable bit
            DMAEN: u1,
            /// Data block size
            DBLOCKSIZE: u4,
            /// Read wait start
            RWSTART: u1,
            /// Read wait stop
            RWSTOP: u1,
            /// Read wait mode
            RWMOD: u1,
            /// SD I/O enable functions
            SDIOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40011c30
        /// data counter register
        pub const DCOUNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data count value
            DATACOUNT: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x30);

        /// address: 0x40011c34
        /// status register
        pub const STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command response received (CRC check
            /// failed)
            CCRCFAIL: u1,
            /// Data block sent/received (CRC check
            /// failed)
            DCRCFAIL: u1,
            /// Command response timeout
            CTIMEOUT: u1,
            /// Data timeout
            DTIMEOUT: u1,
            /// Transmit FIFO underrun
            /// error
            TXUNDERR: u1,
            /// Received FIFO overrun
            /// error
            RXOVERR: u1,
            /// Command response received (CRC check
            /// passed)
            CMDREND: u1,
            /// Command sent (no response
            /// required)
            CMDSENT: u1,
            /// Data end (data counter, SDIDCOUNT, is
            /// zero)
            DATAEND: u1,
            /// Start bit not detected on all data
            /// signals in wide bus mode
            STBITERR: u1,
            /// Data block sent/received (CRC check
            /// passed)
            DBCKEND: u1,
            /// Command transfer in
            /// progress
            CMDACT: u1,
            /// Data transmit in progress
            TXACT: u1,
            /// Data receive in progress
            RXACT: u1,
            /// Transmit FIFO half empty: at least 8
            /// words can be written into the FIFO
            TXFIFOHE: u1,
            /// Receive FIFO half full: there are at
            /// least 8 words in the FIFO
            RXFIFOHF: u1,
            /// Transmit FIFO full
            TXFIFOF: u1,
            /// Receive FIFO full
            RXFIFOF: u1,
            /// Transmit FIFO empty
            TXFIFOE: u1,
            /// Receive FIFO empty
            RXFIFOE: u1,
            /// Data available in transmit
            /// FIFO
            TXDAVL: u1,
            /// Data available in receive
            /// FIFO
            RXDAVL: u1,
            /// SDIO interrupt received
            SDIOIT: u1,
            /// CE-ATA command completion signal
            /// received for CMD61
            CEATAEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x40011c38
        /// interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCRCFAIL flag clear bit
            CCRCFAILC: u1,
            /// DCRCFAIL flag clear bit
            DCRCFAILC: u1,
            /// CTIMEOUT flag clear bit
            CTIMEOUTC: u1,
            /// DTIMEOUT flag clear bit
            DTIMEOUTC: u1,
            /// TXUNDERR flag clear bit
            TXUNDERRC: u1,
            /// RXOVERR flag clear bit
            RXOVERRC: u1,
            /// CMDREND flag clear bit
            CMDRENDC: u1,
            /// CMDSENT flag clear bit
            CMDSENTC: u1,
            /// DATAEND flag clear bit
            DATAENDC: u1,
            /// STBITERR flag clear bit
            STBITERRC: u1,
            /// DBCKEND flag clear bit
            DBCKENDC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// SDIOIT flag clear bit
            SDIOITC: u1,
            /// CEATAEND flag clear bit
            CEATAENDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x38);

        /// address: 0x40011c3c
        /// mask register
        pub const MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command CRC fail interrupt
            /// enable
            CCRCFAILIE: u1,
            /// Data CRC fail interrupt
            /// enable
            DCRCFAILIE: u1,
            /// Command timeout interrupt
            /// enable
            CTIMEOUTIE: u1,
            /// Data timeout interrupt
            /// enable
            DTIMEOUTIE: u1,
            /// Tx FIFO underrun error interrupt
            /// enable
            TXUNDERRIE: u1,
            /// Rx FIFO overrun error interrupt
            /// enable
            RXOVERRIE: u1,
            /// Command response received interrupt
            /// enable
            CMDRENDIE: u1,
            /// Command sent interrupt
            /// enable
            CMDSENTIE: u1,
            /// Data end interrupt enable
            DATAENDIE: u1,
            /// Start bit error interrupt
            /// enable
            STBITERRIE: u1,
            /// Data block end interrupt
            /// enable
            DBCKENDIE: u1,
            /// Command acting interrupt
            /// enable
            CMDACTIE: u1,
            /// Data transmit acting interrupt
            /// enable
            TXACTIE: u1,
            /// Data receive acting interrupt
            /// enable
            RXACTIE: u1,
            /// Tx FIFO half empty interrupt
            /// enable
            TXFIFOHEIE: u1,
            /// Rx FIFO half full interrupt
            /// enable
            RXFIFOHFIE: u1,
            /// Tx FIFO full interrupt
            /// enable
            TXFIFOFIE: u1,
            /// Rx FIFO full interrupt
            /// enable
            RXFIFOFIE: u1,
            /// Tx FIFO empty interrupt
            /// enable
            TXFIFOEIE: u1,
            /// Rx FIFO empty interrupt
            /// enable
            RXFIFOEIE: u1,
            /// Data available in Tx FIFO interrupt
            /// enable
            TXDAVLIE: u1,
            /// Data available in Rx FIFO interrupt
            /// enable
            RXDAVLIE: u1,
            /// SDIO mode interrupt received interrupt
            /// enable
            SDIOITIE: u1,
            /// CE-ATA command completion signal
            /// received interrupt enable
            CEATAENDIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x3c);

        /// address: 0x40011c48
        /// FIFO counter register
        pub const FIFOCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remaining number of words to be written
            /// to or read from the FIFO
            FIFOCOUNT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x40011c80
        /// data FIFO register
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive and transmit FIFO
            /// data
            FIFOData: u32,
        }), base_address + 0x80);
    };

    /// Low power timer
    pub const LPTIM1 = struct {
        pub const base_address = 0x40002400;

        /// address: 0x40002400
        /// Interrupt and Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match
            CMPM: u1,
            /// Autoreload match
            ARRM: u1,
            /// External trigger edge
            /// event
            EXTTRIG: u1,
            /// Compare register update OK
            CMPOK: u1,
            /// Autoreload register update
            /// OK
            ARROK: u1,
            /// Counter direction change down to
            /// up
            UP: u1,
            /// Counter direction change up to
            /// down
            DOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x0);

        /// address: 0x40002404
        /// Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// compare match Clear Flag
            CMPMCF: u1,
            /// Autoreload match Clear
            /// Flag
            ARRMCF: u1,
            /// External trigger valid edge Clear
            /// Flag
            EXTTRIGCF: u1,
            /// Compare register update OK Clear
            /// Flag
            CMPOKCF: u1,
            /// Autoreload register update OK Clear
            /// Flag
            ARROKCF: u1,
            /// Direction change to UP Clear
            /// Flag
            UPCF: u1,
            /// Direction change to down Clear
            /// Flag
            DOWNCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40002408
        /// Interrupt Enable Register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match Interrupt
            /// Enable
            CMPMIE: u1,
            /// Autoreload match Interrupt
            /// Enable
            ARRMIE: u1,
            /// External trigger valid edge Interrupt
            /// Enable
            EXTTRIGIE: u1,
            /// Compare register update OK Interrupt
            /// Enable
            CMPOKIE: u1,
            /// Autoreload register update OK Interrupt
            /// Enable
            ARROKIE: u1,
            /// Direction change to UP Interrupt
            /// Enable
            UPIE: u1,
            /// Direction change to down Interrupt
            /// Enable
            DOWNIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x8);

        /// address: 0x4000240c
        /// Configuration Register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock selector
            CKSEL: u1,
            /// Clock Polarity
            CKPOL: u2,
            /// Configurable digital filter for external
            /// clock
            CKFLT: u2,
            reserved0: u1,
            /// Configurable digital filter for
            /// trigger
            TRGFLT: u2,
            reserved1: u1,
            /// Clock prescaler
            PRESC: u3,
            reserved2: u1,
            /// Trigger selector
            TRIGSEL: u3,
            reserved3: u1,
            /// Trigger enable and
            /// polarity
            TRIGEN: u2,
            /// Timeout enable
            TIMOUT: u1,
            /// Waveform shape
            WAVE: u1,
            /// Waveform shape polarity
            WAVPOL: u1,
            /// Registers update mode
            PRELOAD: u1,
            /// counter mode enabled
            COUNTMODE: u1,
            /// Encoder mode enable
            ENC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);

        /// address: 0x40002410
        /// Control Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPTIM Enable
            ENABLE: u1,
            /// LPTIM start in single mode
            SNGSTRT: u1,
            /// Timer start in continuous
            /// mode
            CNTSTRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x10);

        /// address: 0x40002414
        /// Compare Register
        pub const CMP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40002418
        /// Autoreload Register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x4000241c
        /// Counter Register
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);
    };

    /// Inter-integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005414
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005424
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005428
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C3 = struct {
        pub const base_address = 0x40005c00;

        /// address: 0x40005c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005c08
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40005c0c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005c10
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005c14
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005c18
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x40005c1c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005c20
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005c24
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005c28
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C4 = struct {
        pub const base_address = 0x40006000;

        /// address: 0x40006000
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40006004
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40006008
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000600c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40006010
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40006014
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40006018
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000601c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40006020
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40006024
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40006028
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };

    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// time register
        pub const TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// date register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            /// Year units in BCD format
            YU: u4,
            /// Year tens in BCD format
            YT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup clock selection
            WCKSEL: u3,
            /// Time-stamp event active
            /// edge
            TSEDGE: u1,
            /// Reference clock detection enable (50 or
            /// 60 Hz)
            REFCKON: u1,
            /// Bypass the shadow
            /// registers
            BYPSHAD: u1,
            /// Hour format
            FMT: u1,
            reserved0: u1,
            /// Alarm A enable
            ALRAE: u1,
            /// Alarm B enable
            ALRBE: u1,
            /// Wakeup timer enable
            WUTE: u1,
            /// Time stamp enable
            TSE: u1,
            /// Alarm A interrupt enable
            ALRAIE: u1,
            /// Alarm B interrupt enable
            ALRBIE: u1,
            /// Wakeup timer interrupt
            /// enable
            WUTIE: u1,
            /// Time-stamp interrupt
            /// enable
            TSIE: u1,
            /// Add 1 hour (summer time
            /// change)
            ADD1H: u1,
            /// Subtract 1 hour (winter time
            /// change)
            SUB1H: u1,
            /// Backup
            BKP: u1,
            /// Calibration output
            /// selection
            COSEL: u1,
            /// Output polarity
            POL: u1,
            /// Output selection
            OSEL: u2,
            /// Calibration output enable
            COE: u1,
            /// timestamp on internal event
            /// enable
            ITSE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// initialization and status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm A write flag
            ALRAWF: u1,
            /// Alarm B write flag
            ALRBWF: u1,
            /// Wakeup timer write flag
            WUTWF: u1,
            /// Shift operation pending
            SHPF: u1,
            /// Initialization status flag
            INITS: u1,
            /// Registers synchronization
            /// flag
            RSF: u1,
            /// Initialization flag
            INITF: u1,
            /// Initialization mode
            INIT: u1,
            /// Alarm A flag
            ALRAF: u1,
            /// Alarm B flag
            ALRBF: u1,
            /// Wakeup timer flag
            WUTF: u1,
            /// Time-stamp flag
            TSF: u1,
            /// Time-stamp overflow flag
            TSOVF: u1,
            /// Tamper detection flag
            TAMP1F: u1,
            /// RTC_TAMP2 detection flag
            TAMP2F: u1,
            /// RTC_TAMP3 detection flag
            TAMP3F: u1,
            /// Recalibration pending Flag
            RECALPF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// prescaler register
        pub const PRER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous prescaler
            /// factor
            PREDIV_S: u15,
            reserved0: u1,
            /// Asynchronous prescaler
            /// factor
            PREDIV_A: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// wakeup timer register
        pub const WUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup auto-reload value
            /// bits
            WUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4000281c
        /// alarm A register
        pub const ALRMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm A seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm A minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm A hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm A date mask
            MSK4: u1,
        }), base_address + 0x1c);

        /// address: 0x40002820
        /// alarm B register
        pub const ALRMBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm B seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm B minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm B hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm B date mask
            MSK4: u1,
        }), base_address + 0x20);

        /// address: 0x40002824
        /// write protection register
        pub const WPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protection key
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40002828
        /// sub second register
        pub const SSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000282c
        /// shift control register
        pub const SHIFTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Subtract a fraction of a
            /// second
            SUBFS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Add one second
            ADD1S: u1,
        }), base_address + 0x2c);

        /// address: 0x40002830
        /// time stamp time register
        pub const TSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x30);

        /// address: 0x40002834
        /// time stamp date register
        pub const TSDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40002838
        /// timestamp sub second register
        pub const TSSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x4000283c
        /// calibration register
        pub const CALR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration minus
            CALM: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Use a 16-second calibration cycle
            /// period
            CALW16: u1,
            /// Use an 8-second calibration cycle
            /// period
            CALW8: u1,
            /// Increase frequency of RTC by 488.5
            /// ppm
            CALP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40002840
        /// tamper configuration register
        pub const TAMPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tamper 1 detection enable
            TAMP1E: u1,
            /// Active level for tamper 1
            TAMP1TRG: u1,
            /// Tamper interrupt enable
            TAMPIE: u1,
            /// Tamper 2 detection enable
            TAMP2E: u1,
            /// Active level for tamper 2
            TAMP2TRG: u1,
            /// Tamper 3 detection enable
            TAMP3E: u1,
            /// Active level for tamper 3
            TAMP3TRG: u1,
            /// Activate timestamp on tamper detection
            /// event
            TAMPTS: u1,
            /// Tamper sampling frequency
            TAMPFREQ: u3,
            /// Tamper filter count
            TAMPFLT: u2,
            /// Tamper precharge duration
            TAMPPRCH: u2,
            /// TAMPER pull-up disable
            TAMPPUDIS: u1,
            /// Tamper 1 interrupt enable
            TAMP1IE: u1,
            /// Tamper 1 no erase
            TAMP1NOERASE: u1,
            /// Tamper 1 mask flag
            TAMP1MF: u1,
            /// Tamper 2 interrupt enable
            TAMP2IE: u1,
            /// Tamper 2 no erase
            TAMP2NOERASE: u1,
            /// Tamper 2 mask flag
            TAMP2MF: u1,
            /// Tamper 3 interrupt enable
            TAMP3IE: u1,
            /// Tamper 3 no erase
            TAMP3NOERASE: u1,
            /// Tamper 3 mask flag
            TAMP3MF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x40);

        /// address: 0x40002844
        /// alarm A sub second register
        pub const ALRMASSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x44);

        /// address: 0x40002848
        /// alarm B sub second register
        pub const ALRMBSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x48);

        /// address: 0x4000284c
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC_ALARM on PC13 output
            /// type
            RTC_ALARM_TYPE: u1,
            /// RTC_OUT remap
            RTC_OUT_RMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4c);

        /// address: 0x40002850
        /// backup register
        pub const BKP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x50);

        /// address: 0x40002854
        /// backup register
        pub const BKP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x54);

        /// address: 0x40002858
        /// backup register
        pub const BKP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x58);

        /// address: 0x4000285c
        /// backup register
        pub const BKP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x5c);

        /// address: 0x40002860
        /// backup register
        pub const BKP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x60);

        /// address: 0x40002864
        /// backup register
        pub const BKP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x64);

        /// address: 0x40002868
        /// backup register
        pub const BKP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x68);

        /// address: 0x4000286c
        /// backup register
        pub const BKP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x6c);

        /// address: 0x40002870
        /// backup register
        pub const BKP8R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x70);

        /// address: 0x40002874
        /// backup register
        pub const BKP9R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x74);

        /// address: 0x40002878
        /// backup register
        pub const BKP10R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x78);

        /// address: 0x4000287c
        /// backup register
        pub const BKP11R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x7c);

        /// address: 0x40002880
        /// backup register
        pub const BKP12R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x80);

        /// address: 0x40002884
        /// backup register
        pub const BKP13R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x84);

        /// address: 0x40002888
        /// backup register
        pub const BKP14R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x88);

        /// address: 0x4000288c
        /// backup register
        pub const BKP15R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x8c);

        /// address: 0x40002890
        /// backup register
        pub const BKP16R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x90);

        /// address: 0x40002894
        /// backup register
        pub const BKP17R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x94);

        /// address: 0x40002898
        /// backup register
        pub const BKP18R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x98);

        /// address: 0x4000289c
        /// backup register
        pub const BKP19R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x9c);

        /// address: 0x400028a0
        /// backup register
        pub const BKP20R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa0);

        /// address: 0x400028a4
        /// backup register
        pub const BKP21R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa4);

        /// address: 0x400028a8
        /// backup register
        pub const BKP22R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa8);

        /// address: 0x400028ac
        /// backup register
        pub const BKP23R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xac);

        /// address: 0x400028b0
        /// backup register
        pub const BKP24R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb0);

        /// address: 0x400028b4
        /// backup register
        pub const BKP25R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb4);

        /// address: 0x400028b8
        /// backup register
        pub const BKP26R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb8);

        /// address: 0x400028bc
        /// backup register
        pub const BKP27R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xbc);

        /// address: 0x400028c0
        /// backup register
        pub const BKP28R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc0);

        /// address: 0x400028c4
        /// backup register
        pub const BKP29R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc4);

        /// address: 0x400028c8
        /// backup register
        pub const BKP30R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc8);

        /// address: 0x400028cc
        /// backup register
        pub const BKP31R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xcc);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART6 = struct {
        pub const base_address = 0x40011400;

        /// address: 0x40011400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40011404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40011408
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001140c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011410
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40011414
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40011418
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4001141c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40011420
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40011424
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40011428
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART1 = struct {
        pub const base_address = 0x40011000;

        /// address: 0x40011000
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40011004
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40011008
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001100c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011010
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40011014
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40011018
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4001101c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40011020
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40011024
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40011028
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART3 = struct {
        pub const base_address = 0x40004800;

        /// address: 0x40004800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000480c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000481c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004408
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000441c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004420
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004424
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004428
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART5 = struct {
        pub const base_address = 0x40005000;

        /// address: 0x40005000
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40005004
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40005008
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000500c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005010
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40005014
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40005018
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000501c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40005020
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40005024
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40005028
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART4 = struct {
        pub const base_address = 0x40004c00;

        /// address: 0x40004c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004c08
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x40004c0c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004c10
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004c14
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004c18
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x40004c1c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004c20
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004c24
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004c28
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART8 = struct {
        pub const base_address = 0x40007c00;

        /// address: 0x40007c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40007c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40007c08
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x40007c0c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007c10
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40007c14
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40007c18
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x40007c1c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40007c20
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40007c24
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40007c28
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART7 = struct {
        pub const base_address = 0x40007800;

        /// address: 0x40007800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40007804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40007808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000780c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40007814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40007818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000781c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40007820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40007824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40007828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };

    /// USB on the go full speed
    pub const OTG_FS_GLOBAL = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// OTG_FS control and status register
        /// (OTG_FS_GOTGCTL)
        pub const OTG_FS_GOTGCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Session request success
            SRQSCS: u1,
            /// Session request
            SRQ: u1,
            /// VBUS valid override enable
            VBVALOEN: u1,
            /// VBUS valid override value
            VBVALOVAL: u1,
            /// A-peripheral session valid override
            /// enable
            AVALOEN: u1,
            /// A-peripheral session valid override
            /// value
            AVALOVAL: u1,
            /// B-peripheral session valid override
            /// enable
            BVALOEN: u1,
            /// B-peripheral session valid override
            /// value
            BVALOVAL: u1,
            /// Host negotiation success
            HNGSCS: u1,
            /// HNP request
            HNPRQ: u1,
            /// Host set HNP enable
            HSHNPEN: u1,
            /// Device HNP enabled
            DHNPEN: u1,
            /// Embedded host enable
            EHEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Connector ID status
            CIDSTS: u1,
            /// Long/short debounce time
            DBCT: u1,
            /// A-session valid
            ASVLD: u1,
            /// B-session valid
            BSVLD: u1,
            /// OTG version
            OTGVER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x0);

        /// address: 0x50000004
        /// OTG_FS interrupt register
        /// (OTG_FS_GOTGINT)
        pub const OTG_FS_GOTGINT = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Session end detected
            SEDET: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Session request success status
            /// change
            SRSSCHG: u1,
            /// Host negotiation success status
            /// change
            HNSSCHG: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Host negotiation detected
            HNGDET: u1,
            /// A-device timeout change
            ADTOCHG: u1,
            /// Debounce done
            DBCDNE: u1,
            /// ID input pin changed
            IDCHNG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x4);

        /// address: 0x50000008
        /// OTG_FS AHB configuration register
        /// (OTG_FS_GAHBCFG)
        pub const OTG_FS_GAHBCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global interrupt mask
            GINT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TxFIFO empty level
            TXFELVL: u1,
            /// Periodic TxFIFO empty
            /// level
            PTXFELVL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x5000000c
        /// OTG_FS USB configuration register
        /// (OTG_FS_GUSBCFG)
        pub const OTG_FS_GUSBCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FS timeout calibration
            TOCAL: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Full Speed serial transceiver
            /// select
            PHYSEL: u1,
            reserved3: u1,
            /// SRP-capable
            SRPCAP: u1,
            /// HNP-capable
            HNPCAP: u1,
            /// USB turnaround time
            TRDT: u4,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Force host mode
            FHMOD: u1,
            /// Force device mode
            FDMOD: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x50000010
        /// OTG_FS reset register
        /// (OTG_FS_GRSTCTL)
        pub const OTG_FS_GRSTCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Core soft reset
            CSRST: u1,
            /// HCLK soft reset
            HSRST: u1,
            /// Host frame counter reset
            FCRST: u1,
            reserved0: u1,
            /// RxFIFO flush
            RXFFLSH: u1,
            /// TxFIFO flush
            TXFFLSH: u1,
            /// TxFIFO number
            TXFNUM: u5,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// AHB master idle
            AHBIDL: u1,
        }), base_address + 0x10);

        /// address: 0x50000014
        /// OTG_FS core interrupt register
        /// (OTG_FS_GINTSTS)
        pub const OTG_FS_GINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current mode of operation
            CMOD: u1,
            /// Mode mismatch interrupt
            MMIS: u1,
            /// OTG interrupt
            OTGINT: u1,
            /// Start of frame
            SOF: u1,
            /// RxFIFO non-empty
            RXFLVL: u1,
            /// Non-periodic TxFIFO empty
            NPTXFE: u1,
            /// Global IN non-periodic NAK
            /// effective
            GINAKEFF: u1,
            /// Global OUT NAK effective
            GOUTNAKEFF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Early suspend
            ESUSP: u1,
            /// USB suspend
            USBSUSP: u1,
            /// USB reset
            USBRST: u1,
            /// Enumeration done
            ENUMDNE: u1,
            /// Isochronous OUT packet dropped
            /// interrupt
            ISOODRP: u1,
            /// End of periodic frame
            /// interrupt
            EOPF: u1,
            reserved2: u1,
            reserved3: u1,
            /// IN endpoint interrupt
            IEPINT: u1,
            /// OUT endpoint interrupt
            OEPINT: u1,
            /// Incomplete isochronous IN
            /// transfer
            IISOIXFR: u1,
            /// Incomplete periodic transfer(Host
            /// mode)/Incomplete isochronous OUT transfer(Device
            /// mode)
            IPXFR_INCOMPISOOUT: u1,
            reserved4: u1,
            /// Reset detected interrupt
            RSTDET: u1,
            /// Host port interrupt
            HPRTINT: u1,
            /// Host channels interrupt
            HCINT: u1,
            /// Periodic TxFIFO empty
            PTXFE: u1,
            reserved5: u1,
            /// Connector ID status change
            CIDSCHG: u1,
            /// Disconnect detected
            /// interrupt
            DISCINT: u1,
            /// Session request/new session detected
            /// interrupt
            SRQINT: u1,
            /// Resume/remote wakeup detected
            /// interrupt
            WKUPINT: u1,
        }), base_address + 0x14);

        /// address: 0x50000018
        /// OTG_FS interrupt mask register
        /// (OTG_FS_GINTMSK)
        pub const OTG_FS_GINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Mode mismatch interrupt
            /// mask
            MMISM: u1,
            /// OTG interrupt mask
            OTGINT: u1,
            /// Start of frame mask
            SOFM: u1,
            /// Receive FIFO non-empty
            /// mask
            RXFLVLM: u1,
            /// Non-periodic TxFIFO empty
            /// mask
            NPTXFEM: u1,
            /// Global non-periodic IN NAK effective
            /// mask
            GINAKEFFM: u1,
            /// Global OUT NAK effective
            /// mask
            GONAKEFFM: u1,
            reserved1: u1,
            reserved2: u1,
            /// Early suspend mask
            ESUSPM: u1,
            /// USB suspend mask
            USBSUSPM: u1,
            /// USB reset mask
            USBRST: u1,
            /// Enumeration done mask
            ENUMDNEM: u1,
            /// Isochronous OUT packet dropped interrupt
            /// mask
            ISOODRPM: u1,
            /// End of periodic frame interrupt
            /// mask
            EOPFM: u1,
            reserved3: u1,
            reserved4: u1,
            /// IN endpoints interrupt
            /// mask
            IEPINT: u1,
            /// OUT endpoints interrupt
            /// mask
            OEPINT: u1,
            /// Incomplete isochronous IN transfer
            /// mask
            IISOIXFRM: u1,
            /// Incomplete periodic transfer mask(Host
            /// mode)/Incomplete isochronous OUT transfer mask(Device
            /// mode)
            IPXFRM_IISOOXFRM: u1,
            reserved5: u1,
            /// Reset detected interrupt
            /// mask
            RSTDETM: u1,
            /// Host port interrupt mask
            PRTIM: u1,
            /// Host channels interrupt
            /// mask
            HCIM: u1,
            /// Periodic TxFIFO empty mask
            PTXFEM: u1,
            /// LPM interrupt mask
            LPMIN: u1,
            /// Connector ID status change
            /// mask
            CIDSCHGM: u1,
            /// Disconnect detected interrupt
            /// mask
            DISCINT: u1,
            /// Session request/new session detected
            /// interrupt mask
            SRQIM: u1,
            /// Resume/remote wakeup detected interrupt
            /// mask
            WUIM: u1,
        }), base_address + 0x18);

        /// address: 0x5000001c
        /// OTG_FS Receive status debug read(Device
        /// mode)
        pub const OTG_FS_GRXSTSR_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            EPNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            /// Frame number
            FRMNUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x5000001c
        /// OTG_FS Receive status debug read(Host
        /// mode)
        pub const OTG_FS_GRXSTSR_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            CHNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x1c);

        /// address: 0x50000024
        /// OTG_FS Receive FIFO size register
        /// (OTG_FS_GRXFSIZ)
        pub const OTG_FS_GRXFSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// RxFIFO depth
            RXFD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x50000028
        /// OTG_FS Endpoint 0 Transmit FIFO
        /// size
        pub const OTG_FS_DIEPTXF0_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint 0 transmit RAM start
            /// address
            TX0FSA: u16,
            /// Endpoint 0 TxFIFO depth
            TX0FD: u16,
        }), base_address + 0x28);

        /// address: 0x50000028
        /// OTG_FS Host non-periodic transmit FIFO size
        /// register
        pub const OTG_FS_HNPTXFSIZ_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-periodic transmit RAM start
            /// address
            NPTXFSA: u16,
            /// Non-periodic TxFIFO depth
            NPTXFD: u16,
        }), base_address + 0x28);

        /// address: 0x5000002c
        /// OTG_FS non-periodic transmit FIFO/queue
        /// status register (OTG_FS_GNPTXSTS)
        pub const OTG_FS_HNPTXSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-periodic TxFIFO space
            /// available
            NPTXFSAV: u16,
            /// Non-periodic transmit request queue
            /// space available
            NPTQXSAV: u8,
            /// Top of the non-periodic transmit request
            /// queue
            NPTXQTOP: u7,
            padding0: u1,
        }), base_address + 0x2c);

        /// address: 0x50000038
        /// OTG_FS general core configuration register
        /// (OTG_FS_GCCFG)
        pub const OTG_FS_GCCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data contact detection (DCD)
            /// status
            DCDET: u1,
            /// Primary detection (PD)
            /// status
            PDET: u1,
            /// Secondary detection (SD)
            /// status
            SDET: u1,
            /// DM pull-up detection
            /// status
            PS2DET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Power down
            PWRDWN: u1,
            /// Battery charging detector (BCD)
            /// enable
            BCDEN: u1,
            /// Data contact detection (DCD) mode
            /// enable
            DCDEN: u1,
            /// Primary detection (PD) mode
            /// enable
            PDEN: u1,
            /// Secondary detection (SD) mode
            /// enable
            SDEN: u1,
            /// USB VBUS detection enable
            VBDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x5000003c
        /// core ID register
        pub const OTG_FS_CID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Product ID field
            PRODUCT_ID: u32,
        }), base_address + 0x3c);

        /// address: 0x50000100
        /// OTG_FS Host periodic transmit FIFO size
        /// register (OTG_FS_HPTXFSIZ)
        pub const OTG_FS_HPTXFSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host periodic TxFIFO start
            /// address
            PTXSA: u16,
            /// Host periodic TxFIFO depth
            PTXFSIZ: u16,
        }), base_address + 0x100);

        /// address: 0x50000104
        /// OTG_FS device IN endpoint transmit FIFO size
        /// register (OTG_FS_DIEPTXF1)
        pub const OTG_FS_DIEPTXF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFO2 transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x104);

        /// address: 0x50000108
        /// OTG_FS device IN endpoint transmit FIFO size
        /// register (OTG_FS_DIEPTXF2)
        pub const OTG_FS_DIEPTXF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFO3 transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x108);

        /// address: 0x5000010c
        /// OTG_FS device IN endpoint transmit FIFO size
        /// register (OTG_FS_DIEPTXF3)
        pub const OTG_FS_DIEPTXF3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFO4 transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x10c);

        /// address: 0x50000020
        /// OTG status read and pop register (Device
        /// mode)
        pub const OTG_FS_GRXSTSP_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            EPNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            /// Frame number
            FRMNUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x20);

        /// address: 0x50000020
        /// OTG status read and pop register (Host
        /// mode)
        pub const OTG_FS_GRXSTSP_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel number
            CHNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x50000030
        /// OTG I2C access register
        pub const OTG_FS_GI2CCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2C Read/Write Data
            RWDATA: u8,
            /// I2C Register Address
            REGADDR: u8,
            /// I2C Address
            ADDR: u7,
            /// I2C Enable
            I2CEN: u1,
            /// I2C ACK
            ACK: u1,
            reserved0: u1,
            /// I2C Device Address
            I2CDEVADR: u2,
            /// I2C DatSe0 USB mode
            I2CDATSE0: u1,
            reserved1: u1,
            /// Read/Write Indicator
            RW: u1,
            /// I2C Busy/Done
            BSYDNE: u1,
        }), base_address + 0x30);

        /// address: 0x50000058
        /// OTG power down register
        pub const OTG_FS_GPWRDN = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADP module enable
            ADPMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADP interrupt flag
            ADPIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x58);

        /// address: 0x50000060
        /// OTG ADP timer, control and status
        /// register
        pub const OTG_FS_GADPCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Probe discharge
            PRBDSCHG: u2,
            /// Probe delta
            PRBDELTA: u2,
            /// Probe period
            PRBPER: u2,
            /// Ramp time
            RTIM: u11,
            /// Enable probe
            ENAPRB: u1,
            /// Enable sense
            ENASNS: u1,
            /// ADP reset
            ADPRST: u1,
            /// ADP enable
            ADPEN: u1,
            /// ADP probe interrupt flag
            ADPPRBIF: u1,
            /// ADP sense interrupt flag
            ADPSNSIF: u1,
            /// ADP timeout interrupt flag
            ADPTOIF: u1,
            /// ADP probe interrupt mask
            ADPPRBIM: u1,
            /// ADP sense interrupt mask
            ADPSNSIM: u1,
            /// ADP timeout interrupt mask
            ADPTOIM: u1,
            /// Access request
            AR: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x60);

        /// address: 0x50000110
        /// OTG_FS device IN endpoint transmit FIFO size
        /// register (OTG_FS_DIEPTXF4)
        pub const OTG_FS_DIEPTXF4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint Tx FIFO depth
            INEPTXFD: u16,
        }), base_address + 0x110);

        /// address: 0x50000114
        /// OTG_FS device IN endpoint transmit FIFO size
        /// register (OTG_FS_DIEPTXF5)
        pub const OTG_FS_DIEPTXF5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint Tx FIFO depth
            INEPTXFD: u16,
        }), base_address + 0x114);

        /// address: 0x50000054
        /// OTG core LPM configuration
        /// register
        pub const OTG_FS_GLPMCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPM support enable
            LPMEN: u1,
            /// LPM token acknowledge
            /// enable
            LPMACK: u1,
            /// Best effort service
            /// latency
            BESL: u4,
            /// bRemoteWake value
            REMWAKE: u1,
            /// L1 Shallow Sleep enable
            L1SSEN: u1,
            /// BESL threshold
            BESLTHRS: u4,
            /// L1 deep sleep enable
            L1DSEN: u1,
            /// LPM response
            LPMRST: u2,
            /// Port sleep status
            SLPSTS: u1,
            /// Sleep State Resume OK
            L1RSMOK: u1,
            /// LPM Channel Index
            LPMCHIDX: u4,
            /// LPM retry count
            LPMRCNT: u3,
            /// Send LPM transaction
            SNDLPM: u1,
            /// LPM retry count status
            LPMRCNTSTS: u3,
            /// Enable best effort service
            /// latency
            ENBESL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x54);
    };

    /// USB on the go high speed
    pub const OTG_HS_GLOBAL = struct {
        pub const base_address = 0x40040000;

        /// address: 0x40040000
        /// OTG_HS control and status
        /// register
        pub const OTG_HS_GOTGCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Session request success
            SRQSCS: u1,
            /// Session request
            SRQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Host negotiation success
            HNGSCS: u1,
            /// HNP request
            HNPRQ: u1,
            /// Host set HNP enable
            HSHNPEN: u1,
            /// Device HNP enabled
            DHNPEN: u1,
            /// Embedded host enable
            EHEN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Connector ID status
            CIDSTS: u1,
            /// Long/short debounce time
            DBCT: u1,
            /// A-session valid
            ASVLD: u1,
            /// B-session valid
            BSVLD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x40040004
        /// OTG_HS interrupt register
        pub const OTG_HS_GOTGINT = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Session end detected
            SEDET: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Session request success status
            /// change
            SRSSCHG: u1,
            /// Host negotiation success status
            /// change
            HNSSCHG: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Host negotiation detected
            HNGDET: u1,
            /// A-device timeout change
            ADTOCHG: u1,
            /// Debounce done
            DBCDNE: u1,
            /// ID input pin changed
            IDCHNG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x4);

        /// address: 0x40040008
        /// OTG_HS AHB configuration
        /// register
        pub const OTG_HS_GAHBCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global interrupt mask
            GINT: u1,
            /// Burst length/type
            HBSTLEN: u4,
            /// DMA enable
            DMAEN: u1,
            reserved0: u1,
            /// TxFIFO empty level
            TXFELVL: u1,
            /// Periodic TxFIFO empty
            /// level
            PTXFELVL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x4004000c
        /// OTG_HS USB configuration
        /// register
        pub const OTG_HS_GUSBCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FS timeout calibration
            TOCAL: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// USB 2.0 high-speed ULPI PHY or USB 1.1
            /// full-speed serial transceiver select
            PHYSEL: u1,
            reserved3: u1,
            /// SRP-capable
            SRPCAP: u1,
            /// HNP-capable
            HNPCAP: u1,
            /// USB turnaround time
            TRDT: u4,
            reserved4: u1,
            /// PHY Low-power clock select
            PHYLPCS: u1,
            reserved5: u1,
            /// ULPI FS/LS select
            ULPIFSLS: u1,
            /// ULPI Auto-resume
            ULPIAR: u1,
            /// ULPI Clock SuspendM
            ULPICSM: u1,
            /// ULPI External VBUS Drive
            ULPIEVBUSD: u1,
            /// ULPI external VBUS
            /// indicator
            ULPIEVBUSI: u1,
            /// TermSel DLine pulsing
            /// selection
            TSDPS: u1,
            /// Indicator complement
            PCCI: u1,
            /// Indicator pass through
            PTCI: u1,
            /// ULPI interface protect
            /// disable
            ULPIIPD: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Forced host mode
            FHMOD: u1,
            /// Forced peripheral mode
            FDMOD: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40040010
        /// OTG_HS reset register
        pub const OTG_HS_GRSTCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Core soft reset
            CSRST: u1,
            /// HCLK soft reset
            HSRST: u1,
            /// Host frame counter reset
            FCRST: u1,
            reserved0: u1,
            /// RxFIFO flush
            RXFFLSH: u1,
            /// TxFIFO flush
            TXFFLSH: u1,
            /// TxFIFO number
            TXFNUM: u5,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// DMA request signal enabled for USB OTG
            /// HS
            DMAREQ: u1,
            /// AHB master idle
            AHBIDL: u1,
        }), base_address + 0x10);

        /// address: 0x40040014
        /// OTG_HS core interrupt register
        pub const OTG_HS_GINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current mode of operation
            CMOD: u1,
            /// Mode mismatch interrupt
            MMIS: u1,
            /// OTG interrupt
            OTGINT: u1,
            /// Start of frame
            SOF: u1,
            /// RxFIFO nonempty
            RXFLVL: u1,
            /// Nonperiodic TxFIFO empty
            NPTXFE: u1,
            /// Global IN nonperiodic NAK
            /// effective
            GINAKEFF: u1,
            /// Global OUT NAK effective
            BOUTNAKEFF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Early suspend
            ESUSP: u1,
            /// USB suspend
            USBSUSP: u1,
            /// USB reset
            USBRST: u1,
            /// Enumeration done
            ENUMDNE: u1,
            /// Isochronous OUT packet dropped
            /// interrupt
            ISOODRP: u1,
            /// End of periodic frame
            /// interrupt
            EOPF: u1,
            reserved2: u1,
            reserved3: u1,
            /// IN endpoint interrupt
            IEPINT: u1,
            /// OUT endpoint interrupt
            OEPINT: u1,
            /// Incomplete isochronous IN
            /// transfer
            IISOIXFR: u1,
            /// Incomplete periodic
            /// transfer
            PXFR_INCOMPISOOUT: u1,
            /// Data fetch suspended
            DATAFSUSP: u1,
            reserved4: u1,
            /// Host port interrupt
            HPRTINT: u1,
            /// Host channels interrupt
            HCINT: u1,
            /// Periodic TxFIFO empty
            PTXFE: u1,
            reserved5: u1,
            /// Connector ID status change
            CIDSCHG: u1,
            /// Disconnect detected
            /// interrupt
            DISCINT: u1,
            /// Session request/new session detected
            /// interrupt
            SRQINT: u1,
            /// Resume/remote wakeup detected
            /// interrupt
            WKUINT: u1,
        }), base_address + 0x14);

        /// address: 0x40040018
        /// OTG_HS interrupt mask register
        pub const OTG_HS_GINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Mode mismatch interrupt
            /// mask
            MMISM: u1,
            /// OTG interrupt mask
            OTGINT: u1,
            /// Start of frame mask
            SOFM: u1,
            /// Receive FIFO nonempty mask
            RXFLVLM: u1,
            /// Nonperiodic TxFIFO empty
            /// mask
            NPTXFEM: u1,
            /// Global nonperiodic IN NAK effective
            /// mask
            GINAKEFFM: u1,
            /// Global OUT NAK effective
            /// mask
            GONAKEFFM: u1,
            reserved1: u1,
            reserved2: u1,
            /// Early suspend mask
            ESUSPM: u1,
            /// USB suspend mask
            USBSUSPM: u1,
            /// USB reset mask
            USBRST: u1,
            /// Enumeration done mask
            ENUMDNEM: u1,
            /// Isochronous OUT packet dropped interrupt
            /// mask
            ISOODRPM: u1,
            /// End of periodic frame interrupt
            /// mask
            EOPFM: u1,
            reserved3: u1,
            reserved4: u1,
            /// IN endpoints interrupt
            /// mask
            IEPINT: u1,
            /// OUT endpoints interrupt
            /// mask
            OEPINT: u1,
            /// Incomplete isochronous IN transfer
            /// mask
            IISOIXFRM: u1,
            /// Incomplete periodic transfer
            /// mask
            PXFRM_IISOOXFRM: u1,
            /// Data fetch suspended mask
            FSUSPM: u1,
            /// Reset detected interrupt
            /// mask
            RSTDE: u1,
            /// Host port interrupt mask
            PRTIM: u1,
            /// Host channels interrupt
            /// mask
            HCIM: u1,
            /// Periodic TxFIFO empty mask
            PTXFEM: u1,
            /// LPM interrupt mask
            LPMINTM: u1,
            /// Connector ID status change
            /// mask
            CIDSCHGM: u1,
            /// Disconnect detected interrupt
            /// mask
            DISCINT: u1,
            /// Session request/new session detected
            /// interrupt mask
            SRQIM: u1,
            /// Resume/remote wakeup detected interrupt
            /// mask
            WUIM: u1,
        }), base_address + 0x18);

        /// address: 0x4004001c
        /// OTG_HS Receive status debug read register
        /// (host mode)
        pub const OTG_HS_GRXSTSR_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel number
            CHNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x1c);

        /// address: 0x40040020
        /// OTG_HS status read and pop register (host
        /// mode)
        pub const OTG_HS_GRXSTSP_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel number
            CHNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40040024
        /// OTG_HS Receive FIFO size
        /// register
        pub const OTG_HS_GRXFSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// RxFIFO depth
            RXFD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x40040028
        /// OTG_HS nonperiodic transmit FIFO size
        /// register (host mode)
        pub const OTG_HS_HNPTXFSIZ_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Nonperiodic transmit RAM start
            /// address
            NPTXFSA: u16,
            /// Nonperiodic TxFIFO depth
            NPTXFD: u16,
        }), base_address + 0x28);

        /// address: 0x40040028
        /// Endpoint 0 transmit FIFO size (peripheral
        /// mode)
        pub const OTG_HS_DIEPTXF0_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint 0 transmit RAM start
            /// address
            TX0FSA: u16,
            /// Endpoint 0 TxFIFO depth
            TX0FD: u16,
        }), base_address + 0x28);

        /// address: 0x4004002c
        /// OTG_HS nonperiodic transmit FIFO/queue
        /// status register
        pub const OTG_HS_GNPTXSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Nonperiodic TxFIFO space
            /// available
            NPTXFSAV: u16,
            /// Nonperiodic transmit request queue space
            /// available
            NPTQXSAV: u8,
            /// Top of the nonperiodic transmit request
            /// queue
            NPTXQTOP: u7,
            padding0: u1,
        }), base_address + 0x2c);

        /// address: 0x40040038
        /// OTG_HS general core configuration
        /// register
        pub const OTG_HS_GCCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data contact detection (DCD)
            /// status
            DCDET: u1,
            /// Primary detection (PD)
            /// status
            PDET: u1,
            /// Secondary detection (SD)
            /// status
            SDET: u1,
            /// DM pull-up detection
            /// status
            PS2DET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Power down
            PWRDWN: u1,
            /// Battery charging detector (BCD)
            /// enable
            BCDEN: u1,
            /// Data contact detection (DCD) mode
            /// enable
            DCDEN: u1,
            /// Primary detection (PD) mode
            /// enable
            PDEN: u1,
            /// Secondary detection (SD) mode
            /// enable
            SDEN: u1,
            /// USB VBUS detection enable
            VBDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4004003c
        /// OTG_HS core ID register
        pub const OTG_HS_CID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Product ID field
            PRODUCT_ID: u32,
        }), base_address + 0x3c);

        /// address: 0x40040100
        /// OTG_HS Host periodic transmit FIFO size
        /// register
        pub const OTG_HS_HPTXFSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host periodic TxFIFO start
            /// address
            PTXSA: u16,
            /// Host periodic TxFIFO depth
            PTXFD: u16,
        }), base_address + 0x100);

        /// address: 0x40040104
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x104);

        /// address: 0x40040108
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x108);

        /// address: 0x4004011c
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x11c);

        /// address: 0x40040120
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x120);

        /// address: 0x40040124
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x124);

        /// address: 0x40040128
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x128);

        /// address: 0x4004012c
        /// OTG_HS device IN endpoint transmit FIFO size
        /// register
        pub const OTG_HS_DIEPTXF7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFOx transmit RAM start
            /// address
            INEPTXSA: u16,
            /// IN endpoint TxFIFO depth
            INEPTXFD: u16,
        }), base_address + 0x12c);

        /// address: 0x4004001c
        /// OTG_HS Receive status debug read register
        /// (peripheral mode mode)
        pub const OTG_HS_GRXSTSR_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            EPNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            /// Frame number
            FRMNUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x40040020
        /// OTG_HS status read and pop register
        /// (peripheral mode)
        pub const OTG_HS_GRXSTSP_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            EPNUM: u4,
            /// Byte count
            BCNT: u11,
            /// Data PID
            DPID: u2,
            /// Packet status
            PKTSTS: u4,
            /// Frame number
            FRMNUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x20);

        /// address: 0x40040054
        /// OTG core LPM configuration
        /// register
        pub const OTG_HS_GLPMCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPM support enable
            LPMEN: u1,
            /// LPM token acknowledge
            /// enable
            LPMACK: u1,
            /// Best effort service
            /// latency
            BESL: u4,
            /// bRemoteWake value
            REMWAKE: u1,
            /// L1 Shallow Sleep enable
            L1SSEN: u1,
            /// BESL threshold
            BESLTHRS: u4,
            /// L1 deep sleep enable
            L1DSEN: u1,
            /// LPM response
            LPMRST: u2,
            /// Port sleep status
            SLPSTS: u1,
            /// Sleep State Resume OK
            L1RSMOK: u1,
            /// LPM Channel Index
            LPMCHIDX: u4,
            /// LPM retry count
            LPMRCNT: u3,
            /// Send LPM transaction
            SNDLPM: u1,
            /// LPM retry count status
            LPMRCNTSTS: u3,
            /// Enable best effort service
            /// latency
            ENBESL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x54);
    };

    /// Management data input/output slave
    pub const MDIOS = struct {
        pub const base_address = 0x40017800;

        /// address: 0x40017800
        /// MDIOS configuration register
        pub const MDIOS_CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            EN: u1,
            /// Register write interrupt
            /// enable
            WRIE: u1,
            /// Register Read Interrupt
            /// Enable
            RDIE: u1,
            /// Error interrupt enable
            EIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Disable Preamble Check
            DPC: u1,
            /// Slaves's address
            PORT_ADDRESS: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x40017804
        /// MDIOS write flag register
        pub const MDIOS_WRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write flags for MDIO registers 0 to
            /// 31
            WRF: u32,
        }), base_address + 0x4);

        /// address: 0x40017808
        /// MDIOS clear write flag
        /// register
        pub const MDIOS_CWRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the write flag
            CWRF: u32,
        }), base_address + 0x8);

        /// address: 0x4001780c
        /// MDIOS read flag register
        pub const MDIOS_RDFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read flags for MDIO registers 0 to
            /// 31
            RDF: u32,
        }), base_address + 0xc);

        /// address: 0x40017810
        /// MDIOS clear read flag register
        pub const MDIOS_CRDFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the read flag
            CRDF: u32,
        }), base_address + 0x10);

        /// address: 0x40017814
        /// MDIOS status register
        pub const MDIOS_SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Preamble error flag
            PERF: u1,
            /// Start error flag
            SERF: u1,
            /// Turnaround error flag
            TERF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x14);

        /// address: 0x40017818
        /// MDIOS clear flag register
        pub const MDIOS_CLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the preamble error
            /// flag
            CPERF: u1,
            /// Clear the start error flag
            CSERF: u1,
            /// Clear the turnaround error
            /// flag
            CTERF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x18);

        /// address: 0x4001781c
        /// MDIOS input data register 0
        pub const MDIOS_DINR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN0: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40017820
        /// MDIOS input data register 1
        pub const MDIOS_DINR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40017824
        /// MDIOS input data register 2
        pub const MDIOS_DINR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x40017828
        /// MDIOS input data register 3
        pub const MDIOS_DINR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4001782c
        /// MDIOS input data register 4
        pub const MDIOS_DINR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x40017830
        /// MDIOS input data register 5
        pub const MDIOS_DINR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN5: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40017834
        /// MDIOS input data register 6
        pub const MDIOS_DINR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN6: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40017838
        /// MDIOS input data register 7
        pub const MDIOS_DINR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN7: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x4001783c
        /// MDIOS input data register 8
        pub const MDIOS_DINR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN8: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40017840
        /// MDIOS input data register 9
        pub const MDIOS_DINR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN9: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40017844
        /// MDIOS input data register 10
        pub const MDIOS_DINR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN10: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40017848
        /// MDIOS input data register 11
        pub const MDIOS_DINR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN11: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001784c
        /// MDIOS input data register 12
        pub const MDIOS_DINR12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN12: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40017850
        /// MDIOS input data register 13
        pub const MDIOS_DINR13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN13: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x40017854
        /// MDIOS input data register 14
        pub const MDIOS_DINR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN14: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x40017858
        /// MDIOS input data register 15
        pub const MDIOS_DINR15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN15: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x4001785c
        /// MDIOS input data register 16
        pub const MDIOS_DINR16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN16: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40017860
        /// MDIOS input data register 17
        pub const MDIOS_DINR17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN17: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x60);

        /// address: 0x40017864
        /// MDIOS input data register 18
        pub const MDIOS_DINR18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN18: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x64);

        /// address: 0x40017868
        /// MDIOS input data register 19
        pub const MDIOS_DINR19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN19: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x68);

        /// address: 0x4001786c
        /// MDIOS input data register 20
        pub const MDIOS_DINR20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN20: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x6c);

        /// address: 0x40017870
        /// MDIOS input data register 21
        pub const MDIOS_DINR21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN21: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40017874
        /// MDIOS input data register 22
        pub const MDIOS_DINR22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN22: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x74);

        /// address: 0x40017878
        /// MDIOS input data register 23
        pub const MDIOS_DINR23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN23: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x78);

        /// address: 0x4001787c
        /// MDIOS input data register 24
        pub const MDIOS_DINR24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN24: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x7c);

        /// address: 0x40017880
        /// MDIOS input data register 25
        pub const MDIOS_DINR25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN25: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x40017884
        /// MDIOS input data register 26
        pub const MDIOS_DINR26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN26: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40017888
        /// MDIOS input data register 27
        pub const MDIOS_DINR27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN27: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x4001788c
        /// MDIOS input data register 28
        pub const MDIOS_DINR28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN28: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x40017890
        /// MDIOS input data register 29
        pub const MDIOS_DINR29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN29: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x90);

        /// address: 0x40017894
        /// MDIOS input data register 30
        pub const MDIOS_DINR30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN30: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x94);

        /// address: 0x40017898
        /// MDIOS input data register 31
        pub const MDIOS_DINR31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data received from MDIO Master
            /// during write frames
            DIN31: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x98);

        /// address: 0x4001789c
        /// MDIOS output data register 0
        pub const MDIOS_DOUTR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT0: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x9c);

        /// address: 0x400178a0
        /// MDIOS output data register 1
        pub const MDIOS_DOUTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa0);

        /// address: 0x400178a4
        /// MDIOS output data register 2
        pub const MDIOS_DOUTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa4);

        /// address: 0x400178a8
        /// MDIOS output data register 3
        pub const MDIOS_DOUTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa8);

        /// address: 0x400178ac
        /// MDIOS output data register 4
        pub const MDIOS_DOUTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xac);

        /// address: 0x400178b0
        /// MDIOS output data register 5
        pub const MDIOS_DOUTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT5: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xb0);

        /// address: 0x400178b4
        /// MDIOS output data register 6
        pub const MDIOS_DOUTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT6: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xb4);

        /// address: 0x400178b8
        /// MDIOS output data register 7
        pub const MDIOS_DOUTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT7: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xb8);

        /// address: 0x400178bc
        /// MDIOS output data register 8
        pub const MDIOS_DOUTR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT8: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xbc);

        /// address: 0x400178c0
        /// MDIOS output data register 9
        pub const MDIOS_DOUTR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT9: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc0);

        /// address: 0x400178c4
        /// MDIOS output data register 10
        pub const MDIOS_DOUTR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT10: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc4);

        /// address: 0x400178c8
        /// MDIOS output data register 11
        pub const MDIOS_DOUTR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT11: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc8);

        /// address: 0x400178cc
        /// MDIOS output data register 12
        pub const MDIOS_DOUTR12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT12: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xcc);

        /// address: 0x400178d0
        /// MDIOS output data register 13
        pub const MDIOS_DOUTR13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT13: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xd0);

        /// address: 0x400178d4
        /// MDIOS output data register 14
        pub const MDIOS_DOUTR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT14: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xd4);

        /// address: 0x400178d8
        /// MDIOS output data register 15
        pub const MDIOS_DOUTR15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT15: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xd8);

        /// address: 0x400178dc
        /// MDIOS output data register 16
        pub const MDIOS_DOUTR16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT16: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xdc);

        /// address: 0x400178e0
        /// MDIOS output data register 17
        pub const MDIOS_DOUTR17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT17: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xe0);

        /// address: 0x400178e4
        /// MDIOS output data register 18
        pub const MDIOS_DOUTR18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT18: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xe4);

        /// address: 0x400178e8
        /// MDIOS output data register 19
        pub const MDIOS_DOUTR19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT19: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xe8);

        /// address: 0x400178ec
        /// MDIOS output data register 20
        pub const MDIOS_DOUTR20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT20: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xec);

        /// address: 0x400178f0
        /// MDIOS output data register 21
        pub const MDIOS_DOUTR21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT21: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xf0);

        /// address: 0x400178f4
        /// MDIOS output data register 22
        pub const MDIOS_DOUTR22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT22: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xf4);

        /// address: 0x400178f8
        /// MDIOS output data register 23
        pub const MDIOS_DOUTR23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT23: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xf8);

        /// address: 0x400178fc
        /// MDIOS output data register 24
        pub const MDIOS_DOUTR24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT24: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xfc);

        /// address: 0x40017900
        /// MDIOS output data register 25
        pub const MDIOS_DOUTR25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT25: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x100);

        /// address: 0x40017904
        /// MDIOS output data register 26
        pub const MDIOS_DOUTR26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT26: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x104);

        /// address: 0x40017908
        /// MDIOS output data register 27
        pub const MDIOS_DOUTR27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT27: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x108);

        /// address: 0x4001790c
        /// MDIOS output data register 28
        pub const MDIOS_DOUTR28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT28: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x40017910
        /// MDIOS output data register 29
        pub const MDIOS_DOUTR29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT29: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x110);

        /// address: 0x40017914
        /// MDIOS output data register 30
        pub const MDIOS_DOUTR30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT30: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x114);

        /// address: 0x40017918
        /// MDIOS output data register 31
        pub const MDIOS_DOUTR31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output data sent to MDIO Master during
            /// read frames
            DOUT31: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);
    };

    /// Digital filter for sigma delta
    /// modulators
    pub const DFSDM = struct {
        pub const base_address = 0x40017400;

        /// address: 0x40017400
        /// DFSDM channel configuration 0 register
        /// 1
        pub const DFSDM_CHCFG0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 0
            SITP: u2,
            /// SPI clock select for channel
            /// 0
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 0
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 0
            CKABEN: u1,
            /// Channel 0 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 0
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0x0);

        /// address: 0x40017420
        /// DFSDM channel configuration 1 register
        /// 1
        pub const DFSDM_CHCFG1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 1
            SITP: u2,
            /// SPI clock select for channel
            /// 1
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 1
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 1
            CKABEN: u1,
            /// Channel 1 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 1
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0x20);

        /// address: 0x40017440
        /// DFSDM channel configuration 2 register
        /// 1
        pub const DFSDM_CHCFG2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 2
            SITP: u2,
            /// SPI clock select for channel
            /// 2
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 2
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 2
            CKABEN: u1,
            /// Channel 2 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 2
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0x40);

        /// address: 0x40017460
        /// DFSDM channel configuration 3 register
        /// 1
        pub const DFSDM_CHCFG3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 3
            SITP: u2,
            /// SPI clock select for channel
            /// 3
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 3
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 3
            CKABEN: u1,
            /// Channel 3 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 3
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0x60);

        /// address: 0x40017480
        /// DFSDM channel configuration 4 register
        /// 1
        pub const DFSDM_CHCFG4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 4
            SITP: u2,
            /// SPI clock select for channel
            /// 4
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 4
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 4
            CKABEN: u1,
            /// Channel 4 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 4
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0x80);

        /// address: 0x400174a0
        /// DFSDM channel configuration 5 register
        /// 1
        pub const DFSDM_CHCFG5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 5
            SITP: u2,
            /// SPI clock select for channel
            /// 5
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 5
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 5
            CKABEN: u1,
            /// Channel 5 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 5
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0xa0);

        /// address: 0x400174c0
        /// DFSDM channel configuration 6 register
        /// 1
        pub const DFSDM_CHCFG6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 6
            SITP: u2,
            /// SPI clock select for channel
            /// 6
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 6
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 6
            CKABEN: u1,
            /// Channel 6 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 6
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0xc0);

        /// address: 0x400174e0
        /// DFSDM channel configuration 7 register
        /// 1
        pub const DFSDM_CHCFG7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial interface type for channel
            /// 7
            SITP: u2,
            /// SPI clock select for channel
            /// 7
            SPICKSEL: u2,
            reserved0: u1,
            /// Short-circuit detector enable on channel
            /// 7
            SCDEN: u1,
            /// Clock absence detector enable on channel
            /// 7
            CKABEN: u1,
            /// Channel 7 enable
            CHEN: u1,
            /// Channel inputs selection
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input data multiplexer for channel
            /// 7
            DATMPX: u2,
            /// Data packing mode in DFSDM_CHDATINyR
            /// register
            DATPACK: u2,
            /// Output serial clock
            /// divider
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Output serial clock source
            /// selection
            CKOUTSRC: u1,
            /// Global enable for DFSDM
            /// interface
            DFSDMEN: u1,
        }), base_address + 0xe0);

        /// address: 0x40017404
        /// DFSDM channel configuration 0 register
        /// 2
        pub const DFSDM_CHCFG0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 0
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 0
            OFFSET: u24,
        }), base_address + 0x4);

        /// address: 0x40017424
        /// DFSDM channel configuration 1 register
        /// 2
        pub const DFSDM_CHCFG1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 1
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 1
            OFFSET: u24,
        }), base_address + 0x24);

        /// address: 0x40017444
        /// DFSDM channel configuration 2 register
        /// 2
        pub const DFSDM_CHCFG2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 2
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 2
            OFFSET: u24,
        }), base_address + 0x44);

        /// address: 0x40017464
        /// DFSDM channel configuration 3 register
        /// 2
        pub const DFSDM_CHCFG3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 3
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 3
            OFFSET: u24,
        }), base_address + 0x64);

        /// address: 0x40017484
        /// DFSDM channel configuration 4 register
        /// 2
        pub const DFSDM_CHCFG4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 4
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 4
            OFFSET: u24,
        }), base_address + 0x84);

        /// address: 0x400174a4
        /// DFSDM channel configuration 5 register
        /// 2
        pub const DFSDM_CHCFG5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 5
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 5
            OFFSET: u24,
        }), base_address + 0xa4);

        /// address: 0x400174c4
        /// DFSDM channel configuration 6 register
        /// 2
        pub const DFSDM_CHCFG6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 6
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 6
            OFFSET: u24,
        }), base_address + 0xc4);

        /// address: 0x400174e4
        /// DFSDM channel configuration 7 register
        /// 2
        pub const DFSDM_CHCFG7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data right bit-shift for channel
            /// 7
            DTRBS: u5,
            /// 24-bit calibration offset for channel
            /// 7
            OFFSET: u24,
        }), base_address + 0xe4);

        /// address: 0x40017408
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 0
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 0
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 0
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 0
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x40017428
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 1
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 1
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 1
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 1
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x40017448
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 2
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 2
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 2
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 2
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x40017468
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 3
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 3
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 3
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 3
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x68);

        /// address: 0x40017488
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 4
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 4
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 4
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 4
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x88);

        /// address: 0x400174a8
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 5
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 5
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 5
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 5
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xa8);

        /// address: 0x400174c8
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 6
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 6
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 6
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 6
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc8);

        /// address: 0x400174e8
        /// DFSDM analog watchdog and short-circuit
        /// detector register
        pub const DFSDM_AWSCD7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// short-circuit detector threshold for
            /// channel 7
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Break signal assignment for
            /// short-circuit detector on channel 7
            BKSCD: u4,
            /// Analog watchdog filter oversampling
            /// ratio (decimation rate) on channel 7
            AWFOSR: u5,
            reserved4: u1,
            /// Analog watchdog Sinc filter order on
            /// channel 7
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xe8);

        /// address: 0x4001740c
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x4001742c
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x4001744c
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x4001746c
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x6c);

        /// address: 0x4001748c
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x400174ac
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xac);

        /// address: 0x400174cc
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xcc);

        /// address: 0x400174ec
        /// DFSDM channel watchdog filter data
        /// register
        pub const DFSDM_CHWDAT7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input channel y watchdog
            /// data
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xec);

        /// address: 0x40017410
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 0
            INDAT0: u16,
            /// Input data for channel 1
            INDAT1: u16,
        }), base_address + 0x10);

        /// address: 0x40017430
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 1
            INDAT0: u16,
            /// Input data for channel 2
            INDAT1: u16,
        }), base_address + 0x30);

        /// address: 0x40017450
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 2
            INDAT0: u16,
            /// Input data for channel 3
            INDAT1: u16,
        }), base_address + 0x50);

        /// address: 0x40017470
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 3
            INDAT0: u16,
            /// Input data for channel 4
            INDAT1: u16,
        }), base_address + 0x70);

        /// address: 0x40017490
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 4
            INDAT0: u16,
            /// Input data for channel 5
            INDAT1: u16,
        }), base_address + 0x90);

        /// address: 0x400174b0
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 5
            INDAT0: u16,
            /// Input data for channel 6
            INDAT1: u16,
        }), base_address + 0xb0);

        /// address: 0x400174d0
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 6
            INDAT0: u16,
            /// Input data for channel 7
            INDAT1: u16,
        }), base_address + 0xd0);

        /// address: 0x400174f0
        /// DFSDM channel data input
        /// register
        pub const DFSDM_CHDATIN7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input data for channel 7
            INDAT0: u16,
            /// Input data for channel 8
            INDAT1: u16,
        }), base_address + 0xf0);

        /// address: 0x40017500
        /// DFSDM control register 1
        pub const DFSDM0_CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u5,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved3: u1,
            reserved4: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved5: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// Regular channel selection
            RCH: u3,
            reserved8: u1,
            reserved9: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x100);

        /// address: 0x40017580
        /// DFSDM control register 1
        pub const DFSDM1_CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u5,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved3: u1,
            reserved4: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved5: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// Regular channel selection
            RCH: u3,
            reserved8: u1,
            reserved9: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x180);

        /// address: 0x40017600
        /// DFSDM control register 1
        pub const DFSDM2_CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u5,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved3: u1,
            reserved4: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved5: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// Regular channel selection
            RCH: u3,
            reserved8: u1,
            reserved9: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x200);

        /// address: 0x40017780
        /// DFSDM control register 1
        pub const DFSDM3_CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u5,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved3: u1,
            reserved4: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved5: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// Regular channel selection
            RCH: u3,
            reserved8: u1,
            reserved9: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x380);

        /// address: 0x40017504
        /// DFSDM control register 2
        pub const DFSDM0_CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x104);

        /// address: 0x40017584
        /// DFSDM control register 2
        pub const DFSDM1_CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x184);

        /// address: 0x40017604
        /// DFSDM control register 2
        pub const DFSDM2_CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x204);

        /// address: 0x40017784
        /// DFSDM control register 2
        pub const DFSDM3_CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x384);

        /// address: 0x40017508
        /// DFSDM interrupt and status
        /// register
        pub const DFSDM0_ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x108);

        /// address: 0x40017588
        /// DFSDM interrupt and status
        /// register
        pub const DFSDM1_ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x188);

        /// address: 0x40017608
        /// DFSDM interrupt and status
        /// register
        pub const DFSDM2_ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x208);

        /// address: 0x40017788
        /// DFSDM interrupt and status
        /// register
        pub const DFSDM3_ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x388);

        /// address: 0x4001750c
        /// DFSDM interrupt flag clear
        /// register
        pub const DFSDM0_ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x10c);

        /// address: 0x4001758c
        /// DFSDM interrupt flag clear
        /// register
        pub const DFSDM1_ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x18c);

        /// address: 0x4001760c
        /// DFSDM interrupt flag clear
        /// register
        pub const DFSDM2_ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x20c);

        /// address: 0x4001778c
        /// DFSDM interrupt flag clear
        /// register
        pub const DFSDM3_ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x38c);

        /// address: 0x40017510
        /// DFSDM injected channel group selection
        /// register
        pub const DFSDM0_JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x110);

        /// address: 0x40017590
        /// DFSDM injected channel group selection
        /// register
        pub const DFSDM1_JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x190);

        /// address: 0x40017610
        /// DFSDM injected channel group selection
        /// register
        pub const DFSDM2_JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x210);

        /// address: 0x40017710
        /// DFSDM injected channel group selection
        /// register
        pub const DFSDM3_JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x310);

        /// address: 0x40017514
        /// DFSDM filter control register
        pub const DFSDM0_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x114);

        /// address: 0x40017594
        /// DFSDM filter control register
        pub const DFSDM1_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x194);

        /// address: 0x40017614
        /// DFSDM filter control register
        pub const DFSDM2_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x214);

        /// address: 0x40017714
        /// DFSDM filter control register
        pub const DFSDM3_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x314);

        /// address: 0x40017518
        /// DFSDM data register for injected
        /// group
        pub const DFSDM0_JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x118);

        /// address: 0x40017598
        /// DFSDM data register for injected
        /// group
        pub const DFSDM1_JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x198);

        /// address: 0x40017618
        /// DFSDM data register for injected
        /// group
        pub const DFSDM2_JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x218);

        /// address: 0x40017718
        /// DFSDM data register for injected
        /// group
        pub const DFSDM3_JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x318);

        /// address: 0x4001751c
        /// DFSDM data register for the regular
        /// channel
        pub const DFSDM0_RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x11c);

        /// address: 0x40017598
        /// DFSDM data register for the regular
        /// channel
        pub const DFSDM1_RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x198);

        /// address: 0x40017618
        /// DFSDM data register for the regular
        /// channel
        pub const DFSDM2_RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x218);

        /// address: 0x40017718
        /// DFSDM data register for the regular
        /// channel
        pub const DFSDM3_RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x318);

        /// address: 0x40017520
        /// DFSDM analog watchdog high threshold
        /// register
        pub const DFSDM0_AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x120);

        /// address: 0x400175a0
        /// DFSDM analog watchdog high threshold
        /// register
        pub const DFSDM1_AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x1a0);

        /// address: 0x40017620
        /// DFSDM analog watchdog high threshold
        /// register
        pub const DFSDM2_AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x220);

        /// address: 0x400176a0
        /// DFSDM analog watchdog high threshold
        /// register
        pub const DFSDM3_AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x2a0);

        /// address: 0x40017524
        /// DFSDM analog watchdog low threshold
        /// register
        pub const DFSDM0_AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x124);

        /// address: 0x400175a4
        /// DFSDM analog watchdog low threshold
        /// register
        pub const DFSDM1_AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x1a4);

        /// address: 0x40017624
        /// DFSDM analog watchdog low threshold
        /// register
        pub const DFSDM2_AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x224);

        /// address: 0x400176a4
        /// DFSDM analog watchdog low threshold
        /// register
        pub const DFSDM3_AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x2a4);

        /// address: 0x40017528
        /// DFSDM analog watchdog status
        /// register
        pub const DFSDM0_AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x128);

        /// address: 0x400175a8
        /// DFSDM analog watchdog status
        /// register
        pub const DFSDM1_AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1a8);

        /// address: 0x40017628
        /// DFSDM analog watchdog status
        /// register
        pub const DFSDM2_AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x228);

        /// address: 0x400176a8
        /// DFSDM analog watchdog status
        /// register
        pub const DFSDM3_AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2a8);

        /// address: 0x4001752c
        /// DFSDM analog watchdog clear flag
        /// register
        pub const DFSDM0_AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x12c);

        /// address: 0x400175ac
        /// DFSDM analog watchdog clear flag
        /// register
        pub const DFSDM1_AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1ac);

        /// address: 0x4001762c
        /// DFSDM analog watchdog clear flag
        /// register
        pub const DFSDM2_AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x22c);

        /// address: 0x400176ac
        /// DFSDM analog watchdog clear flag
        /// register
        pub const DFSDM3_AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2ac);

        /// address: 0x40017530
        /// DFSDM Extremes detector maximum
        /// register
        pub const DFSDM0_EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x130);

        /// address: 0x400175b0
        /// DFSDM Extremes detector maximum
        /// register
        pub const DFSDM1_EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x1b0);

        /// address: 0x40017630
        /// DFSDM Extremes detector maximum
        /// register
        pub const DFSDM2_EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x230);

        /// address: 0x400176b0
        /// DFSDM Extremes detector maximum
        /// register
        pub const DFSDM3_EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x2b0);

        /// address: 0x40017534
        /// DFSDM Extremes detector minimum
        /// register
        pub const DFSDM0_EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector minimum
            /// value
            EXMIN: u24,
        }), base_address + 0x134);

        /// address: 0x400175b4
        /// DFSDM Extremes detector minimum
        /// register
        pub const DFSDM1_EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector minimum
            /// value
            EXMIN: u24,
        }), base_address + 0x1b4);

        /// address: 0x40017634
        /// DFSDM Extremes detector minimum
        /// register
        pub const DFSDM2_EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector minimum
            /// value
            EXMIN: u24,
        }), base_address + 0x234);

        /// address: 0x400176b4
        /// DFSDM Extremes detector minimum
        /// register
        pub const DFSDM3_EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector minimum
            /// value
            EXMIN: u24,
        }), base_address + 0x2b4);

        /// address: 0x40017538
        /// DFSDM conversion timer
        /// register
        pub const DFSDM0_CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion
            /// time
            CNVCNT: u28,
        }), base_address + 0x138);

        /// address: 0x400175b8
        /// DFSDM conversion timer
        /// register
        pub const DFSDM1_CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion
            /// time
            CNVCNT: u28,
        }), base_address + 0x1b8);

        /// address: 0x40017638
        /// DFSDM conversion timer
        /// register
        pub const DFSDM2_CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion
            /// time
            CNVCNT: u28,
        }), base_address + 0x238);

        /// address: 0x400176b8
        /// DFSDM conversion timer
        /// register
        pub const DFSDM3_CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion
            /// time
            CNVCNT: u28,
        }), base_address + 0x2b8);
    };

    /// JPEG codec
    pub const JPEG = struct {
        pub const base_address = 0x50051000;

        /// address: 0x50051000
        /// JPEG codec configuration register
        /// 0
        pub const JPEG_CONFR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start
            START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x0);

        /// address: 0x50051004
        /// JPEG codec configuration register
        /// 1
        pub const JPEG_CONFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of color components
            NF: u2,
            reserved0: u1,
            /// Decoding Enable
            DE: u1,
            /// Color Space
            COLORSPACE: u2,
            /// Number of components for
            /// Scan
            NS: u2,
            /// Header Processing
            HDR: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Y Size
            YSIZE: u16,
        }), base_address + 0x4);

        /// address: 0x50051008
        /// JPEG codec configuration register
        /// 2
        pub const JPEG_CONFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of MCU
            NMCU: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x8);

        /// address: 0x5005100c
        /// JPEG codec configuration register
        /// 3
        pub const JPEG_CONFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// X size
            XSIZE: u16,
        }), base_address + 0xc);

        /// address: 0x50051010
        /// JPEG codec configuration register
        /// 4
        pub const JPEG_CONFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Huffman DC
            HD: u1,
            /// Huffman AC
            HA: u1,
            /// Quantization Table
            QT: u2,
            /// Number of Block
            NB: u4,
            /// Vertical Sampling Factor
            VSF: u4,
            /// Horizontal Sampling Factor
            HSF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50051014
        /// JPEG codec configuration register
        /// 5
        pub const JPEG_CONFR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Huffman DC
            HD: u1,
            /// Huffman AC
            HA: u1,
            /// Quantization Table
            QT: u2,
            /// Number of Block
            NB: u4,
            /// Vertical Sampling Factor
            VSF: u4,
            /// Horizontal Sampling Factor
            HSF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50051018
        /// JPEG codec configuration register
        /// 6
        pub const JPEG_CONFR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Huffman DC
            HD: u1,
            /// Huffman AC
            HA: u1,
            /// Quantization Table
            QT: u2,
            /// Number of Block
            NB: u4,
            /// Vertical Sampling Factor
            VSF: u4,
            /// Horizontal Sampling Factor
            HSF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x5005101c
        /// JPEG codec configuration register
        /// 7
        pub const JPEG_CONFR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Huffman DC
            HD: u1,
            /// Huffman AC
            HA: u1,
            /// Quantization Table
            QT: u2,
            /// Number of Block
            NB: u4,
            /// Vertical Sampling Factor
            VSF: u4,
            /// Horizontal Sampling Factor
            HSF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x50051030
        /// JPEG control register
        pub const JPEG_CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JPEG Core Enable
            JCEN: u1,
            /// Input FIFO Threshold Interrupt
            /// Enable
            IFTIE: u1,
            /// Input FIFO Not Full Interrupt
            /// Enable
            IFNFIE: u1,
            /// Output FIFO Threshold Interrupt
            /// Enable
            OFTIE: u1,
            /// Output FIFO Not Empty Interrupt
            /// Enable
            OFNEIE: u1,
            /// End of Conversion Interrupt
            /// Enable
            EOCIE: u1,
            /// Header Parsing Done Interrupt
            /// Enable
            HPDIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Input DMA Enable
            IDMAEN: u1,
            /// Output DMA Enable
            ODMAEN: u1,
            /// Input FIFO Flush
            IFF: u1,
            /// Output FIFO Flush
            OFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x50051034
        /// JPEG status register
        pub const JPEG_SR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Input FIFO Threshold Flag
            IFTF: u1,
            /// Input FIFO Not Full Flag
            IFNFF: u1,
            /// Output FIFO Threshold Flag
            OFTF: u1,
            /// Output FIFO Not Empty Flag
            OFNEF: u1,
            /// End of Conversion Flag
            EOCF: u1,
            /// Header Parsing Done Flag
            HPDF: u1,
            /// Codec Operation Flag
            COF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x34);

        /// address: 0x50051038
        /// JPEG clear flag register
        pub const JPEG_CFR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Clear End of Conversion
            /// Flag
            CEOCF: u1,
            /// Clear Header Parsing Done
            /// Flag
            CHPDF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x38);

        /// address: 0x50051040
        /// JPEG data input register
        pub const JPEG_DIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Input FIFO
            DATAIN: u32,
        }), base_address + 0x40);

        /// address: 0x50051044
        /// JPEG data output register
        pub const JPEG_DOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Output FIFO
            DATAOUT: u32,
        }), base_address + 0x44);

        /// address: 0x50051050
        /// JPEG quantization tables
        pub const QMEM0_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x50);

        /// address: 0x50051054
        /// JPEG quantization tables
        pub const QMEM0_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x54);

        /// address: 0x50051058
        /// JPEG quantization tables
        pub const QMEM0_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x58);

        /// address: 0x5005105c
        /// JPEG quantization tables
        pub const QMEM0_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x5c);

        /// address: 0x50051060
        /// JPEG quantization tables
        pub const QMEM0_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x60);

        /// address: 0x50051064
        /// JPEG quantization tables
        pub const QMEM0_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x64);

        /// address: 0x50051068
        /// JPEG quantization tables
        pub const QMEM0_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x68);

        /// address: 0x5005106c
        /// JPEG quantization tables
        pub const QMEM0_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x6c);

        /// address: 0x50051070
        /// JPEG quantization tables
        pub const QMEM0_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x70);

        /// address: 0x50051074
        /// JPEG quantization tables
        pub const QMEM0_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x74);

        /// address: 0x50051078
        /// JPEG quantization tables
        pub const QMEM0_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x78);

        /// address: 0x5005107c
        /// JPEG quantization tables
        pub const QMEM0_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x7c);

        /// address: 0x50051080
        /// JPEG quantization tables
        pub const QMEM0_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x80);

        /// address: 0x50051084
        /// JPEG quantization tables
        pub const QMEM0_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x84);

        /// address: 0x50051088
        /// JPEG quantization tables
        pub const QMEM0_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x88);

        /// address: 0x5005108c
        /// JPEG quantization tables
        pub const QMEM0_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x8c);

        /// address: 0x50051090
        /// JPEG quantization tables
        pub const QMEM1_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x90);

        /// address: 0x50051094
        /// JPEG quantization tables
        pub const QMEM1_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x94);

        /// address: 0x50051098
        /// JPEG quantization tables
        pub const QMEM1_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x98);

        /// address: 0x5005109c
        /// JPEG quantization tables
        pub const QMEM1_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x9c);

        /// address: 0x500510a0
        /// JPEG quantization tables
        pub const QMEM1_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xa0);

        /// address: 0x500510a4
        /// JPEG quantization tables
        pub const QMEM1_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xa4);

        /// address: 0x500510a8
        /// JPEG quantization tables
        pub const QMEM1_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xa8);

        /// address: 0x500510ac
        /// JPEG quantization tables
        pub const QMEM1_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xac);

        /// address: 0x500510b0
        /// JPEG quantization tables
        pub const QMEM1_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xb0);

        /// address: 0x500510b4
        /// JPEG quantization tables
        pub const QMEM1_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xb4);

        /// address: 0x500510b8
        /// JPEG quantization tables
        pub const QMEM1_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xb8);

        /// address: 0x500510bc
        /// JPEG quantization tables
        pub const QMEM1_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xbc);

        /// address: 0x500510c0
        /// JPEG quantization tables
        pub const QMEM1_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xc0);

        /// address: 0x500510c4
        /// JPEG quantization tables
        pub const QMEM1_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xc4);

        /// address: 0x500510c8
        /// JPEG quantization tables
        pub const QMEM1_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xc8);

        /// address: 0x500510cc
        /// JPEG quantization tables
        pub const QMEM1_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xcc);

        /// address: 0x500510d0
        /// JPEG quantization tables
        pub const QMEM2_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xd0);

        /// address: 0x500510d4
        /// JPEG quantization tables
        pub const QMEM2_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xd4);

        /// address: 0x500510d8
        /// JPEG quantization tables
        pub const QMEM2_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xd8);

        /// address: 0x500510dc
        /// JPEG quantization tables
        pub const QMEM2_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xdc);

        /// address: 0x500510e0
        /// JPEG quantization tables
        pub const QMEM2_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xe0);

        /// address: 0x500510e4
        /// JPEG quantization tables
        pub const QMEM2_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xe4);

        /// address: 0x500510e8
        /// JPEG quantization tables
        pub const QMEM2_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xe8);

        /// address: 0x500510ec
        /// JPEG quantization tables
        pub const QMEM2_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xec);

        /// address: 0x500510f0
        /// JPEG quantization tables
        pub const QMEM2_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xf0);

        /// address: 0x500510f4
        /// JPEG quantization tables
        pub const QMEM2_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xf4);

        /// address: 0x500510f8
        /// JPEG quantization tables
        pub const QMEM2_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xf8);

        /// address: 0x500510fc
        /// JPEG quantization tables
        pub const QMEM2_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0xfc);

        /// address: 0x50051100
        /// JPEG quantization tables
        pub const QMEM2_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x100);

        /// address: 0x50051104
        /// JPEG quantization tables
        pub const QMEM2_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x104);

        /// address: 0x50051108
        /// JPEG quantization tables
        pub const QMEM2_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x108);

        /// address: 0x5005110c
        /// JPEG quantization tables
        pub const QMEM2_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x10c);

        /// address: 0x50051110
        /// JPEG quantization tables
        pub const QMEM3_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x110);

        /// address: 0x50051114
        /// JPEG quantization tables
        pub const QMEM3_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x114);

        /// address: 0x50051118
        /// JPEG quantization tables
        pub const QMEM3_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x118);

        /// address: 0x5005111c
        /// JPEG quantization tables
        pub const QMEM3_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x11c);

        /// address: 0x50051120
        /// JPEG quantization tables
        pub const QMEM3_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x120);

        /// address: 0x50051124
        /// JPEG quantization tables
        pub const QMEM3_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x124);

        /// address: 0x50051128
        /// JPEG quantization tables
        pub const QMEM3_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x128);

        /// address: 0x5005112c
        /// JPEG quantization tables
        pub const QMEM3_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x12c);

        /// address: 0x50051130
        /// JPEG quantization tables
        pub const QMEM3_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x130);

        /// address: 0x50051134
        /// JPEG quantization tables
        pub const QMEM3_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x134);

        /// address: 0x50051138
        /// JPEG quantization tables
        pub const QMEM3_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x138);

        /// address: 0x5005113c
        /// JPEG quantization tables
        pub const QMEM3_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x13c);

        /// address: 0x50051140
        /// JPEG quantization tables
        pub const QMEM3_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x140);

        /// address: 0x50051144
        /// JPEG quantization tables
        pub const QMEM3_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x144);

        /// address: 0x50051148
        /// JPEG quantization tables
        pub const QMEM3_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x148);

        /// address: 0x5005114c
        /// JPEG quantization tables
        pub const QMEM3_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// QMem RAM
            QMem_RAM: u32,
        }), base_address + 0x14c);

        /// address: 0x50051150
        /// JPEG HuffMin tables
        pub const HUFFMIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x150);

        /// address: 0x50051154
        /// JPEG HuffMin tables
        pub const HUFFMIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x154);

        /// address: 0x50051158
        /// JPEG HuffMin tables
        pub const HUFFMIN_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x158);

        /// address: 0x5005115c
        /// JPEG HuffMin tables
        pub const HUFFMIN_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x15c);

        /// address: 0x50051160
        /// JPEG HuffMin tables
        pub const HUFFMIN_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x160);

        /// address: 0x50051164
        /// JPEG HuffMin tables
        pub const HUFFMIN_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x164);

        /// address: 0x50051168
        /// JPEG HuffMin tables
        pub const HUFFMIN_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x168);

        /// address: 0x5005116c
        /// JPEG HuffMin tables
        pub const HUFFMIN_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x16c);

        /// address: 0x50051170
        /// JPEG HuffMin tables
        pub const HUFFMIN_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x170);

        /// address: 0x50051174
        /// JPEG HuffMin tables
        pub const HUFFMIN_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x174);

        /// address: 0x50051178
        /// JPEG HuffMin tables
        pub const HUFFMIN_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x178);

        /// address: 0x5005117c
        /// JPEG HuffMin tables
        pub const HUFFMIN_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x17c);

        /// address: 0x50051180
        /// JPEG HuffMin tables
        pub const HUFFMIN_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x180);

        /// address: 0x50051184
        /// JPEG HuffMin tables
        pub const HUFFMIN_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x184);

        /// address: 0x50051188
        /// JPEG HuffMin tables
        pub const HUFFMIN_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x188);

        /// address: 0x5005118c
        /// JPEG HuffMin tables
        pub const HUFFMIN_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffMin RAM
            HuffMin_RAM: u32,
        }), base_address + 0x18c);

        /// address: 0x50051190
        /// JPEG HuffSymb tables
        pub const HUFFBASE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x190);

        /// address: 0x50051194
        /// JPEG HuffSymb tables
        pub const HUFFBASE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x194);

        /// address: 0x50051198
        /// JPEG HuffSymb tables
        pub const HUFFBASE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x198);

        /// address: 0x5005119c
        /// JPEG HuffSymb tables
        pub const HUFFBASE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x19c);

        /// address: 0x500511a0
        /// JPEG HuffSymb tables
        pub const HUFFBASE4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1a0);

        /// address: 0x500511a4
        /// JPEG HuffSymb tables
        pub const HUFFBASE5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1a4);

        /// address: 0x500511a8
        /// JPEG HuffSymb tables
        pub const HUFFBASE6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1a8);

        /// address: 0x500511ac
        /// JPEG HuffSymb tables
        pub const HUFFBASE7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1ac);

        /// address: 0x500511b0
        /// JPEG HuffSymb tables
        pub const HUFFBASE8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1b0);

        /// address: 0x500511b4
        /// JPEG HuffSymb tables
        pub const HUFFBASE9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1b4);

        /// address: 0x500511b8
        /// JPEG HuffSymb tables
        pub const HUFFBASE10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1b8);

        /// address: 0x500511bc
        /// JPEG HuffSymb tables
        pub const HUFFBASE11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1bc);

        /// address: 0x500511c0
        /// JPEG HuffSymb tables
        pub const HUFFBASE12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c0);

        /// address: 0x500511c4
        /// JPEG HuffSymb tables
        pub const HUFFBASE13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c4);

        /// address: 0x500511c8
        /// JPEG HuffSymb tables
        pub const HUFFBASE14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c8);

        /// address: 0x500511cc
        /// JPEG HuffSymb tables
        pub const HUFFBASE15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1cc);

        /// address: 0x500511d0
        /// JPEG HuffSymb tables
        pub const HUFFBASE16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1d0);

        /// address: 0x500511d4
        /// JPEG HuffSymb tables
        pub const HUFFBASE17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1d4);

        /// address: 0x500511d8
        /// JPEG HuffSymb tables
        pub const HUFFBASE18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1d8);

        /// address: 0x500511dc
        /// JPEG HuffSymb tables
        pub const HUFFBASE19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1dc);

        /// address: 0x500511e0
        /// JPEG HuffSymb tables
        pub const HUFFBASE20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1e0);

        /// address: 0x500511e4
        /// JPEG HuffSymb tables
        pub const HUFFBASE21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1e4);

        /// address: 0x500511e8
        /// JPEG HuffSymb tables
        pub const HUFFBASE22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1e8);

        /// address: 0x500511ec
        /// JPEG HuffSymb tables
        pub const HUFFBASE23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1ec);

        /// address: 0x500511f0
        /// JPEG HuffSymb tables
        pub const HUFFBASE24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1f0);

        /// address: 0x500511f4
        /// JPEG HuffSymb tables
        pub const HUFFBASE25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1f4);

        /// address: 0x500511f8
        /// JPEG HuffSymb tables
        pub const HUFFBASE26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1f8);

        /// address: 0x500511fc
        /// JPEG HuffSymb tables
        pub const HUFFBASE27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1fc);

        /// address: 0x50051200
        /// JPEG HuffSymb tables
        pub const HUFFBASE28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x200);

        /// address: 0x50051204
        /// JPEG HuffSymb tables
        pub const HUFFBASE29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x204);

        /// address: 0x50051208
        /// JPEG HuffSymb tables
        pub const HUFFBASE30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x208);

        /// address: 0x5005120c
        /// JPEG HuffSymb tables
        pub const HUFFBASE31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HuffBase RAM
            HuffBase_RAM_0: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// HuffBase RAM
            HuffBase_RAM_1: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x20c);

        /// address: 0x50051210
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x210);

        /// address: 0x50051214
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x214);

        /// address: 0x50051218
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x218);

        /// address: 0x5005121c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x21c);

        /// address: 0x50051220
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x220);

        /// address: 0x50051224
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x224);

        /// address: 0x50051228
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x228);

        /// address: 0x5005122c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x22c);

        /// address: 0x50051230
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x230);

        /// address: 0x50051234
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x234);

        /// address: 0x50051238
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x238);

        /// address: 0x5005123c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x23c);

        /// address: 0x50051240
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x240);

        /// address: 0x50051244
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x244);

        /// address: 0x50051248
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x248);

        /// address: 0x5005124c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x24c);

        /// address: 0x50051250
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x250);

        /// address: 0x50051254
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x254);

        /// address: 0x50051258
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x258);

        /// address: 0x5005125c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x25c);

        /// address: 0x50051260
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x260);

        /// address: 0x50051264
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x264);

        /// address: 0x50051268
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x268);

        /// address: 0x5005126c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x26c);

        /// address: 0x50051270
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x270);

        /// address: 0x50051274
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x274);

        /// address: 0x50051278
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x278);

        /// address: 0x5005127c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x27c);

        /// address: 0x50051280
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x280);

        /// address: 0x50051284
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x284);

        /// address: 0x50051288
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x288);

        /// address: 0x5005128c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x28c);

        /// address: 0x50051290
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB32 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x290);

        /// address: 0x50051294
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB33 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x294);

        /// address: 0x50051298
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB34 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x298);

        /// address: 0x5005129c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB35 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x29c);

        /// address: 0x500512a0
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB36 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2a0);

        /// address: 0x500512a4
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB37 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2a4);

        /// address: 0x500512a8
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB38 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2a8);

        /// address: 0x500512ac
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB39 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2ac);

        /// address: 0x500512b0
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB40 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2b0);

        /// address: 0x500512b4
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB41 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2b4);

        /// address: 0x500512b8
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB42 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2b8);

        /// address: 0x500512bc
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB43 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2bc);

        /// address: 0x500512c0
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB44 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2c0);

        /// address: 0x500512c4
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2c4);

        /// address: 0x500512c8
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB46 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2c8);

        /// address: 0x500512cc
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB47 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2cc);

        /// address: 0x500512d0
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB48 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2d0);

        /// address: 0x500512d4
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB49 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2d4);

        /// address: 0x500512d8
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB50 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2d8);

        /// address: 0x500512dc
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB51 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2dc);

        /// address: 0x500512e0
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB52 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2e0);

        /// address: 0x500512e4
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB53 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2e4);

        /// address: 0x500512e8
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB54 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2e8);

        /// address: 0x500512ec
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2ec);

        /// address: 0x500512f0
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB56 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2f0);

        /// address: 0x500512f4
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB57 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2f4);

        /// address: 0x500512f8
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB58 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2f8);

        /// address: 0x500512fc
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB59 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x2fc);

        /// address: 0x50051300
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB60 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x300);

        /// address: 0x50051304
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB61 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x304);

        /// address: 0x50051308
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB62 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x308);

        /// address: 0x5005130c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB63 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x30c);

        /// address: 0x50051310
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB64 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x310);

        /// address: 0x50051314
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB65 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x314);

        /// address: 0x50051318
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB66 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x318);

        /// address: 0x5005131c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x31c);

        /// address: 0x50051320
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB68 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x320);

        /// address: 0x50051324
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB69 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x324);

        /// address: 0x50051328
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB70 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x328);

        /// address: 0x5005132c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB71 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x32c);

        /// address: 0x50051330
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB72 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x330);

        /// address: 0x50051334
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB73 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x334);

        /// address: 0x50051338
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB74 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x338);

        /// address: 0x5005133c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB75 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x33c);

        /// address: 0x50051340
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB76 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x340);

        /// address: 0x50051344
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB77 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x344);

        /// address: 0x50051348
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB78 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x348);

        /// address: 0x5005134c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB79 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x34c);

        /// address: 0x50051350
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB80 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x350);

        /// address: 0x50051354
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB81 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x354);

        /// address: 0x50051358
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB82 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x358);

        /// address: 0x5005135c
        /// JPEG HUFFSYMB tables
        pub const HUFFSYMB83 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTSymb RAM
            HuffSymb_RAM: u32,
        }), base_address + 0x35c);

        /// address: 0x50051360
        /// JPEG DHTMem tables
        pub const DHTMEM0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x360);

        /// address: 0x50051364
        /// JPEG DHTMem tables
        pub const DHTMEM2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x364);

        /// address: 0x50051368
        /// JPEG DHTMem tables
        pub const DHTMEM3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x368);

        /// address: 0x5005136c
        /// JPEG DHTMem tables
        pub const DHTMEM4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x36c);

        /// address: 0x50051370
        /// JPEG DHTMem tables
        pub const DHTMEM5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x370);

        /// address: 0x50051374
        /// JPEG DHTMem tables
        pub const DHTMEM6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x374);

        /// address: 0x50051378
        /// JPEG DHTMem tables
        pub const DHTMEM7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x378);

        /// address: 0x5005137c
        /// JPEG DHTMem tables
        pub const DHTMEM8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x37c);

        /// address: 0x50051380
        /// JPEG DHTMem tables
        pub const DHTMEM9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x380);

        /// address: 0x50051384
        /// JPEG DHTMem tables
        pub const DHTMEM10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x384);

        /// address: 0x50051388
        /// JPEG DHTMem tables
        pub const DHTMEM11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x388);

        /// address: 0x5005138c
        /// JPEG DHTMem tables
        pub const DHTMEM12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x38c);

        /// address: 0x50051390
        /// JPEG DHTMem tables
        pub const DHTMEM13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x390);

        /// address: 0x50051394
        /// JPEG DHTMem tables
        pub const DHTMEM14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x394);

        /// address: 0x50051398
        /// JPEG DHTMem tables
        pub const DHTMEM15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x398);

        /// address: 0x5005139c
        /// JPEG DHTMem tables
        pub const DHTMEM16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x39c);

        /// address: 0x500513a0
        /// JPEG DHTMem tables
        pub const DHTMEM17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3a0);

        /// address: 0x500513a4
        /// JPEG DHTMem tables
        pub const DHTMEM18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3a4);

        /// address: 0x500513a8
        /// JPEG DHTMem tables
        pub const DHTMEM19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3a8);

        /// address: 0x500513ac
        /// JPEG DHTMem tables
        pub const DHTMEM20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3ac);

        /// address: 0x500513b0
        /// JPEG DHTMem tables
        pub const DHTMEM21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3b0);

        /// address: 0x500513b4
        /// JPEG DHTMem tables
        pub const DHTMEM22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3b4);

        /// address: 0x500513b8
        /// JPEG DHTMem tables
        pub const DHTMEM23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3b8);

        /// address: 0x500513bc
        /// JPEG DHTMem tables
        pub const DHTMEM24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3bc);

        /// address: 0x500513c0
        /// JPEG DHTMem tables
        pub const DHTMEM25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3c0);

        /// address: 0x500513c4
        /// JPEG DHTMem tables
        pub const DHTMEM26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3c4);

        /// address: 0x500513c8
        /// JPEG DHTMem tables
        pub const DHTMEM27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3c8);

        /// address: 0x500513cc
        /// JPEG DHTMem tables
        pub const DHTMEM28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3cc);

        /// address: 0x500513d0
        /// JPEG DHTMem tables
        pub const DHTMEM29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3d0);

        /// address: 0x500513d4
        /// JPEG DHTMem tables
        pub const DHTMEM30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3d4);

        /// address: 0x500513d8
        /// JPEG DHTMem tables
        pub const DHTMEM31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3d8);

        /// address: 0x500513dc
        /// JPEG DHTMem tables
        pub const DHTMEM32 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3dc);

        /// address: 0x500513e0
        /// JPEG DHTMem tables
        pub const DHTMEM33 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3e0);

        /// address: 0x500513e4
        /// JPEG DHTMem tables
        pub const DHTMEM34 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3e4);

        /// address: 0x500513e8
        /// JPEG DHTMem tables
        pub const DHTMEM35 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3e8);

        /// address: 0x500513ec
        /// JPEG DHTMem tables
        pub const DHTMEM36 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3ec);

        /// address: 0x500513f0
        /// JPEG DHTMem tables
        pub const DHTMEM37 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3f0);

        /// address: 0x500513f4
        /// JPEG DHTMem tables
        pub const DHTMEM38 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3f4);

        /// address: 0x500513f8
        /// JPEG DHTMem tables
        pub const DHTMEM39 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3f8);

        /// address: 0x500513fc
        /// JPEG DHTMem tables
        pub const DHTMEM40 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x3fc);

        /// address: 0x50051400
        /// JPEG DHTMem tables
        pub const DHTMEM41 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x400);

        /// address: 0x50051404
        /// JPEG DHTMem tables
        pub const DHTMEM42 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x404);

        /// address: 0x50051408
        /// JPEG DHTMem tables
        pub const DHTMEM43 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x408);

        /// address: 0x5005140c
        /// JPEG DHTMem tables
        pub const DHTMEM44 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x40c);

        /// address: 0x50051410
        /// JPEG DHTMem tables
        pub const DHTMEM45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x410);

        /// address: 0x50051414
        /// JPEG DHTMem tables
        pub const DHTMEM46 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x414);

        /// address: 0x50051418
        /// JPEG DHTMem tables
        pub const DHTMEM47 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x418);

        /// address: 0x5005141c
        /// JPEG DHTMem tables
        pub const DHTMEM48 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x41c);

        /// address: 0x50051420
        /// JPEG DHTMem tables
        pub const DHTMEM49 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x420);

        /// address: 0x50051424
        /// JPEG DHTMem tables
        pub const DHTMEM50 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x424);

        /// address: 0x50051428
        /// JPEG DHTMem tables
        pub const DHTMEM51 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x428);

        /// address: 0x5005142c
        /// JPEG DHTMem tables
        pub const DHTMEM52 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x42c);

        /// address: 0x50051430
        /// JPEG DHTMem tables
        pub const DHTMEM53 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x430);

        /// address: 0x50051434
        /// JPEG DHTMem tables
        pub const DHTMEM54 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x434);

        /// address: 0x50051438
        /// JPEG DHTMem tables
        pub const DHTMEM55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x438);

        /// address: 0x5005143c
        /// JPEG DHTMem tables
        pub const DHTMEM56 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x43c);

        /// address: 0x50051440
        /// JPEG DHTMem tables
        pub const DHTMEM57 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x440);

        /// address: 0x50051444
        /// JPEG DHTMem tables
        pub const DHTMEM58 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x444);

        /// address: 0x50051448
        /// JPEG DHTMem tables
        pub const DHTMEM59 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x448);

        /// address: 0x5005144c
        /// JPEG DHTMem tables
        pub const DHTMEM60 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x44c);

        /// address: 0x50051450
        /// JPEG DHTMem tables
        pub const DHTMEM61 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x450);

        /// address: 0x50051454
        /// JPEG DHTMem tables
        pub const DHTMEM62 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x454);

        /// address: 0x50051458
        /// JPEG DHTMem tables
        pub const DHTMEM63 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x458);

        /// address: 0x5005145c
        /// JPEG DHTMem tables
        pub const DHTMEM64 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x45c);

        /// address: 0x50051460
        /// JPEG DHTMem tables
        pub const DHTMEM65 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x460);

        /// address: 0x50051464
        /// JPEG DHTMem tables
        pub const DHTMEM66 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x464);

        /// address: 0x50051468
        /// JPEG DHTMem tables
        pub const DHTMEM67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x468);

        /// address: 0x5005146c
        /// JPEG DHTMem tables
        pub const DHTMEM68 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x46c);

        /// address: 0x50051470
        /// JPEG DHTMem tables
        pub const DHTMEM69 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x470);

        /// address: 0x50051474
        /// JPEG DHTMem tables
        pub const DHTMEM70 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x474);

        /// address: 0x50051478
        /// JPEG DHTMem tables
        pub const DHTMEM71 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x478);

        /// address: 0x5005147c
        /// JPEG DHTMem tables
        pub const DHTMEM72 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x47c);

        /// address: 0x50051480
        /// JPEG DHTMem tables
        pub const DHTMEM73 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x480);

        /// address: 0x50051484
        /// JPEG DHTMem tables
        pub const DHTMEM74 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x484);

        /// address: 0x50051488
        /// JPEG DHTMem tables
        pub const DHTMEM75 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x488);

        /// address: 0x5005148c
        /// JPEG DHTMem tables
        pub const DHTMEM76 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x48c);

        /// address: 0x50051490
        /// JPEG DHTMem tables
        pub const DHTMEM77 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x490);

        /// address: 0x50051494
        /// JPEG DHTMem tables
        pub const DHTMEM78 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x494);

        /// address: 0x50051498
        /// JPEG DHTMem tables
        pub const DHTMEM79 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x498);

        /// address: 0x5005149c
        /// JPEG DHTMem tables
        pub const DHTMEM80 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x49c);

        /// address: 0x500514a0
        /// JPEG DHTMem tables
        pub const DHTMEM81 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4a0);

        /// address: 0x500514a4
        /// JPEG DHTMem tables
        pub const DHTMEM82 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4a4);

        /// address: 0x500514a8
        /// JPEG DHTMem tables
        pub const DHTMEM83 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4a8);

        /// address: 0x500514ac
        /// JPEG DHTMem tables
        pub const DHTMEM84 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4ac);

        /// address: 0x500514b0
        /// JPEG DHTMem tables
        pub const DHTMEM85 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4b0);

        /// address: 0x500514b4
        /// JPEG DHTMem tables
        pub const DHTMEM86 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4b4);

        /// address: 0x500514b8
        /// JPEG DHTMem tables
        pub const DHTMEM87 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4b8);

        /// address: 0x500514bc
        /// JPEG DHTMem tables
        pub const DHTMEM88 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4bc);

        /// address: 0x500514c0
        /// JPEG DHTMem tables
        pub const DHTMEM89 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4c0);

        /// address: 0x500514c4
        /// JPEG DHTMem tables
        pub const DHTMEM90 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4c4);

        /// address: 0x500514c8
        /// JPEG DHTMem tables
        pub const DHTMEM91 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4c8);

        /// address: 0x500514cc
        /// JPEG DHTMem tables
        pub const DHTMEM92 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4cc);

        /// address: 0x500514d0
        /// JPEG DHTMem tables
        pub const DHTMEM93 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4d0);

        /// address: 0x500514d4
        /// JPEG DHTMem tables
        pub const DHTMEM94 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4d4);

        /// address: 0x500514d8
        /// JPEG DHTMem tables
        pub const DHTMEM95 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4d8);

        /// address: 0x500514dc
        /// JPEG DHTMem tables
        pub const DHTMEM96 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4dc);

        /// address: 0x500514e0
        /// JPEG DHTMem tables
        pub const DHTMEM97 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4e0);

        /// address: 0x500514e4
        /// JPEG DHTMem tables
        pub const DHTMEM98 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4e4);

        /// address: 0x500514e8
        /// JPEG DHTMem tables
        pub const DHTMEM99 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4e8);

        /// address: 0x500514ec
        /// JPEG DHTMem tables
        pub const DHTMEM100 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4ec);

        /// address: 0x500514f0
        /// JPEG DHTMem tables
        pub const DHTMEM101 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4f0);

        /// address: 0x500514f4
        /// JPEG DHTMem tables
        pub const DHTMEM102 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4f4);

        /// address: 0x500514f8
        /// JPEG DHTMem tables
        pub const DHTMEM103 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x4f8);

        /// address: 0x50051500
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x500);

        /// address: 0x50051504
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x504);

        /// address: 0x50051508
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x508);

        /// address: 0x5005150c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x50c);

        /// address: 0x50051510
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x510);

        /// address: 0x50051514
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x514);

        /// address: 0x50051518
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x518);

        /// address: 0x5005151c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x51c);

        /// address: 0x50051520
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x520);

        /// address: 0x50051524
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x524);

        /// address: 0x50051528
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x528);

        /// address: 0x5005152c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x52c);

        /// address: 0x50051530
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x530);

        /// address: 0x50051534
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x534);

        /// address: 0x50051538
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x538);

        /// address: 0x5005153c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x53c);

        /// address: 0x50051540
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x540);

        /// address: 0x50051544
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x544);

        /// address: 0x50051548
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x548);

        /// address: 0x5005154c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x54c);

        /// address: 0x50051550
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x550);

        /// address: 0x50051554
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x554);

        /// address: 0x50051558
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x558);

        /// address: 0x5005155c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x55c);

        /// address: 0x50051560
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x560);

        /// address: 0x50051564
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x564);

        /// address: 0x50051568
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x568);

        /// address: 0x5005156c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x56c);

        /// address: 0x50051570
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x570);

        /// address: 0x50051574
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x574);

        /// address: 0x50051578
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x578);

        /// address: 0x5005157c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x57c);

        /// address: 0x50051580
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_32 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x580);

        /// address: 0x50051584
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_33 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x584);

        /// address: 0x50051588
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_34 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x588);

        /// address: 0x5005158c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_35 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x58c);

        /// address: 0x50051590
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_36 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x590);

        /// address: 0x50051594
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_37 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x594);

        /// address: 0x50051598
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_38 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x598);

        /// address: 0x5005159c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_39 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x59c);

        /// address: 0x500515a0
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_40 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5a0);

        /// address: 0x500515a4
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_41 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5a4);

        /// address: 0x500515a8
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_42 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5a8);

        /// address: 0x500515ac
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_43 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5ac);

        /// address: 0x500515b0
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_44 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5b0);

        /// address: 0x500515b4
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5b4);

        /// address: 0x500515b8
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_46 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5b8);

        /// address: 0x500515bc
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_47 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5bc);

        /// address: 0x500515c0
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_48 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5c0);

        /// address: 0x500515c4
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_49 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5c4);

        /// address: 0x500515c8
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_50 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5c8);

        /// address: 0x500515cc
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_51 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5cc);

        /// address: 0x500515d0
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_52 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5d0);

        /// address: 0x500515d4
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_53 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5d4);

        /// address: 0x500515d8
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_54 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5d8);

        /// address: 0x500515dc
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5dc);

        /// address: 0x500515e0
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_56 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5e0);

        /// address: 0x500515e4
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_57 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5e4);

        /// address: 0x500515e8
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_58 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5e8);

        /// address: 0x500515ec
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_59 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5ec);

        /// address: 0x500515f0
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_60 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5f0);

        /// address: 0x500515f4
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_61 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5f4);

        /// address: 0x500515f8
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_62 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5f8);

        /// address: 0x500515fc
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_63 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x5fc);

        /// address: 0x50051600
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_64 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x600);

        /// address: 0x50051604
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_65 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x604);

        /// address: 0x50051608
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_66 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x608);

        /// address: 0x5005160c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x60c);

        /// address: 0x50051610
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_68 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x610);

        /// address: 0x50051614
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_69 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x614);

        /// address: 0x50051618
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_70 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x618);

        /// address: 0x5005161c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_71 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x61c);

        /// address: 0x50051620
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_72 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x620);

        /// address: 0x50051624
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_73 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x624);

        /// address: 0x50051628
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_74 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x628);

        /// address: 0x5005162c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_75 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x62c);

        /// address: 0x50051630
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_76 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x630);

        /// address: 0x50051634
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_77 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x634);

        /// address: 0x50051638
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_78 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x638);

        /// address: 0x5005163c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_79 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x63c);

        /// address: 0x50051640
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_80 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x640);

        /// address: 0x50051644
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_81 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x644);

        /// address: 0x50051648
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_82 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x648);

        /// address: 0x5005164c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_83 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x64c);

        /// address: 0x50051650
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_84 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x650);

        /// address: 0x50051654
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_85 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x654);

        /// address: 0x50051658
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_86 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x658);

        /// address: 0x5005165c
        /// JPEG encoder, AC Huffman table
        /// 0
        pub const HUFFENC_AC0_87 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x65c);

        /// address: 0x50051660
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x660);

        /// address: 0x50051664
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x664);

        /// address: 0x50051668
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x668);

        /// address: 0x5005166c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x66c);

        /// address: 0x50051670
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x670);

        /// address: 0x50051674
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x674);

        /// address: 0x50051678
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x678);

        /// address: 0x5005167c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x67c);

        /// address: 0x50051680
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x680);

        /// address: 0x50051684
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x684);

        /// address: 0x50051688
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x688);

        /// address: 0x5005168c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x68c);

        /// address: 0x50051690
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x690);

        /// address: 0x50051694
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x694);

        /// address: 0x50051698
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x698);

        /// address: 0x5005169c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x69c);

        /// address: 0x500516a0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6a0);

        /// address: 0x500516a4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6a4);

        /// address: 0x500516a8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6a8);

        /// address: 0x500516ac
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6ac);

        /// address: 0x500516b0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6b0);

        /// address: 0x500516b4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6b4);

        /// address: 0x500516b8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6b8);

        /// address: 0x500516bc
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6bc);

        /// address: 0x500516c0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6c0);

        /// address: 0x500516c4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6c4);

        /// address: 0x500516c8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6c8);

        /// address: 0x500516cc
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6cc);

        /// address: 0x500516d0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6d0);

        /// address: 0x500516d4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6d4);

        /// address: 0x500516d8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6d8);

        /// address: 0x500516dc
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6dc);

        /// address: 0x500516e0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_32 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6e0);

        /// address: 0x500516e4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_33 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6e4);

        /// address: 0x500516e8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_34 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6e8);

        /// address: 0x500516ec
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_35 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6ec);

        /// address: 0x500516f0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_36 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6f0);

        /// address: 0x500516f4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_37 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6f4);

        /// address: 0x500516f8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_38 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6f8);

        /// address: 0x500516fc
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_39 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x6fc);

        /// address: 0x50051700
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_40 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x700);

        /// address: 0x50051704
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_41 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x704);

        /// address: 0x50051708
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_42 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x708);

        /// address: 0x5005170c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_43 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x70c);

        /// address: 0x50051710
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_44 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x710);

        /// address: 0x50051714
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x714);

        /// address: 0x50051718
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_46 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x718);

        /// address: 0x5005171c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_47 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x71c);

        /// address: 0x50051720
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_48 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x720);

        /// address: 0x50051724
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_49 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x724);

        /// address: 0x50051728
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_50 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x728);

        /// address: 0x5005172c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_51 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x72c);

        /// address: 0x50051730
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_52 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x730);

        /// address: 0x50051734
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_53 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x734);

        /// address: 0x50051738
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_54 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x738);

        /// address: 0x5005173c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x73c);

        /// address: 0x50051740
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_56 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x740);

        /// address: 0x50051744
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_57 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x744);

        /// address: 0x50051748
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_58 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x748);

        /// address: 0x5005174c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_59 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x74c);

        /// address: 0x50051750
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_60 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x750);

        /// address: 0x50051754
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_61 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x754);

        /// address: 0x50051758
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_62 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x758);

        /// address: 0x5005175c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_63 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x75c);

        /// address: 0x50051760
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_64 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x760);

        /// address: 0x50051764
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_65 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x764);

        /// address: 0x50051768
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_66 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x768);

        /// address: 0x5005176c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x76c);

        /// address: 0x50051770
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_68 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x770);

        /// address: 0x50051774
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_69 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x774);

        /// address: 0x50051778
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_70 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x778);

        /// address: 0x5005177c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_71 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x77c);

        /// address: 0x50051780
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_72 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x780);

        /// address: 0x50051784
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_73 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x784);

        /// address: 0x50051788
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_74 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x788);

        /// address: 0x5005178c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_75 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x78c);

        /// address: 0x50051790
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_76 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x790);

        /// address: 0x50051794
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_77 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x794);

        /// address: 0x50051798
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_78 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x798);

        /// address: 0x5005179c
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_79 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x79c);

        /// address: 0x500517a0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_80 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7a0);

        /// address: 0x500517a4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_81 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7a4);

        /// address: 0x500517a8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_82 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7a8);

        /// address: 0x500517ac
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_83 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7ac);

        /// address: 0x500517b0
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_84 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7b0);

        /// address: 0x500517b4
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_85 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7b4);

        /// address: 0x500517b8
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_86 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7b8);

        /// address: 0x500517bc
        /// JPEG encoder, AC Huffman table
        /// 1
        pub const HUFFENC_AC1_87 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7bc);

        /// address: 0x500517c0
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7c0);

        /// address: 0x500517c4
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7c4);

        /// address: 0x500517c8
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7c8);

        /// address: 0x500517cc
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7cc);

        /// address: 0x500517d0
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7d0);

        /// address: 0x500517d4
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7d4);

        /// address: 0x500517d8
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7d8);

        /// address: 0x500517dc
        /// JPEG encoder, DC Huffman table
        /// 0
        pub const HUFFENC_DC0_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7dc);

        /// address: 0x500517e0
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7e0);

        /// address: 0x500517e4
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7e4);

        /// address: 0x500517e8
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7e8);

        /// address: 0x500517ec
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7ec);

        /// address: 0x500517f0
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7f0);

        /// address: 0x500517f4
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7f4);

        /// address: 0x500517f8
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7f8);

        /// address: 0x500517fc
        /// JPEG encoder, DC Huffman table
        /// 1
        pub const HUFFENC_DC1_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DHTMem RAM
            DHTMem_RAM: u32,
        }), base_address + 0x7fc);
    };

    /// Ethernet: MAC management counters
    pub const Ethernet_MMC = struct {
        pub const base_address = 0x40028100;

        /// address: 0x40028100
        /// Ethernet MMC control register
        pub const MMCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CR
            CR: u1,
            /// CSR
            CSR: u1,
            /// ROR
            ROR: u1,
            /// MCF
            MCF: u1,
            /// MCP
            MCP: u1,
            /// MCFHP
            MCFHP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);

        /// address: 0x40028104
        /// Ethernet MMC receive interrupt
        /// register
        pub const MMCRIR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// RFCES
            RFCES: u1,
            /// RFAES
            RFAES: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// RGUFS
            RGUFS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x4);

        /// address: 0x40028108
        /// Ethernet MMC transmit interrupt
        /// register
        pub const MMCTIR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// TGFSCS
            TGFSCS: u1,
            /// TGFMSCS
            TGFMSCS: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// TGFS
            TGFS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x4002810c
        /// Ethernet MMC receive interrupt mask
        /// register
        pub const MMCRIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// RFCEM
            RFCEM: u1,
            /// RFAEM
            RFAEM: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// RGUFM
            RGUFM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xc);

        /// address: 0x40028110
        /// Ethernet MMC transmit interrupt mask
        /// register
        pub const MMCTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// TGFSCM
            TGFSCM: u1,
            /// TGFMSCM
            TGFMSCM: u1,
            /// TGFM
            TGFM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x10);

        /// address: 0x4002814c
        /// Ethernet MMC transmitted good frames after a
        /// single collision counter
        pub const MMCTGFSCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TGFSCC
            TGFSCC: u32,
        }), base_address + 0x4c);

        /// address: 0x40028150
        /// Ethernet MMC transmitted good frames after
        /// more than a single collision
        pub const MMCTGFMSCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TGFMSCC
            TGFMSCC: u32,
        }), base_address + 0x50);

        /// address: 0x40028168
        /// Ethernet MMC transmitted good frames counter
        /// register
        pub const MMCTGFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HTL
            TGFC: u32,
        }), base_address + 0x68);

        /// address: 0x40028194
        /// Ethernet MMC received frames with CRC error
        /// counter register
        pub const MMCRFCECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RFCFC
            RFCFC: u32,
        }), base_address + 0x94);

        /// address: 0x40028198
        /// Ethernet MMC received frames with alignment
        /// error counter register
        pub const MMCRFAECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RFAEC
            RFAEC: u32,
        }), base_address + 0x98);

        /// address: 0x400281c4
        /// MMC received good unicast frames counter
        /// register
        pub const MMCRGUFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RGUFC
            RGUFC: u32,
        }), base_address + 0xc4);
    };

    /// Ethernet: Precision time protocol
    pub const Ethernet_PTP = struct {
        pub const base_address = 0x40028700;

        /// address: 0x40028700
        /// Ethernet PTP time stamp control
        /// register
        pub const PTPTSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TSE
            TSE: u1,
            /// TSFCU
            TSFCU: u1,
            /// TSSTI
            TSSTI: u1,
            /// TSSTU
            TSSTU: u1,
            /// TSITE
            TSITE: u1,
            /// TTSARU
            TTSARU: u1,
            reserved0: u1,
            reserved1: u1,
            /// TSSARFE
            TSSARFE: u1,
            /// TSSSR
            TSSSR: u1,
            /// TSPTPPSV2E
            TSPTPPSV2E: u1,
            /// TSSPTPOEFE
            TSSPTPOEFE: u1,
            /// TSSIPV6FE
            TSSIPV6FE: u1,
            /// TSSIPV4FE
            TSSIPV4FE: u1,
            /// TSSEME
            TSSEME: u1,
            /// TSSMRME
            TSSMRME: u1,
            /// TSCNT
            TSCNT: u2,
            /// TSPFFMAE
            TSPFFMAE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x0);

        /// address: 0x40028704
        /// Ethernet PTP subsecond increment
        /// register
        pub const PTPSSIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// STSSI
            STSSI: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40028708
        /// Ethernet PTP time stamp high
        /// register
        pub const PTPTSHR = @intToPtr(*volatile Mmio(32, packed struct {
            /// STS
            STS: u32,
        }), base_address + 0x8);

        /// address: 0x4002870c
        /// Ethernet PTP time stamp low
        /// register
        pub const PTPTSLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// STSS
            STSS: u31,
            /// STPNS
            STPNS: u1,
        }), base_address + 0xc);

        /// address: 0x40028710
        /// Ethernet PTP time stamp high update
        /// register
        pub const PTPTSHUR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TSUS
            TSUS: u32,
        }), base_address + 0x10);

        /// address: 0x40028714
        /// Ethernet PTP time stamp low update
        /// register
        pub const PTPTSLUR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TSUSS
            TSUSS: u31,
            /// TSUPNS
            TSUPNS: u1,
        }), base_address + 0x14);

        /// address: 0x40028718
        /// Ethernet PTP time stamp addend
        /// register
        pub const PTPTSAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TSA
            TSA: u32,
        }), base_address + 0x18);

        /// address: 0x4002871c
        /// Ethernet PTP target time high
        /// register
        pub const PTPTTHR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0
            TTSH: u32,
        }), base_address + 0x1c);

        /// address: 0x40028720
        /// Ethernet PTP target time low
        /// register
        pub const PTPTTLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TTSL
            TTSL: u32,
        }), base_address + 0x20);

        /// address: 0x40028728
        /// Ethernet PTP time stamp status
        /// register
        pub const PTPTSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TSSO
            TSSO: u1,
            /// TSTTR
            TSTTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x28);

        /// address: 0x4002872c
        /// Ethernet PTP PPS control
        /// register
        pub const PTPPPSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TSSO
            TSSO: u1,
            /// TSTTR
            TSTTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x2c);
    };

    /// Ethernet: DMA controller operation
    pub const Ethernet_DMA = struct {
        pub const base_address = 0x40029000;

        /// address: 0x40029000
        /// Ethernet DMA bus mode register
        pub const DMABMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SR
            SR: u1,
            /// DA
            DA: u1,
            /// DSL
            DSL: u5,
            /// EDFE
            EDFE: u1,
            /// PBL
            PBL: u6,
            /// RTPR
            RTPR: u2,
            /// FB
            FB: u1,
            /// RDP
            RDP: u6,
            /// USP
            USP: u1,
            /// FPM
            FPM: u1,
            /// AAB
            AAB: u1,
            /// MB
            MB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x0);

        /// address: 0x40029004
        /// Ethernet DMA transmit poll demand
        /// register
        pub const DMATPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TPD
            TPD: u32,
        }), base_address + 0x4);

        /// address: 0x40029008
        /// EHERNET DMA receive poll demand
        /// register
        pub const DMARPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RPD
            RPD: u32,
        }), base_address + 0x8);

        /// address: 0x4002900c
        /// Ethernet DMA receive descriptor list address
        /// register
        pub const DMARDLAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SRL
            SRL: u32,
        }), base_address + 0xc);

        /// address: 0x40029010
        /// Ethernet DMA transmit descriptor list
        /// address register
        pub const DMATDLAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// STL
            STL: u32,
        }), base_address + 0x10);

        /// address: 0x40029014
        /// Ethernet DMA status register
        pub const DMASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TS
            TS: u1,
            /// TPSS
            TPSS: u1,
            /// TBUS
            TBUS: u1,
            /// TJTS
            TJTS: u1,
            /// ROS
            ROS: u1,
            /// TUS
            TUS: u1,
            /// RS
            RS: u1,
            /// RBUS
            RBUS: u1,
            /// RPSS
            RPSS: u1,
            /// PWTS
            PWTS: u1,
            /// ETS
            ETS: u1,
            reserved0: u1,
            reserved1: u1,
            /// FBES
            FBES: u1,
            /// ERS
            ERS: u1,
            /// AIS
            AIS: u1,
            /// NIS
            NIS: u1,
            /// RPS
            RPS: u3,
            /// TPS
            TPS: u3,
            /// EBS
            EBS: u3,
            reserved2: u1,
            /// MMCS
            MMCS: u1,
            /// PMTS
            PMTS: u1,
            /// TSTS
            TSTS: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x40029018
        /// Ethernet DMA operation mode
        /// register
        pub const DMAOMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// SR
            SR: u1,
            /// OSF
            OSF: u1,
            /// RTC
            RTC: u2,
            reserved1: u1,
            /// FUGF
            FUGF: u1,
            /// FEF
            FEF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ST
            ST: u1,
            /// TTC
            TTC: u3,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// FTF
            FTF: u1,
            /// TSF
            TSF: u1,
            reserved10: u1,
            reserved11: u1,
            /// DFRF
            DFRF: u1,
            /// RSF
            RSF: u1,
            /// DTCEFD
            DTCEFD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x4002901c
        /// Ethernet DMA interrupt enable
        /// register
        pub const DMAIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIE
            TIE: u1,
            /// TPSIE
            TPSIE: u1,
            /// TBUIE
            TBUIE: u1,
            /// TJTIE
            TJTIE: u1,
            /// ROIE
            ROIE: u1,
            /// TUIE
            TUIE: u1,
            /// RIE
            RIE: u1,
            /// RBUIE
            RBUIE: u1,
            /// RPSIE
            RPSIE: u1,
            /// RWTIE
            RWTIE: u1,
            /// ETIE
            ETIE: u1,
            reserved0: u1,
            reserved1: u1,
            /// FBEIE
            FBEIE: u1,
            /// ERIE
            ERIE: u1,
            /// AISE
            AISE: u1,
            /// NISE
            NISE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x40029020
        /// Ethernet DMA missed frame and buffer
        /// overflow counter register
        pub const DMAMFBOCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MFC
            MFC: u16,
            /// OMFC
            OMFC: u1,
            /// MFA
            MFA: u11,
            /// OFOC
            OFOC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x20);

        /// address: 0x40029024
        /// Ethernet DMA receive status watchdog timer
        /// register
        pub const DMARSWTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RSWTC
            RSWTC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40029048
        /// Ethernet DMA current host transmit
        /// descriptor register
        pub const DMACHTDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HTDAP
            HTDAP: u32,
        }), base_address + 0x48);

        /// address: 0x4002904c
        /// Ethernet DMA current host receive descriptor
        /// register
        pub const DMACHRDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HRDAP
            HRDAP: u32,
        }), base_address + 0x4c);

        /// address: 0x40029050
        /// Ethernet DMA current host transmit buffer
        /// address register
        pub const DMACHTBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HTBAP
            HTBAP: u32,
        }), base_address + 0x50);

        /// address: 0x40029054
        /// Ethernet DMA current host receive buffer
        /// address register
        pub const DMACHRBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HRBAP
            HRBAP: u32,
        }), base_address + 0x54);
    };

    /// USB on the go full speed
    pub const OTG_FS_HOST = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// OTG_FS host configuration register
        /// (OTG_FS_HCFG)
        pub const OTG_FS_HCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FS/LS PHY clock select
            FSLSPCS: u2,
            /// FS- and LS-only support
            FSLSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x50000404
        /// OTG_FS Host frame interval
        /// register
        pub const OTG_FS_HFIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame interval
            FRIVL: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000408
        /// OTG_FS host frame number/frame time
        /// remaining register (OTG_FS_HFNUM)
        pub const OTG_FS_HFNUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FRNUM: u16,
            /// Frame time remaining
            FTREM: u16,
        }), base_address + 0x8);

        /// address: 0x50000410
        /// OTG_FS_Host periodic transmit FIFO/queue
        /// status register (OTG_FS_HPTXSTS)
        pub const OTG_FS_HPTXSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Periodic transmit data FIFO space
            /// available
            PTXFSAVL: u16,
            /// Periodic transmit request queue space
            /// available
            PTXQSAV: u8,
            /// Top of the periodic transmit request
            /// queue
            PTXQTOP: u8,
        }), base_address + 0x10);

        /// address: 0x50000414
        /// OTG_FS Host all channels interrupt
        /// register
        pub const OTG_FS_HAINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel interrupts
            HAINT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000418
        /// OTG_FS host all channels interrupt mask
        /// register
        pub const OTG_FS_HAINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel interrupt mask
            HAINTM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x50000440
        /// OTG_FS host port control and status register
        /// (OTG_FS_HPRT)
        pub const OTG_FS_HPRT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port connect status
            PCSTS: u1,
            /// Port connect detected
            PCDET: u1,
            /// Port enable
            PENA: u1,
            /// Port enable/disable change
            PENCHNG: u1,
            /// Port overcurrent active
            POCA: u1,
            /// Port overcurrent change
            POCCHNG: u1,
            /// Port resume
            PRES: u1,
            /// Port suspend
            PSUSP: u1,
            /// Port reset
            PRST: u1,
            reserved0: u1,
            /// Port line status
            PLSTS: u2,
            /// Port power
            PPWR: u1,
            /// Port test control
            PTCTL: u4,
            /// Port speed
            PSPD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x40);

        /// address: 0x50000500
        /// OTG_FS host channel-0 characteristics
        /// register (OTG_FS_HCCHAR0)
        pub const OTG_FS_HCCHAR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x100);

        /// address: 0x50000520
        /// OTG_FS host channel-1 characteristics
        /// register (OTG_FS_HCCHAR1)
        pub const OTG_FS_HCCHAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x120);

        /// address: 0x50000540
        /// OTG_FS host channel-2 characteristics
        /// register (OTG_FS_HCCHAR2)
        pub const OTG_FS_HCCHAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x140);

        /// address: 0x50000560
        /// OTG_FS host channel-3 characteristics
        /// register (OTG_FS_HCCHAR3)
        pub const OTG_FS_HCCHAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x160);

        /// address: 0x50000580
        /// OTG_FS host channel-4 characteristics
        /// register (OTG_FS_HCCHAR4)
        pub const OTG_FS_HCCHAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x180);

        /// address: 0x500005a0
        /// OTG_FS host channel-5 characteristics
        /// register (OTG_FS_HCCHAR5)
        pub const OTG_FS_HCCHAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1a0);

        /// address: 0x500005c0
        /// OTG_FS host channel-6 characteristics
        /// register (OTG_FS_HCCHAR6)
        pub const OTG_FS_HCCHAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1c0);

        /// address: 0x500005e0
        /// OTG_FS host channel-7 characteristics
        /// register (OTG_FS_HCCHAR7)
        pub const OTG_FS_HCCHAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1e0);

        /// address: 0x50000508
        /// OTG_FS host channel-0 interrupt register
        /// (OTG_FS_HCINT0)
        pub const OTG_FS_HCINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x108);

        /// address: 0x50000528
        /// OTG_FS host channel-1 interrupt register
        /// (OTG_FS_HCINT1)
        pub const OTG_FS_HCINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x128);

        /// address: 0x50000548
        /// OTG_FS host channel-2 interrupt register
        /// (OTG_FS_HCINT2)
        pub const OTG_FS_HCINT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x148);

        /// address: 0x50000568
        /// OTG_FS host channel-3 interrupt register
        /// (OTG_FS_HCINT3)
        pub const OTG_FS_HCINT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x168);

        /// address: 0x50000588
        /// OTG_FS host channel-4 interrupt register
        /// (OTG_FS_HCINT4)
        pub const OTG_FS_HCINT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x188);

        /// address: 0x500005a8
        /// OTG_FS host channel-5 interrupt register
        /// (OTG_FS_HCINT5)
        pub const OTG_FS_HCINT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1a8);

        /// address: 0x500005c8
        /// OTG_FS host channel-6 interrupt register
        /// (OTG_FS_HCINT6)
        pub const OTG_FS_HCINT6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c8);

        /// address: 0x500005e8
        /// OTG_FS host channel-7 interrupt register
        /// (OTG_FS_HCINT7)
        pub const OTG_FS_HCINT7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1e8);

        /// address: 0x5000050c
        /// OTG_FS host channel-0 mask register
        /// (OTG_FS_HCINTMSK0)
        pub const OTG_FS_HCINTMSK0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10c);

        /// address: 0x5000052c
        /// OTG_FS host channel-1 mask register
        /// (OTG_FS_HCINTMSK1)
        pub const OTG_FS_HCINTMSK1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x12c);

        /// address: 0x5000054c
        /// OTG_FS host channel-2 mask register
        /// (OTG_FS_HCINTMSK2)
        pub const OTG_FS_HCINTMSK2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14c);

        /// address: 0x5000056c
        /// OTG_FS host channel-3 mask register
        /// (OTG_FS_HCINTMSK3)
        pub const OTG_FS_HCINTMSK3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x16c);

        /// address: 0x5000058c
        /// OTG_FS host channel-4 mask register
        /// (OTG_FS_HCINTMSK4)
        pub const OTG_FS_HCINTMSK4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x18c);

        /// address: 0x500005ac
        /// OTG_FS host channel-5 mask register
        /// (OTG_FS_HCINTMSK5)
        pub const OTG_FS_HCINTMSK5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1ac);

        /// address: 0x500005cc
        /// OTG_FS host channel-6 mask register
        /// (OTG_FS_HCINTMSK6)
        pub const OTG_FS_HCINTMSK6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1cc);

        /// address: 0x500005ec
        /// OTG_FS host channel-7 mask register
        /// (OTG_FS_HCINTMSK7)
        pub const OTG_FS_HCINTMSK7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1ec);

        /// address: 0x50000510
        /// OTG_FS host channel-0 transfer size
        /// register
        pub const OTG_FS_HCTSIZ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x110);

        /// address: 0x50000530
        /// OTG_FS host channel-1 transfer size
        /// register
        pub const OTG_FS_HCTSIZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x130);

        /// address: 0x50000550
        /// OTG_FS host channel-2 transfer size
        /// register
        pub const OTG_FS_HCTSIZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x150);

        /// address: 0x50000570
        /// OTG_FS host channel-3 transfer size
        /// register
        pub const OTG_FS_HCTSIZ3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x170);

        /// address: 0x50000590
        /// OTG_FS host channel-x transfer size
        /// register
        pub const OTG_FS_HCTSIZ4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x190);

        /// address: 0x500005b0
        /// OTG_FS host channel-5 transfer size
        /// register
        pub const OTG_FS_HCTSIZ5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1b0);

        /// address: 0x500005d0
        /// OTG_FS host channel-6 transfer size
        /// register
        pub const OTG_FS_HCTSIZ6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1d0);

        /// address: 0x500005f0
        /// OTG_FS host channel-7 transfer size
        /// register
        pub const OTG_FS_HCTSIZ7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1f0);

        /// address: 0x500005f4
        /// OTG_FS host channel-8 characteristics
        /// register
        pub const OTG_FS_HCCHAR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1f4);

        /// address: 0x500005f8
        /// OTG_FS host channel-8 interrupt
        /// register
        pub const OTG_FS_HCINT8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1f8);

        /// address: 0x500005fc
        /// OTG_FS host channel-8 mask
        /// register
        pub const OTG_FS_HCINTMSK8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1fc);

        /// address: 0x50000600
        /// OTG_FS host channel-8 transfer size
        /// register
        pub const OTG_FS_HCTSIZ8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x200);

        /// address: 0x50000604
        /// OTG_FS host channel-9 characteristics
        /// register
        pub const OTG_FS_HCCHAR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x204);

        /// address: 0x50000608
        /// OTG_FS host channel-9 interrupt
        /// register
        pub const OTG_FS_HCINT9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x208);

        /// address: 0x5000060c
        /// OTG_FS host channel-9 mask
        /// register
        pub const OTG_FS_HCINTMSK9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x20c);

        /// address: 0x50000610
        /// OTG_FS host channel-9 transfer size
        /// register
        pub const OTG_FS_HCTSIZ9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x210);

        /// address: 0x50000614
        /// OTG_FS host channel-10 characteristics
        /// register
        pub const OTG_FS_HCCHAR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x214);

        /// address: 0x50000618
        /// OTG_FS host channel-10 interrupt
        /// register
        pub const OTG_FS_HCINT10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x218);

        /// address: 0x5000061c
        /// OTG_FS host channel-10 mask
        /// register
        pub const OTG_FS_HCINTMSK10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x21c);

        /// address: 0x50000620
        /// OTG_FS host channel-10 transfer size
        /// register
        pub const OTG_FS_HCTSIZ10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x220);

        /// address: 0x50000624
        /// OTG_FS host channel-11 characteristics
        /// register
        pub const OTG_FS_HCCHAR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multicount
            MCNT: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x224);

        /// address: 0x50000628
        /// OTG_FS host channel-11 interrupt
        /// register
        pub const OTG_FS_HCINT11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x228);

        /// address: 0x5000062c
        /// OTG_FS host channel-11 mask
        /// register
        pub const OTG_FS_HCINTMSK11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            reserved0: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x22c);

        /// address: 0x50000630
        /// OTG_FS host channel-11 transfer size
        /// register
        pub const OTG_FS_HCTSIZ11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x230);
    };

    /// USB on the go full speed
    pub const OTG_FS_DEVICE = struct {
        pub const base_address = 0x50000800;

        /// address: 0x50000800
        /// OTG_FS device configuration register
        /// (OTG_FS_DCFG)
        pub const OTG_FS_DCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device speed
            DSPD: u2,
            /// Non-zero-length status OUT
            /// handshake
            NZLSOHSK: u1,
            reserved0: u1,
            /// Device address
            DAD: u7,
            /// Periodic frame interval
            PFIVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x50000804
        /// OTG_FS device control register
        /// (OTG_FS_DCTL)
        pub const OTG_FS_DCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remote wakeup signaling
            RWUSIG: u1,
            /// Soft disconnect
            SDIS: u1,
            /// Global IN NAK status
            GINSTS: u1,
            /// Global OUT NAK status
            GONSTS: u1,
            /// Test control
            TCTL: u3,
            /// Set global IN NAK
            SGINAK: u1,
            /// Clear global IN NAK
            CGINAK: u1,
            /// Set global OUT NAK
            SGONAK: u1,
            /// Clear global OUT NAK
            CGONAK: u1,
            /// Power-on programming done
            POPRGDNE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x50000808
        /// OTG_FS device status register
        /// (OTG_FS_DSTS)
        pub const OTG_FS_DSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Suspend status
            SUSPSTS: u1,
            /// Enumerated speed
            ENUMSPD: u2,
            /// Erratic error
            EERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Frame number of the received
            /// SOF
            FNSOF: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x50000810
        /// OTG_FS device IN endpoint common interrupt
        /// mask register (OTG_FS_DIEPMSK)
        pub const OTG_FS_DIEPMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt
            /// mask
            XFRCM: u1,
            /// Endpoint disabled interrupt
            /// mask
            EPDM: u1,
            reserved0: u1,
            /// Timeout condition mask (Non-isochronous
            /// endpoints)
            TOM: u1,
            /// IN token received when TxFIFO empty
            /// mask
            ITTXFEMSK: u1,
            /// IN token received with EP mismatch
            /// mask
            INEPNMM: u1,
            /// IN endpoint NAK effective
            /// mask
            INEPNEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x10);

        /// address: 0x50000814
        /// OTG_FS device OUT endpoint common interrupt
        /// mask register (OTG_FS_DOEPMSK)
        pub const OTG_FS_DOEPMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt
            /// mask
            XFRCM: u1,
            /// Endpoint disabled interrupt
            /// mask
            EPDM: u1,
            reserved0: u1,
            /// SETUP phase done mask
            STUPM: u1,
            /// OUT token received when endpoint
            /// disabled mask
            OTEPDM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x14);

        /// address: 0x50000818
        /// OTG_FS device all endpoints interrupt
        /// register (OTG_FS_DAINT)
        pub const OTG_FS_DAINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint interrupt bits
            IEPINT: u16,
            /// OUT endpoint interrupt
            /// bits
            OEPINT: u16,
        }), base_address + 0x18);

        /// address: 0x5000081c
        /// OTG_FS all endpoints interrupt mask register
        /// (OTG_FS_DAINTMSK)
        pub const OTG_FS_DAINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN EP interrupt mask bits
            IEPM: u16,
            /// OUT endpoint interrupt
            /// bits
            OEPINT: u16,
        }), base_address + 0x1c);

        /// address: 0x50000828
        /// OTG_FS device VBUS discharge time
        /// register
        pub const OTG_FS_DVBUSDIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device VBUS discharge time
            VBUSDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x5000082c
        /// OTG_FS device VBUS pulsing time
        /// register
        pub const OTG_FS_DVBUSPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device VBUS pulsing time
            DVBUSP: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x50000834
        /// OTG_FS device IN endpoint FIFO empty
        /// interrupt mask register
        pub const OTG_FS_DIEPEMPMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN EP Tx FIFO empty interrupt mask
            /// bits
            INEPTXFEM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x50000900
        /// OTG_FS device control IN endpoint 0 control
        /// register (OTG_FS_DIEPCTL0)
        pub const OTG_FS_DIEPCTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// USB active endpoint
            USBAEP: u1,
            reserved13: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved14: u1,
            /// STALL handshake
            STALL: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            reserved15: u1,
            reserved16: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x100);

        /// address: 0x50000920
        /// OTG device endpoint-1 control
        /// register
        pub const OTG_FS_DIEPCTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            reserved4: u1,
            /// Stall
            Stall: u1,
            /// TXFNUM
            TXFNUM: u4,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM/SD1PID
            SODDFRM_SD1PID: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x120);

        /// address: 0x50000940
        /// OTG device endpoint-2 control
        /// register
        pub const OTG_FS_DIEPCTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            reserved4: u1,
            /// Stall
            Stall: u1,
            /// TXFNUM
            TXFNUM: u4,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x140);

        /// address: 0x50000960
        /// OTG device endpoint-3 control
        /// register
        pub const OTG_FS_DIEPCTL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            reserved4: u1,
            /// Stall
            Stall: u1,
            /// TXFNUM
            TXFNUM: u4,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x160);

        /// address: 0x50000b00
        /// device endpoint-0 control
        /// register
        pub const OTG_FS_DOEPCTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// USBAEP
            USBAEP: u1,
            reserved13: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            /// SNPM
            SNPM: u1,
            /// Stall
            Stall: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            reserved18: u1,
            reserved19: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x300);

        /// address: 0x50000b20
        /// device endpoint-1 control
        /// register
        pub const OTG_FS_DOEPCTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            /// SNPM
            SNPM: u1,
            /// Stall
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x320);

        /// address: 0x50000b40
        /// device endpoint-2 control
        /// register
        pub const OTG_FS_DOEPCTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            /// SNPM
            SNPM: u1,
            /// Stall
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x340);

        /// address: 0x50000b60
        /// device endpoint-3 control
        /// register
        pub const OTG_FS_DOEPCTL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            /// SNPM
            SNPM: u1,
            /// Stall
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x360);

        /// address: 0x50000908
        /// device endpoint-x interrupt
        /// register
        pub const OTG_FS_DIEPINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// TOC
            TOC: u1,
            /// ITTXFE
            ITTXFE: u1,
            reserved1: u1,
            /// INEPNE
            INEPNE: u1,
            /// TXFE
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x108);

        /// address: 0x50000928
        /// device endpoint-1 interrupt
        /// register
        pub const OTG_FS_DIEPINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// TOC
            TOC: u1,
            /// ITTXFE
            ITTXFE: u1,
            reserved1: u1,
            /// INEPNE
            INEPNE: u1,
            /// TXFE
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x128);

        /// address: 0x50000948
        /// device endpoint-2 interrupt
        /// register
        pub const OTG_FS_DIEPINT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// TOC
            TOC: u1,
            /// ITTXFE
            ITTXFE: u1,
            reserved1: u1,
            /// INEPNE
            INEPNE: u1,
            /// TXFE
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x148);

        /// address: 0x50000968
        /// device endpoint-3 interrupt
        /// register
        pub const OTG_FS_DIEPINT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// TOC
            TOC: u1,
            /// ITTXFE
            ITTXFE: u1,
            reserved1: u1,
            /// INEPNE
            INEPNE: u1,
            /// TXFE
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x168);

        /// address: 0x50000b08
        /// device endpoint-0 interrupt
        /// register
        pub const OTG_FS_DOEPINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// STUP
            STUP: u1,
            /// OTEPDIS
            OTEPDIS: u1,
            reserved1: u1,
            /// B2BSTUP
            B2BSTUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x308);

        /// address: 0x50000b28
        /// device endpoint-1 interrupt
        /// register
        pub const OTG_FS_DOEPINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// STUP
            STUP: u1,
            /// OTEPDIS
            OTEPDIS: u1,
            reserved1: u1,
            /// B2BSTUP
            B2BSTUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x328);

        /// address: 0x50000b48
        /// device endpoint-2 interrupt
        /// register
        pub const OTG_FS_DOEPINT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// STUP
            STUP: u1,
            /// OTEPDIS
            OTEPDIS: u1,
            reserved1: u1,
            /// B2BSTUP
            B2BSTUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x348);

        /// address: 0x50000b68
        /// device endpoint-3 interrupt
        /// register
        pub const OTG_FS_DOEPINT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// STUP
            STUP: u1,
            /// OTEPDIS
            OTEPDIS: u1,
            reserved1: u1,
            /// B2BSTUP
            B2BSTUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x368);

        /// address: 0x50000910
        /// device endpoint-0 transfer size
        /// register
        pub const OTG_FS_DIEPTSIZ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Packet count
            PKTCNT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x110);

        /// address: 0x50000b10
        /// device OUT endpoint-0 transfer size
        /// register
        pub const OTG_FS_DOEPTSIZ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Packet count
            PKTCNT: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// SETUP packet count
            STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x310);

        /// address: 0x50000930
        /// device endpoint-1 transfer size
        /// register
        pub const OTG_FS_DIEPTSIZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x130);

        /// address: 0x50000950
        /// device endpoint-2 transfer size
        /// register
        pub const OTG_FS_DIEPTSIZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x150);

        /// address: 0x50000970
        /// device endpoint-3 transfer size
        /// register
        pub const OTG_FS_DIEPTSIZ3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x170);

        /// address: 0x50000918
        /// OTG_FS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_FS_DTXFSTS0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// available
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x50000938
        /// OTG_FS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_FS_DTXFSTS1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// available
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x50000958
        /// OTG_FS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_FS_DTXFSTS2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// available
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x158);

        /// address: 0x50000978
        /// OTG_FS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_FS_DTXFSTS3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// available
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x178);

        /// address: 0x50000b30
        /// device OUT endpoint-1 transfer size
        /// register
        pub const OTG_FS_DOEPTSIZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x330);

        /// address: 0x50000b50
        /// device OUT endpoint-2 transfer size
        /// register
        pub const OTG_FS_DOEPTSIZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x350);

        /// address: 0x50000b70
        /// device OUT endpoint-3 transfer size
        /// register
        pub const OTG_FS_DOEPTSIZ3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x370);

        /// address: 0x50000980
        /// OTG device endpoint-4 control
        /// register
        pub const OTG_FS_DIEPCTL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            reserved4: u1,
            /// Stall
            Stall: u1,
            /// TXFNUM
            TXFNUM: u4,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x180);

        /// address: 0x50000988
        /// device endpoint-4 interrupt
        /// register
        pub const OTG_FS_DIEPINT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// TOC
            TOC: u1,
            /// ITTXFE
            ITTXFE: u1,
            reserved1: u1,
            /// INEPNE
            INEPNE: u1,
            /// TXFE
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x188);

        /// address: 0x50000994
        /// device endpoint-4 transfer size
        /// register
        pub const OTG_FS_DIEPTSIZ4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x194);

        /// address: 0x5000099c
        /// OTG_FS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_FS_DTXFSTS4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// available
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x19c);

        /// address: 0x500009a0
        /// OTG device endpoint-5 control
        /// register
        pub const OTG_FS_DIEPCTL5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            reserved4: u1,
            /// Stall
            Stall: u1,
            /// TXFNUM
            TXFNUM: u4,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x1a0);

        /// address: 0x500009a8
        /// device endpoint-5 interrupt
        /// register
        pub const OTG_FS_DIEPINT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// TOC
            TOC: u1,
            /// ITTXFE
            ITTXFE: u1,
            reserved1: u1,
            /// INEPNE
            INEPNE: u1,
            /// TXFE
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1a8);

        /// address: 0x500009b0
        /// device endpoint-5 transfer size
        /// register
        pub const OTG_FS_DIEPTSIZ55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x1b0);

        /// address: 0x500009b8
        /// OTG_FS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_FS_DTXFSTS55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// available
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1b8);

        /// address: 0x50000b78
        /// device endpoint-4 control
        /// register
        pub const OTG_FS_DOEPCTL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            /// SNPM
            SNPM: u1,
            /// Stall
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x378);

        /// address: 0x50000b80
        /// device endpoint-4 interrupt
        /// register
        pub const OTG_FS_DOEPINT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// STUP
            STUP: u1,
            /// OTEPDIS
            OTEPDIS: u1,
            reserved1: u1,
            /// B2BSTUP
            B2BSTUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x380);

        /// address: 0x50000b88
        /// device OUT endpoint-4 transfer size
        /// register
        pub const OTG_FS_DOEPTSIZ4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x388);

        /// address: 0x50000b90
        /// device endpoint-5 control
        /// register
        pub const OTG_FS_DOEPCTL5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPSIZ
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USBAEP
            USBAEP: u1,
            /// EONUM/DPID
            EONUM_DPID: u1,
            /// NAKSTS
            NAKSTS: u1,
            /// EPTYP
            EPTYP: u2,
            /// SNPM
            SNPM: u1,
            /// Stall
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// CNAK
            CNAK: u1,
            /// SNAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVNFRM: u1,
            /// SODDFRM
            SODDFRM: u1,
            /// EPDIS
            EPDIS: u1,
            /// EPENA
            EPENA: u1,
        }), base_address + 0x390);

        /// address: 0x50000b98
        /// device endpoint-5 interrupt
        /// register
        pub const OTG_FS_DOEPINT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// XFRC
            XFRC: u1,
            /// EPDISD
            EPDISD: u1,
            reserved0: u1,
            /// STUP
            STUP: u1,
            /// OTEPDIS
            OTEPDIS: u1,
            reserved1: u1,
            /// B2BSTUP
            B2BSTUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x398);

        /// address: 0x50000ba0
        /// device OUT endpoint-5 transfer size
        /// register
        pub const OTG_FS_DOEPTSIZ5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x3a0);
    };

    /// USB on the go full speed
    pub const OTG_FS_PWRCLK = struct {
        pub const base_address = 0x50000e00;

        /// address: 0x50000e00
        /// OTG_FS power and clock gating control
        /// register (OTG_FS_PCGCCTL)
        pub const OTG_FS_PCGCCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop PHY clock
            STPPCLK: u1,
            /// Gate HCLK
            GATEHCLK: u1,
            reserved0: u1,
            reserved1: u1,
            /// PHY Suspended
            PHYSUSP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);
    };

    /// USB on the go high speed
    pub const OTG_HS_HOST = struct {
        pub const base_address = 0x40040400;

        /// address: 0x40040400
        /// OTG_HS host configuration
        /// register
        pub const OTG_HS_HCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FS/LS PHY clock select
            FSLSPCS: u2,
            /// FS- and LS-only support
            FSLSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40040404
        /// OTG_HS Host frame interval
        /// register
        pub const OTG_HS_HFIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame interval
            FRIVL: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40040408
        /// OTG_HS host frame number/frame time
        /// remaining register
        pub const OTG_HS_HFNUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FRNUM: u16,
            /// Frame time remaining
            FTREM: u16,
        }), base_address + 0x8);

        /// address: 0x40040410
        /// OTG_HS_Host periodic transmit FIFO/queue
        /// status register
        pub const OTG_HS_HPTXSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Periodic transmit data FIFO space
            /// available
            PTXFSAVL: u16,
            /// Periodic transmit request queue space
            /// available
            PTXQSAV: u8,
            /// Top of the periodic transmit request
            /// queue
            PTXQTOP: u8,
        }), base_address + 0x10);

        /// address: 0x40040414
        /// OTG_HS Host all channels interrupt
        /// register
        pub const OTG_HS_HAINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel interrupts
            HAINT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40040418
        /// OTG_HS host all channels interrupt mask
        /// register
        pub const OTG_HS_HAINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel interrupt mask
            HAINTM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40040440
        /// OTG_HS host port control and status
        /// register
        pub const OTG_HS_HPRT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port connect status
            PCSTS: u1,
            /// Port connect detected
            PCDET: u1,
            /// Port enable
            PENA: u1,
            /// Port enable/disable change
            PENCHNG: u1,
            /// Port overcurrent active
            POCA: u1,
            /// Port overcurrent change
            POCCHNG: u1,
            /// Port resume
            PRES: u1,
            /// Port suspend
            PSUSP: u1,
            /// Port reset
            PRST: u1,
            reserved0: u1,
            /// Port line status
            PLSTS: u2,
            /// Port power
            PPWR: u1,
            /// Port test control
            PTCTL: u4,
            /// Port speed
            PSPD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x40);

        /// address: 0x40040500
        /// OTG_HS host channel-0 characteristics
        /// register
        pub const OTG_HS_HCCHAR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x100);

        /// address: 0x40040520
        /// OTG_HS host channel-1 characteristics
        /// register
        pub const OTG_HS_HCCHAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x120);

        /// address: 0x40040540
        /// OTG_HS host channel-2 characteristics
        /// register
        pub const OTG_HS_HCCHAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x140);

        /// address: 0x40040560
        /// OTG_HS host channel-3 characteristics
        /// register
        pub const OTG_HS_HCCHAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x160);

        /// address: 0x40040580
        /// OTG_HS host channel-4 characteristics
        /// register
        pub const OTG_HS_HCCHAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x180);

        /// address: 0x400405a0
        /// OTG_HS host channel-5 characteristics
        /// register
        pub const OTG_HS_HCCHAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1a0);

        /// address: 0x400405c0
        /// OTG_HS host channel-6 characteristics
        /// register
        pub const OTG_HS_HCCHAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1c0);

        /// address: 0x400405e0
        /// OTG_HS host channel-7 characteristics
        /// register
        pub const OTG_HS_HCCHAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x1e0);

        /// address: 0x40040600
        /// OTG_HS host channel-8 characteristics
        /// register
        pub const OTG_HS_HCCHAR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x200);

        /// address: 0x40040620
        /// OTG_HS host channel-9 characteristics
        /// register
        pub const OTG_HS_HCCHAR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x220);

        /// address: 0x40040640
        /// OTG_HS host channel-10 characteristics
        /// register
        pub const OTG_HS_HCCHAR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x240);

        /// address: 0x40040660
        /// OTG_HS host channel-11 characteristics
        /// register
        pub const OTG_HS_HCCHAR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x260);

        /// address: 0x40040504
        /// OTG_HS host channel-0 split control
        /// register
        pub const OTG_HS_HCSPLT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x104);

        /// address: 0x40040524
        /// OTG_HS host channel-1 split control
        /// register
        pub const OTG_HS_HCSPLT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x124);

        /// address: 0x40040544
        /// OTG_HS host channel-2 split control
        /// register
        pub const OTG_HS_HCSPLT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x144);

        /// address: 0x40040564
        /// OTG_HS host channel-3 split control
        /// register
        pub const OTG_HS_HCSPLT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x164);

        /// address: 0x40040584
        /// OTG_HS host channel-4 split control
        /// register
        pub const OTG_HS_HCSPLT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x184);

        /// address: 0x400405a4
        /// OTG_HS host channel-5 split control
        /// register
        pub const OTG_HS_HCSPLT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x1a4);

        /// address: 0x400405c4
        /// OTG_HS host channel-6 split control
        /// register
        pub const OTG_HS_HCSPLT6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x1c4);

        /// address: 0x400405e4
        /// OTG_HS host channel-7 split control
        /// register
        pub const OTG_HS_HCSPLT7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x1e4);

        /// address: 0x40040604
        /// OTG_HS host channel-8 split control
        /// register
        pub const OTG_HS_HCSPLT8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x204);

        /// address: 0x40040624
        /// OTG_HS host channel-9 split control
        /// register
        pub const OTG_HS_HCSPLT9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x224);

        /// address: 0x40040644
        /// OTG_HS host channel-10 split control
        /// register
        pub const OTG_HS_HCSPLT10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x244);

        /// address: 0x40040664
        /// OTG_HS host channel-11 split control
        /// register
        pub const OTG_HS_HCSPLT11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x264);

        /// address: 0x40040508
        /// OTG_HS host channel-11 interrupt
        /// register
        pub const OTG_HS_HCINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x108);

        /// address: 0x40040528
        /// OTG_HS host channel-1 interrupt
        /// register
        pub const OTG_HS_HCINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x128);

        /// address: 0x40040548
        /// OTG_HS host channel-2 interrupt
        /// register
        pub const OTG_HS_HCINT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x148);

        /// address: 0x40040568
        /// OTG_HS host channel-3 interrupt
        /// register
        pub const OTG_HS_HCINT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x168);

        /// address: 0x40040588
        /// OTG_HS host channel-4 interrupt
        /// register
        pub const OTG_HS_HCINT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x188);

        /// address: 0x400405a8
        /// OTG_HS host channel-5 interrupt
        /// register
        pub const OTG_HS_HCINT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1a8);

        /// address: 0x400405c8
        /// OTG_HS host channel-6 interrupt
        /// register
        pub const OTG_HS_HCINT6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c8);

        /// address: 0x400405e8
        /// OTG_HS host channel-7 interrupt
        /// register
        pub const OTG_HS_HCINT7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1e8);

        /// address: 0x40040608
        /// OTG_HS host channel-8 interrupt
        /// register
        pub const OTG_HS_HCINT8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x208);

        /// address: 0x40040628
        /// OTG_HS host channel-9 interrupt
        /// register
        pub const OTG_HS_HCINT9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x228);

        /// address: 0x40040648
        /// OTG_HS host channel-10 interrupt
        /// register
        pub const OTG_HS_HCINT10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x248);

        /// address: 0x40040668
        /// OTG_HS host channel-11 interrupt
        /// register
        pub const OTG_HS_HCINT11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x268);

        /// address: 0x4004050c
        /// OTG_HS host channel-11 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10c);

        /// address: 0x4004052c
        /// OTG_HS host channel-1 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x12c);

        /// address: 0x4004054c
        /// OTG_HS host channel-2 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14c);

        /// address: 0x4004056c
        /// OTG_HS host channel-3 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x16c);

        /// address: 0x4004058c
        /// OTG_HS host channel-4 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x18c);

        /// address: 0x400405ac
        /// OTG_HS host channel-5 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1ac);

        /// address: 0x400405cc
        /// OTG_HS host channel-6 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1cc);

        /// address: 0x400405ec
        /// OTG_HS host channel-7 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1ec);

        /// address: 0x4004060c
        /// OTG_HS host channel-8 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x20c);

        /// address: 0x4004062c
        /// OTG_HS host channel-9 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x22c);

        /// address: 0x4004064c
        /// OTG_HS host channel-10 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x24c);

        /// address: 0x4004066c
        /// OTG_HS host channel-11 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// response received interrupt
            /// mask
            NYET: u1,
            /// Transaction error mask
            TXERRM: u1,
            /// Babble error mask
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x26c);

        /// address: 0x40040510
        /// OTG_HS host channel-11 transfer size
        /// register
        pub const OTG_HS_HCTSIZ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x110);

        /// address: 0x40040530
        /// OTG_HS host channel-1 transfer size
        /// register
        pub const OTG_HS_HCTSIZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x130);

        /// address: 0x40040550
        /// OTG_HS host channel-2 transfer size
        /// register
        pub const OTG_HS_HCTSIZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x150);

        /// address: 0x40040570
        /// OTG_HS host channel-3 transfer size
        /// register
        pub const OTG_HS_HCTSIZ3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x170);

        /// address: 0x40040590
        /// OTG_HS host channel-4 transfer size
        /// register
        pub const OTG_HS_HCTSIZ4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x190);

        /// address: 0x400405b0
        /// OTG_HS host channel-5 transfer size
        /// register
        pub const OTG_HS_HCTSIZ5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1b0);

        /// address: 0x400405d0
        /// OTG_HS host channel-6 transfer size
        /// register
        pub const OTG_HS_HCTSIZ6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1d0);

        /// address: 0x400405f0
        /// OTG_HS host channel-7 transfer size
        /// register
        pub const OTG_HS_HCTSIZ7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1f0);

        /// address: 0x40040610
        /// OTG_HS host channel-8 transfer size
        /// register
        pub const OTG_HS_HCTSIZ8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x210);

        /// address: 0x40040630
        /// OTG_HS host channel-9 transfer size
        /// register
        pub const OTG_HS_HCTSIZ9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x230);

        /// address: 0x40040650
        /// OTG_HS host channel-10 transfer size
        /// register
        pub const OTG_HS_HCTSIZ10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x250);

        /// address: 0x40040670
        /// OTG_HS host channel-11 transfer size
        /// register
        pub const OTG_HS_HCTSIZ11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x270);

        /// address: 0x40040514
        /// OTG_HS host channel-0 DMA address
        /// register
        pub const OTG_HS_HCDMA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x114);

        /// address: 0x40040534
        /// OTG_HS host channel-1 DMA address
        /// register
        pub const OTG_HS_HCDMA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x134);

        /// address: 0x40040554
        /// OTG_HS host channel-2 DMA address
        /// register
        pub const OTG_HS_HCDMA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x154);

        /// address: 0x40040574
        /// OTG_HS host channel-3 DMA address
        /// register
        pub const OTG_HS_HCDMA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x174);

        /// address: 0x40040594
        /// OTG_HS host channel-4 DMA address
        /// register
        pub const OTG_HS_HCDMA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x194);

        /// address: 0x400405b4
        /// OTG_HS host channel-5 DMA address
        /// register
        pub const OTG_HS_HCDMA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x1b4);

        /// address: 0x400405d4
        /// OTG_HS host channel-6 DMA address
        /// register
        pub const OTG_HS_HCDMA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x1d4);

        /// address: 0x400405f4
        /// OTG_HS host channel-7 DMA address
        /// register
        pub const OTG_HS_HCDMA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x1f4);

        /// address: 0x40040614
        /// OTG_HS host channel-8 DMA address
        /// register
        pub const OTG_HS_HCDMA8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x214);

        /// address: 0x40040634
        /// OTG_HS host channel-9 DMA address
        /// register
        pub const OTG_HS_HCDMA9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x234);

        /// address: 0x40040654
        /// OTG_HS host channel-10 DMA address
        /// register
        pub const OTG_HS_HCDMA10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x254);

        /// address: 0x40040674
        /// OTG_HS host channel-11 DMA address
        /// register
        pub const OTG_HS_HCDMA11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x274);

        /// address: 0x40040678
        /// OTG_HS host channel-12 characteristics
        /// register
        pub const OTG_HS_HCCHAR12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x278);

        /// address: 0x4004067c
        /// OTG_HS host channel-12 split control
        /// register
        pub const OTG_HS_HCSPLT12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x27c);

        /// address: 0x40040680
        /// OTG_HS host channel-12 interrupt
        /// register
        pub const OTG_HS_HCINT12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x280);

        /// address: 0x40040684
        /// OTG_HS host channel-12 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERRM: u1,
            /// Babble error
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x284);

        /// address: 0x40040688
        /// OTG_HS host channel-12 transfer size
        /// register
        pub const OTG_HS_HCTSIZ12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x288);

        /// address: 0x4004068c
        /// OTG_HS host channel-12 DMA address
        /// register
        pub const OTG_HS_HCDMA12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x28c);

        /// address: 0x40040690
        /// OTG_HS host channel-13 characteristics
        /// register
        pub const OTG_HS_HCCHAR13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x290);

        /// address: 0x40040694
        /// OTG_HS host channel-13 split control
        /// register
        pub const OTG_HS_HCSPLT13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x294);

        /// address: 0x40040698
        /// OTG_HS host channel-13 interrupt
        /// register
        pub const OTG_HS_HCINT13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x298);

        /// address: 0x4004069c
        /// OTG_HS host channel-13 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALLM response received interrupt
            /// mask
            STALLM: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERRM: u1,
            /// Babble error
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x29c);

        /// address: 0x400406a0
        /// OTG_HS host channel-13 transfer size
        /// register
        pub const OTG_HS_HCTSIZ13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x2a0);

        /// address: 0x400406a4
        /// OTG_HS host channel-13 DMA address
        /// register
        pub const OTG_HS_HCDMA13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x2a4);

        /// address: 0x400406a8
        /// OTG_HS host channel-14 characteristics
        /// register
        pub const OTG_HS_HCCHAR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x2a8);

        /// address: 0x400406ac
        /// OTG_HS host channel-14 split control
        /// register
        pub const OTG_HS_HCSPLT14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x2ac);

        /// address: 0x400406b0
        /// OTG_HS host channel-14 interrupt
        /// register
        pub const OTG_HS_HCINT14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2b0);

        /// address: 0x400406b4
        /// OTG_HS host channel-14 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALLM: u1,
            /// NAKM response received interrupt
            /// mask
            NAKM: u1,
            /// ACKM response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERRM: u1,
            /// Babble error
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2b4);

        /// address: 0x400406b8
        /// OTG_HS host channel-14 transfer size
        /// register
        pub const OTG_HS_HCTSIZ14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x2b8);

        /// address: 0x400406bc
        /// OTG_HS host channel-14 DMA address
        /// register
        pub const OTG_HS_HCDMA14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x2bc);

        /// address: 0x400406c0
        /// OTG_HS host channel-15 characteristics
        /// register
        pub const OTG_HS_HCCHAR15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSDEV: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Multi Count (MC) / Error Count
            /// (EC)
            MC: u2,
            /// Device address
            DAD: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CHDIS: u1,
            /// Channel enable
            CHENA: u1,
        }), base_address + 0x2c0);

        /// address: 0x400406c4
        /// OTG_HS host channel-15 split control
        /// register
        pub const OTG_HS_HCSPLT15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port address
            PRTADDR: u7,
            /// Hub address
            HUBADDR: u7,
            /// XACTPOS
            XACTPOS: u2,
            /// Do complete split
            COMPLSPLT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Split enable
            SPLITEN: u1,
        }), base_address + 0x2c4);

        /// address: 0x400406c8
        /// OTG_HS host channel-15 interrupt
        /// register
        pub const OTG_HS_HCINT15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            XFRC: u1,
            /// Channel halted
            CHH: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERR: u1,
            /// Babble error
            BBERR: u1,
            /// Frame overrun
            FRMOR: u1,
            /// Data toggle error
            DTERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2c8);

        /// address: 0x400406cc
        /// OTG_HS host channel-15 interrupt mask
        /// register
        pub const OTG_HS_HCINTMSK15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed mask
            XFRCM: u1,
            /// Channel halted mask
            CHHM: u1,
            /// AHB error
            AHBERR: u1,
            /// STALL response received interrupt
            /// mask
            STALL: u1,
            /// NAK response received interrupt
            /// mask
            NAKM: u1,
            /// ACK response received/transmitted
            /// interrupt mask
            ACKM: u1,
            /// Response received
            /// interrupt
            NYET: u1,
            /// Transaction error
            TXERRM: u1,
            /// Babble error
            BBERRM: u1,
            /// Frame overrun mask
            FRMORM: u1,
            /// Data toggle error mask
            DTERRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2cc);

        /// address: 0x400406d0
        /// OTG_HS host channel-15 transfer size
        /// register
        pub const OTG_HS_HCTSIZ15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x2d0);

        /// address: 0x400406d4
        /// OTG_HS host channel-15 DMA address
        /// register
        pub const OTG_HS_HCDMA15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x2d4);
    };

    /// USB on the go high speed
    pub const OTG_HS_DEVICE = struct {
        pub const base_address = 0x40040800;

        /// address: 0x40040800
        /// OTG_HS device configuration
        /// register
        pub const OTG_HS_DCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device speed
            DSPD: u2,
            /// Nonzero-length status OUT
            /// handshake
            NZLSOHSK: u1,
            reserved0: u1,
            /// Device address
            DAD: u7,
            /// Periodic (micro)frame
            /// interval
            PFIVL: u2,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Periodic scheduling
            /// interval
            PERSCHIVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40040804
        /// OTG_HS device control register
        pub const OTG_HS_DCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remote wakeup signaling
            RWUSIG: u1,
            /// Soft disconnect
            SDIS: u1,
            /// Global IN NAK status
            GINSTS: u1,
            /// Global OUT NAK status
            GONSTS: u1,
            /// Test control
            TCTL: u3,
            /// Set global IN NAK
            SGINAK: u1,
            /// Clear global IN NAK
            CGINAK: u1,
            /// Set global OUT NAK
            SGONAK: u1,
            /// Clear global OUT NAK
            CGONAK: u1,
            /// Power-on programming done
            POPRGDNE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40040808
        /// OTG_HS device status register
        pub const OTG_HS_DSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Suspend status
            SUSPSTS: u1,
            /// Enumerated speed
            ENUMSPD: u2,
            /// Erratic error
            EERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Frame number of the received
            /// SOF
            FNSOF: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x40040810
        /// OTG_HS device IN endpoint common interrupt
        /// mask register
        pub const OTG_HS_DIEPMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt
            /// mask
            XFRCM: u1,
            /// Endpoint disabled interrupt
            /// mask
            EPDM: u1,
            reserved0: u1,
            /// Timeout condition mask (nonisochronous
            /// endpoints)
            TOM: u1,
            /// IN token received when TxFIFO empty
            /// mask
            ITTXFEMSK: u1,
            /// IN token received with EP mismatch
            /// mask
            INEPNMM: u1,
            /// IN endpoint NAK effective
            /// mask
            INEPNEM: u1,
            reserved1: u1,
            /// FIFO underrun mask
            TXFURM: u1,
            /// BNA interrupt mask
            BIM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40040814
        /// OTG_HS device OUT endpoint common interrupt
        /// mask register
        pub const OTG_HS_DOEPMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt
            /// mask
            XFRCM: u1,
            /// Endpoint disabled interrupt
            /// mask
            EPDM: u1,
            reserved0: u1,
            /// SETUP phase done mask
            STUPM: u1,
            /// OUT token received when endpoint
            /// disabled mask
            OTEPDM: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets received
            /// mask
            B2BSTUP: u1,
            reserved2: u1,
            /// OUT packet error mask
            OPEM: u1,
            /// BNA interrupt mask
            BOIM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x14);

        /// address: 0x40040818
        /// OTG_HS device all endpoints interrupt
        /// register
        pub const OTG_HS_DAINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint interrupt bits
            IEPINT: u16,
            /// OUT endpoint interrupt
            /// bits
            OEPINT: u16,
        }), base_address + 0x18);

        /// address: 0x4004081c
        /// OTG_HS all endpoints interrupt mask
        /// register
        pub const OTG_HS_DAINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN EP interrupt mask bits
            IEPM: u16,
            /// OUT EP interrupt mask bits
            OEPM: u16,
        }), base_address + 0x1c);

        /// address: 0x40040828
        /// OTG_HS device VBUS discharge time
        /// register
        pub const OTG_HS_DVBUSDIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device VBUS discharge time
            VBUSDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4004082c
        /// OTG_HS device VBUS pulsing time
        /// register
        pub const OTG_HS_DVBUSPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device VBUS pulsing time
            DVBUSP: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40040830
        /// OTG_HS Device threshold control
        /// register
        pub const OTG_HS_DTHRCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Nonisochronous IN endpoints threshold
            /// enable
            NONISOTHREN: u1,
            /// ISO IN endpoint threshold
            /// enable
            ISOTHREN: u1,
            /// Transmit threshold length
            TXTHRLEN: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Receive threshold enable
            RXTHREN: u1,
            /// Receive threshold length
            RXTHRLEN: u9,
            reserved5: u1,
            /// Arbiter parking enable
            ARPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x30);

        /// address: 0x40040834
        /// OTG_HS device IN endpoint FIFO empty
        /// interrupt mask register
        pub const OTG_HS_DIEPEMPMSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN EP Tx FIFO empty interrupt mask
            /// bits
            INEPTXFEM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40040838
        /// OTG_HS device each endpoint interrupt
        /// register
        pub const OTG_HS_DEACHINT = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// IN endpoint 1interrupt bit
            IEP1INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// OUT endpoint 1 interrupt
            /// bit
            OEP1INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x38);

        /// address: 0x4004083c
        /// OTG_HS device each endpoint interrupt
        /// register mask
        pub const OTG_HS_DEACHINTMSK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// IN Endpoint 1 interrupt mask
            /// bit
            IEP1INTM: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// OUT Endpoint 1 interrupt mask
            /// bit
            OEP1INTM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x3c);

        /// address: 0x40040900
        /// OTG device endpoint-0 control
        /// register
        pub const OTG_HS_DIEPCTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x100);

        /// address: 0x40040920
        /// OTG device endpoint-1 control
        /// register
        pub const OTG_HS_DIEPCTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x120);

        /// address: 0x40040940
        /// OTG device endpoint-2 control
        /// register
        pub const OTG_HS_DIEPCTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x140);

        /// address: 0x40040960
        /// OTG device endpoint-3 control
        /// register
        pub const OTG_HS_DIEPCTL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x160);

        /// address: 0x40040980
        /// OTG device endpoint-4 control
        /// register
        pub const OTG_HS_DIEPCTL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x180);

        /// address: 0x400409a0
        /// OTG device endpoint-5 control
        /// register
        pub const OTG_HS_DIEPCTL5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x1a0);

        /// address: 0x400409c0
        /// OTG device endpoint-6 control
        /// register
        pub const OTG_HS_DIEPCTL6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x1c0);

        /// address: 0x400409e0
        /// OTG device endpoint-7 control
        /// register
        pub const OTG_HS_DIEPCTL7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even/odd frame
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            reserved4: u1,
            /// STALL handshake
            Stall: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x1e0);

        /// address: 0x40040908
        /// OTG device endpoint-0 interrupt
        /// register
        pub const OTG_HS_DIEPINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x108);

        /// address: 0x40040928
        /// OTG device endpoint-1 interrupt
        /// register
        pub const OTG_HS_DIEPINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x128);

        /// address: 0x40040948
        /// OTG device endpoint-2 interrupt
        /// register
        pub const OTG_HS_DIEPINT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x148);

        /// address: 0x40040968
        /// OTG device endpoint-3 interrupt
        /// register
        pub const OTG_HS_DIEPINT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x168);

        /// address: 0x40040988
        /// OTG device endpoint-4 interrupt
        /// register
        pub const OTG_HS_DIEPINT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x188);

        /// address: 0x400409a8
        /// OTG device endpoint-5 interrupt
        /// register
        pub const OTG_HS_DIEPINT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1a8);

        /// address: 0x400409c8
        /// OTG device endpoint-6 interrupt
        /// register
        pub const OTG_HS_DIEPINT6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c8);

        /// address: 0x400409e8
        /// OTG device endpoint-7 interrupt
        /// register
        pub const OTG_HS_DIEPINT7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// Timeout condition
            TOC: u1,
            /// IN token received when TxFIFO is
            /// empty
            ITTXFE: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            INEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            /// Transmit Fifo Underrun
            TXFIFOUDRN: u1,
            /// Buffer not available
            /// interrupt
            BNA: u1,
            reserved2: u1,
            /// Packet dropped status
            PKTDRPSTS: u1,
            /// Babble error interrupt
            BERR: u1,
            /// NAK interrupt
            NAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1e8);

        /// address: 0x40040910
        /// OTG_HS device IN endpoint 0 transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Packet count
            PKTCNT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x110);

        /// address: 0x40040914
        /// OTG_HS device endpoint-1 DMA address
        /// register
        pub const OTG_HS_DIEPDMA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x114);

        /// address: 0x40040934
        /// OTG_HS device endpoint-2 DMA address
        /// register
        pub const OTG_HS_DIEPDMA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x134);

        /// address: 0x40040954
        /// OTG_HS device endpoint-3 DMA address
        /// register
        pub const OTG_HS_DIEPDMA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x154);

        /// address: 0x40040974
        /// OTG_HS device endpoint-4 DMA address
        /// register
        pub const OTG_HS_DIEPDMA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x174);

        /// address: 0x40040994
        /// OTG_HS device endpoint-5 DMA address
        /// register
        pub const OTG_HS_DIEPDMA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA address
            DMAADDR: u32,
        }), base_address + 0x194);

        /// address: 0x40040918
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x40040938
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x40040958
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x158);

        /// address: 0x40040978
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x178);

        /// address: 0x40040998
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x198);

        /// address: 0x400409b8
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1b8);

        /// address: 0x40040930
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x130);

        /// address: 0x40040950
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x150);

        /// address: 0x40040970
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x170);

        /// address: 0x40040990
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x190);

        /// address: 0x400409b0
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x1b0);

        /// address: 0x40040b00
        /// OTG_HS device control OUT endpoint 0 control
        /// register
        pub const OTG_HS_DOEPCTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// USB active endpoint
            USBAEP: u1,
            reserved13: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            reserved18: u1,
            reserved19: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x300);

        /// address: 0x40040b20
        /// OTG device endpoint-1 control
        /// register
        pub const OTG_HS_DOEPCTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x320);

        /// address: 0x40040b40
        /// OTG device endpoint-2 control
        /// register
        pub const OTG_HS_DOEPCTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x340);

        /// address: 0x40040b60
        /// OTG device endpoint-3 control
        /// register
        pub const OTG_HS_DOEPCTL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x360);

        /// address: 0x40040b08
        /// OTG_HS device endpoint-0 interrupt
        /// register
        pub const OTG_HS_DOEPINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x308);

        /// address: 0x40040b28
        /// OTG_HS device endpoint-1 interrupt
        /// register
        pub const OTG_HS_DOEPINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x328);

        /// address: 0x40040b48
        /// OTG_HS device endpoint-2 interrupt
        /// register
        pub const OTG_HS_DOEPINT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x348);

        /// address: 0x40040b68
        /// OTG_HS device endpoint-3 interrupt
        /// register
        pub const OTG_HS_DOEPINT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x368);

        /// address: 0x40040b88
        /// OTG_HS device endpoint-4 interrupt
        /// register
        pub const OTG_HS_DOEPINT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x388);

        /// address: 0x40040ba8
        /// OTG_HS device endpoint-5 interrupt
        /// register
        pub const OTG_HS_DOEPINT5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x3a8);

        /// address: 0x40040bc8
        /// OTG_HS device endpoint-6 interrupt
        /// register
        pub const OTG_HS_DOEPINT6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x3c8);

        /// address: 0x40040be8
        /// OTG_HS device endpoint-7 interrupt
        /// register
        pub const OTG_HS_DOEPINT7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed
            /// interrupt
            XFRC: u1,
            /// Endpoint disabled
            /// interrupt
            EPDISD: u1,
            reserved0: u1,
            /// SETUP phase done
            STUP: u1,
            /// OUT token received when endpoint
            /// disabled
            OTEPDIS: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// received
            B2BSTUP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// NYET interrupt
            NYET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x3e8);

        /// address: 0x40040b10
        /// OTG_HS device endpoint-0 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Packet count
            PKTCNT: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// SETUP packet count
            STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x310);

        /// address: 0x40040b30
        /// OTG_HS device endpoint-1 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x330);

        /// address: 0x40040b50
        /// OTG_HS device endpoint-2 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x350);

        /// address: 0x40040b70
        /// OTG_HS device endpoint-3 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x370);

        /// address: 0x40040b90
        /// OTG_HS device endpoint-4 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x390);

        /// address: 0x400409a0
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x1a0);

        /// address: 0x400409a4
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1a4);

        /// address: 0x400409a8
        /// OTG_HS device endpoint transfer size
        /// register
        pub const OTG_HS_DIEPTSIZ7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Multi count
            MCNT: u2,
            padding0: u1,
        }), base_address + 0x1a8);

        /// address: 0x400409ac
        /// OTG_HS device IN endpoint transmit FIFO
        /// status register
        pub const OTG_HS_DTXFSTS7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// avail
            INEPTFSAV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1ac);

        /// address: 0x40040b80
        /// OTG device endpoint-4 control
        /// register
        pub const OTG_HS_DOEPCTL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x380);

        /// address: 0x40040ba0
        /// OTG device endpoint-5 control
        /// register
        pub const OTG_HS_DOEPCTL5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x3a0);

        /// address: 0x40040bc0
        /// OTG device endpoint-6 control
        /// register
        pub const OTG_HS_DOEPCTL6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x3c0);

        /// address: 0x40040be0
        /// OTG device endpoint-7 control
        /// register
        pub const OTG_HS_DOEPCTL7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPSIZ: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// USB active endpoint
            USBAEP: u1,
            /// Even odd frame/Endpoint data
            /// PID
            EONUM_DPID: u1,
            /// NAK status
            NAKSTS: u1,
            /// Endpoint type
            EPTYP: u2,
            /// Snoop mode
            SNPM: u1,
            /// STALL handshake
            Stall: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// Set DATA0 PID/Set even
            /// frame
            SD0PID_SEVNFRM: u1,
            /// Set odd frame
            SODDFRM: u1,
            /// Endpoint disable
            EPDIS: u1,
            /// Endpoint enable
            EPENA: u1,
        }), base_address + 0x3e0);

        /// address: 0x40040bb0
        /// OTG_HS device endpoint-5 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x3b0);

        /// address: 0x40040bd0
        /// OTG_HS device endpoint-6 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x3d0);

        /// address: 0x40040bf0
        /// OTG_HS device endpoint-7 transfer size
        /// register
        pub const OTG_HS_DOEPTSIZ7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size
            XFRSIZ: u19,
            /// Packet count
            PKTCNT: u10,
            /// Received data PID/SETUP packet
            /// count
            RXDPID_STUPCNT: u2,
            padding0: u1,
        }), base_address + 0x3f0);
    };

    /// USB on the go high speed
    pub const OTG_HS_PWRCLK = struct {
        pub const base_address = 0x40040e00;

        /// address: 0x40040e00
        /// Power and clock gating control
        /// register
        pub const OTG_HS_PCGCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop PHY clock
            STPPCLK: u1,
            /// Gate HCLK
            GATEHCLK: u1,
            reserved0: u1,
            reserved1: u1,
            /// PHY suspended
            PHYSUSP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);
    };

    /// DSI Host
    pub const DSI = struct {
        pub const base_address = 0x40016c00;

        /// address: 0x40016c00
        /// DSI Host Version Register
        pub const DSI_VR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Version of the DSI Host
            VERSION: u32,
        }), base_address + 0x0);

        /// address: 0x40016c04
        /// DSI Host Control Register
        pub const DSI_CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x4);

        /// address: 0x40016c08
        /// DSI HOST Clock Control
        /// Register
        pub const DSI_CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Escape Clock Division
            TXECKDIV: u8,
            /// Timeout Clock Division
            TOCKDIV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40016c0c
        /// DSI Host LTDC VCID Register
        pub const DSI_LVCIDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual Channel ID
            VCID: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40016c10
        /// DSI Host LTDC Color Coding
        /// Register
        pub const DSI_LCOLCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Coding
            COLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Loosely Packet Enable
            LPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x10);

        /// address: 0x40016c14
        /// DSI Host LTDC Polarity Configuration
        /// Register
        pub const DSI_LPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Enable Polarity
            DEP: u1,
            /// VSYNC Polarity
            VSP: u1,
            /// HSYNC Polarity
            HSP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x14);

        /// address: 0x40016c18
        /// DSI Host Low-Power mode Configuration
        /// Register
        pub const DSI_LPMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// VACT Largest Packet Size
            VLPSIZE: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Largest Packet Size
            LPSIZE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x40016c2c
        /// DSI Host Protocol Configuration
        /// Register
        pub const DSI_PCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EoTp Transmission Enable
            ETTXE: u1,
            /// EoTp Reception Enable
            ETRXE: u1,
            /// Bus Turn Around Enable
            BTAE: u1,
            /// ECC Reception Enable
            ECCRXE: u1,
            /// CRC Reception Enable
            CRCRXE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x2c);

        /// address: 0x40016c30
        /// DSI Host Generic VCID Register
        pub const DSI_GVCIDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual Channel ID
            VCID: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x30);

        /// address: 0x40016c34
        /// DSI Host mode Configuration
        /// Register
        pub const DSI_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command mode
            CMDM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x34);

        /// address: 0x40016c38
        /// DSI Host Video mode Configuration
        /// Register
        pub const DSI_VMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video mode Type
            VMT: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Low-Power Vertical Sync Active
            /// Enable
            LPVSAE: u1,
            /// Low-power Vertical Back-Porch
            /// Enable
            LPVBPE: u1,
            /// Low-power Vertical Front-porch
            /// Enable
            LPVFPE: u1,
            /// Low-Power Vertical Active
            /// Enable
            LPVAE: u1,
            /// Low-Power Horizontal Back-Porch
            /// Enable
            LPHBPE: u1,
            /// Low-Power Horizontal Front-Porch
            /// Enable
            LPHFPE: u1,
            /// Frame Bus-Turn-Around Acknowledge
            /// Enable
            FBTAAE: u1,
            /// Low-Power Command Enable
            LPCE: u1,
            /// Pattern Generator Enable
            PGE: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Pattern Generator mode
            PGM: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Pattern Generator
            /// Orientation
            PGO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x38);

        /// address: 0x40016c3c
        /// DSI Host Video Packet Configuration
        /// Register
        pub const DSI_VPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Packet Size
            VPSIZE: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x3c);

        /// address: 0x40016c40
        /// DSI Host Video Chunks Configuration
        /// Register
        pub const DSI_VCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of Chunks
            NUMC: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x40);

        /// address: 0x40016c44
        /// DSI Host Video Null Packet Configuration
        /// Register
        pub const DSI_VNPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Null Packet Size
            NPSIZE: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x44);

        /// address: 0x40016c48
        /// DSI Host Video HSA Configuration
        /// Register
        pub const DSI_VHSACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Synchronism Active
            /// duration
            HSA: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x48);

        /// address: 0x40016c4c
        /// DSI Host Video HBP Configuration
        /// Register
        pub const DSI_VHBPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Back-Porch
            /// duration
            HBP: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4c);

        /// address: 0x40016c50
        /// DSI Host Video Line Configuration
        /// Register
        pub const DSI_VLCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Line duration
            HLINE: u15,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x50);

        /// address: 0x40016c54
        /// DSI Host Video VSA Configuration
        /// Register
        pub const DSI_VVSACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Synchronism Active
            /// duration
            VSA: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x54);

        /// address: 0x40016c58
        /// DSI Host Video VBP Configuration
        /// Register
        pub const DSI_VVBPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Back-Porch
            /// duration
            VBP: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x58);

        /// address: 0x40016c5c
        /// DSI Host Video VFP Configuration
        /// Register
        pub const DSI_VVFPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Front-Porch
            /// duration
            VFP: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x5c);

        /// address: 0x40016c60
        /// DSI Host Video VA Configuration
        /// Register
        pub const DSI_VVACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Active duration
            VA: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x60);

        /// address: 0x40016c64
        /// DSI Host LTDC Command Configuration
        /// Register
        pub const DSI_LCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command Size
            CMDSIZE: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x64);

        /// address: 0x40016c68
        /// DSI Host Command mode Configuration
        /// Register
        pub const DSI_CMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tearing Effect Acknowledge Request
            /// Enable
            TEARE: u1,
            /// Acknowledge Request Enable
            ARE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Generic Short Write Zero parameters
            /// Transmission
            GSW0TX: u1,
            /// Generic Short Write One parameters
            /// Transmission
            GSW1TX: u1,
            /// Generic Short Write Two parameters
            /// Transmission
            GSW2TX: u1,
            /// Generic Short Read Zero parameters
            /// Transmission
            GSR0TX: u1,
            /// Generic Short Read One parameters
            /// Transmission
            GSR1TX: u1,
            /// Generic Short Read Two parameters
            /// Transmission
            GSR2TX: u1,
            /// Generic Long Write
            /// Transmission
            GLWTX: u1,
            reserved6: u1,
            /// DCS Short Write Zero parameter
            /// Transmission
            DSW0TX: u1,
            /// DCS Short Read One parameter
            /// Transmission
            DSW1TX: u1,
            /// DCS Short Read Zero parameter
            /// Transmission
            DSR0TX: u1,
            /// DCS Long Write
            /// Transmission
            DLWTX: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Maximum Read Packet Size
            MRDPS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x68);

        /// address: 0x40016c6c
        /// DSI Host Generic Header Configuration
        /// Register
        pub const DSI_GHCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Type
            DT: u6,
            /// Channel
            VCID: u2,
            /// WordCount LSB
            WCLSB: u8,
            /// WordCount MSB
            WCMSB: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x40016c70
        /// DSI Host Generic Payload Data
        /// Register
        pub const DSI_GPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Payload Byte 1
            DATA1: u8,
            /// Payload Byte 2
            DATA2: u8,
            /// Payload Byte 3
            DATA3: u8,
            /// Payload Byte 4
            DATA4: u8,
        }), base_address + 0x70);

        /// address: 0x40016c74
        /// DSI Host Generic Packet Status
        /// Register
        pub const DSI_GPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command FIFO Empty
            CMDFE: u1,
            /// Command FIFO Full
            CMDFF: u1,
            /// Payload Write FIFO Empty
            PWRFE: u1,
            /// Payload Write FIFO Full
            PWRFF: u1,
            /// Payload Read FIFO Empty
            PRDFE: u1,
            /// Payload Read FIFO Full
            PRDFF: u1,
            /// Read Command Busy
            RCB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x74);

        /// address: 0x40016c78
        /// DSI Host Timeout Counter Configuration
        /// Register 0
        pub const DSI_TCCR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power Reception Timeout
            /// Counter
            LPRX_TOCNT: u16,
            /// High-Speed Transmission Timeout
            /// Counter
            HSTX_TOCNT: u16,
        }), base_address + 0x78);

        /// address: 0x40016c7c
        /// DSI Host Timeout Counter Configuration
        /// Register 1
        pub const DSI_TCCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// High-Speed Read Timeout
            /// Counter
            HSRD_TOCNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x7c);

        /// address: 0x40016c80
        /// DSI Host Timeout Counter Configuration
        /// Register 2
        pub const DSI_TCCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-Power Read Timeout
            /// Counter
            LPRD_TOCNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x40016c84
        /// DSI Host Timeout Counter Configuration
        /// Register 3
        pub const DSI_TCCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// High-Speed Write Timeout
            /// Counter
            HSWR_TOCNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Presp mode
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x84);

        /// address: 0x40016c88
        /// DSI Host Timeout Counter Configuration
        /// Register 4
        pub const DSI_TCCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-Power Write Timeout
            /// Counter
            LSWR_TOCNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x40016c8c
        /// DSI Host Timeout Counter Configuration
        /// Register 5
        pub const DSI_TCCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus-Turn-Around Timeout
            /// Counter
            BTA_TOCNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x40016c94
        /// DSI Host Clock Lane Configuration
        /// Register
        pub const DSI_CLCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// D-PHY Clock Control
            DPCC: u1,
            /// Automatic Clock lane
            /// Control
            ACR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x94);

        /// address: 0x40016c98
        /// DSI Host Clock Lane Timer Configuration
        /// Register
        pub const DSI_CLTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-Power to High-Speed
            /// Time
            LP2HS_TIME: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// High-Speed to Low-Power
            /// Time
            HS2LP_TIME: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x98);

        /// address: 0x40016c9c
        /// DSI Host Data Lane Timer Configuration
        /// Register
        pub const DSI_DLTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum Read Time
            MRD_TIME: u15,
            reserved0: u1,
            /// Low-Power To High-Speed
            /// Time
            LP2HS_TIME: u8,
            /// High-Speed To Low-Power
            /// Time
            HS2LP_TIME: u8,
        }), base_address + 0x9c);

        /// address: 0x40016ca0
        /// DSI Host PHY Control Register
        pub const DSI_PCTLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Digital Enable
            DEN: u1,
            /// Clock Enable
            CKE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xa0);

        /// address: 0x40016ca4
        /// DSI Host PHY Configuration
        /// Register
        pub const DSI_PCONFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of Lanes
            NL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Stop Wait Time
            SW_TIME: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa4);

        /// address: 0x40016ca8
        /// DSI Host PHY ULPS Control
        /// Register
        pub const DSI_PUCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ULPS Request on Clock Lane
            URCL: u1,
            /// ULPS Exit on Clock Lane
            UECL: u1,
            /// ULPS Request on Data Lane
            URDL: u1,
            /// ULPS Exit on Data Lane
            UEDL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xa8);

        /// address: 0x40016cac
        /// DSI Host PHY TX Triggers Configuration
        /// Register
        pub const DSI_PTTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Trigger
            TX_TRIG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xac);

        /// address: 0x40016cb0
        /// DSI Host PHY Status Register
        pub const DSI_PSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PHY Direction
            PD: u1,
            /// PHY Stop State Clock lane
            PSSC: u1,
            /// ULPS Active Not Clock lane
            UANC: u1,
            /// PHY Stop State lane 0
            PSS0: u1,
            /// ULPS Active Not lane 1
            UAN0: u1,
            /// RX ULPS Escape lane 0
            RUE0: u1,
            /// PHY Stop State lane 1
            PSS1: u1,
            /// ULPS Active Not lane 1
            UAN1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xb0);

        /// address: 0x40016cbc
        /// DSI Host Interrupt & Status Register
        /// 0
        pub const DSI_ISR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Acknowledge Error 0
            AE0: u1,
            /// Acknowledge Error 1
            AE1: u1,
            /// Acknowledge Error 2
            AE2: u1,
            /// Acknowledge Error 3
            AE3: u1,
            /// Acknowledge Error 4
            AE4: u1,
            /// Acknowledge Error 5
            AE5: u1,
            /// Acknowledge Error 6
            AE6: u1,
            /// Acknowledge Error 7
            AE7: u1,
            /// Acknowledge Error 8
            AE8: u1,
            /// Acknowledge Error 9
            AE9: u1,
            /// Acknowledge Error 10
            AE10: u1,
            /// Acknowledge Error 11
            AE11: u1,
            /// Acknowledge Error 12
            AE12: u1,
            /// Acknowledge Error 13
            AE13: u1,
            /// Acknowledge Error 14
            AE14: u1,
            /// Acknowledge Error 15
            AE15: u1,
            /// PHY Error 0
            PE0: u1,
            /// PHY Error 1
            PE1: u1,
            /// PHY Error 2
            PE2: u1,
            /// PHY Error 3
            PE3: u1,
            /// PHY Error 4
            PE4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0xbc);

        /// address: 0x40016cc0
        /// DSI Host Interrupt & Status Register
        /// 1
        pub const DSI_ISR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout High-Speed
            /// Transmission
            TOHSTX: u1,
            /// Timeout Low-Power
            /// Reception
            TOLPRX: u1,
            /// ECC Single-bit Error
            ECCSE: u1,
            /// ECC Multi-bit Error
            ECCME: u1,
            /// CRC Error
            CRCE: u1,
            /// Packet Size Error
            PSE: u1,
            /// EoTp Error
            EOTPE: u1,
            /// LTDC Payload Write Error
            LPWRE: u1,
            /// Generic Command Write
            /// Error
            GCWRE: u1,
            /// Generic Payload Write
            /// Error
            GPWRE: u1,
            /// Generic Payload Transmit
            /// Error
            GPTXE: u1,
            /// Generic Payload Read Error
            GPRDE: u1,
            /// Generic Payload Receive
            /// Error
            GPRXE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0xc0);

        /// address: 0x40016cc4
        /// DSI Host Interrupt Enable Register
        /// 0
        pub const DSI_IER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Acknowledge Error 0 Interrupt
            /// Enable
            AE0IE: u1,
            /// Acknowledge Error 1 Interrupt
            /// Enable
            AE1IE: u1,
            /// Acknowledge Error 2 Interrupt
            /// Enable
            AE2IE: u1,
            /// Acknowledge Error 3 Interrupt
            /// Enable
            AE3IE: u1,
            /// Acknowledge Error 4 Interrupt
            /// Enable
            AE4IE: u1,
            /// Acknowledge Error 5 Interrupt
            /// Enable
            AE5IE: u1,
            /// Acknowledge Error 6 Interrupt
            /// Enable
            AE6IE: u1,
            /// Acknowledge Error 7 Interrupt
            /// Enable
            AE7IE: u1,
            /// Acknowledge Error 8 Interrupt
            /// Enable
            AE8IE: u1,
            /// Acknowledge Error 9 Interrupt
            /// Enable
            AE9IE: u1,
            /// Acknowledge Error 10 Interrupt
            /// Enable
            AE10IE: u1,
            /// Acknowledge Error 11 Interrupt
            /// Enable
            AE11IE: u1,
            /// Acknowledge Error 12 Interrupt
            /// Enable
            AE12IE: u1,
            /// Acknowledge Error 13 Interrupt
            /// Enable
            AE13IE: u1,
            /// Acknowledge Error 14 Interrupt
            /// Enable
            AE14IE: u1,
            /// Acknowledge Error 15 Interrupt
            /// Enable
            AE15IE: u1,
            /// PHY Error 0 Interrupt
            /// Enable
            PE0IE: u1,
            /// PHY Error 1 Interrupt
            /// Enable
            PE1IE: u1,
            /// PHY Error 2 Interrupt
            /// Enable
            PE2IE: u1,
            /// PHY Error 3 Interrupt
            /// Enable
            PE3IE: u1,
            /// PHY Error 4 Interrupt
            /// Enable
            PE4IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0xc4);

        /// address: 0x40016cc8
        /// DSI Host Interrupt Enable Register
        /// 1
        pub const DSI_IER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout High-Speed Transmission
            /// Interrupt Enable
            TOHSTXIE: u1,
            /// Timeout Low-Power Reception Interrupt
            /// Enable
            TOLPRXIE: u1,
            /// ECC Single-bit Error Interrupt
            /// Enable
            ECCSEIE: u1,
            /// ECC Multi-bit Error Interrupt
            /// Enable
            ECCMEIE: u1,
            /// CRC Error Interrupt Enable
            CRCEIE: u1,
            /// Packet Size Error Interrupt
            /// Enable
            PSEIE: u1,
            /// EoTp Error Interrupt
            /// Enable
            EOTPEIE: u1,
            /// LTDC Payload Write Error Interrupt
            /// Enable
            LPWREIE: u1,
            /// Generic Command Write Error Interrupt
            /// Enable
            GCWREIE: u1,
            /// Generic Payload Write Error Interrupt
            /// Enable
            GPWREIE: u1,
            /// Generic Payload Transmit Error Interrupt
            /// Enable
            GPTXEIE: u1,
            /// Generic Payload Read Error Interrupt
            /// Enable
            GPRDEIE: u1,
            /// Generic Payload Receive Error Interrupt
            /// Enable
            GPRXEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0xc8);

        /// address: 0x40016cd8
        /// DSI Host Force Interrupt Register
        /// 0
        pub const DSI_FIR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force Acknowledge Error 0
            FAE0: u1,
            /// Force Acknowledge Error 1
            FAE1: u1,
            /// Force Acknowledge Error 2
            FAE2: u1,
            /// Force Acknowledge Error 3
            FAE3: u1,
            /// Force Acknowledge Error 4
            FAE4: u1,
            /// Force Acknowledge Error 5
            FAE5: u1,
            /// Force Acknowledge Error 6
            FAE6: u1,
            /// Force Acknowledge Error 7
            FAE7: u1,
            /// Force Acknowledge Error 8
            FAE8: u1,
            /// Force Acknowledge Error 9
            FAE9: u1,
            /// Force Acknowledge Error 10
            FAE10: u1,
            /// Force Acknowledge Error 11
            FAE11: u1,
            /// Force Acknowledge Error 12
            FAE12: u1,
            /// Force Acknowledge Error 13
            FAE13: u1,
            /// Force Acknowledge Error 14
            FAE14: u1,
            /// Force Acknowledge Error 15
            FAE15: u1,
            /// Force PHY Error 0
            FPE0: u1,
            /// Force PHY Error 1
            FPE1: u1,
            /// Force PHY Error 2
            FPE2: u1,
            /// Force PHY Error 3
            FPE3: u1,
            /// Force PHY Error 4
            FPE4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0xd8);

        /// address: 0x40016cdc
        /// DSI Host Force Interrupt Register
        /// 1
        pub const DSI_FIR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force Timeout High-Speed
            /// Transmission
            FTOHSTX: u1,
            /// Force Timeout Low-Power
            /// Reception
            FTOLPRX: u1,
            /// Force ECC Single-bit Error
            FECCSE: u1,
            /// Force ECC Multi-bit Error
            FECCME: u1,
            /// Force CRC Error
            FCRCE: u1,
            /// Force Packet Size Error
            FPSE: u1,
            /// Force EoTp Error
            FEOTPE: u1,
            /// Force LTDC Payload Write
            /// Error
            FLPWRE: u1,
            /// Force Generic Command Write
            /// Error
            FGCWRE: u1,
            /// Force Generic Payload Write
            /// Error
            FGPWRE: u1,
            /// Force Generic Payload Transmit
            /// Error
            FGPTXE: u1,
            /// Force Generic Payload Read
            /// Error
            FGPRDE: u1,
            /// Force Generic Payload Receive
            /// Error
            FGPRXE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0xdc);

        /// address: 0x40016d00
        /// DSI Host Video Shadow Control
        /// Register
        pub const DSI_VSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update Register
            UR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x100);

        /// address: 0x40016d0c
        /// DSI Host LTDC Current VCID
        /// Register
        pub const DSI_LCVCIDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual Channel ID
            VCID: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x10c);

        /// address: 0x40016d10
        /// DSI Host LTDC Current Color Coding
        /// Register
        pub const DSI_LCCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Coding
            COLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Loosely Packed Enable
            LPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x110);

        /// address: 0x40016d18
        /// DSI Host Low-Power mode Current
        /// Configuration Register
        pub const DSI_LPMCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// VACT Largest Packet Size
            VLPSIZE: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Largest Packet Size
            LPSIZE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x118);

        /// address: 0x40016d38
        /// DSI Host Video mode Current Configuration
        /// Register
        pub const DSI_VMCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video mode Type
            VMT: u2,
            /// Low-Power Vertical Sync time
            /// Enable
            LPVSAE: u1,
            /// Low-power Vertical Back-Porch
            /// Enable
            LPVBPE: u1,
            /// Low-power Vertical Front-Porch
            /// Enable
            LPVFPE: u1,
            /// Low-Power Vertical Active
            /// Enable
            LPVAE: u1,
            /// Low-power Horizontal Back-Porch
            /// Enable
            LPHBPE: u1,
            /// Low-Power Horizontal Front-Porch
            /// Enable
            LPHFE: u1,
            /// Frame BTA Acknowledge
            /// Enable
            FBTAAE: u1,
            /// Low-Power Command Enable
            LPCE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x138);

        /// address: 0x40016d3c
        /// DSI Host Video Packet Current Configuration
        /// Register
        pub const DSI_VPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Packet Size
            VPSIZE: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x13c);

        /// address: 0x40016d40
        /// DSI Host Video Chunks Current Configuration
        /// Register
        pub const DSI_VCCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of Chunks
            NUMC: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x140);

        /// address: 0x40016d44
        /// DSI Host Video Null Packet Current
        /// Configuration Register
        pub const DSI_VNPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Null Packet Size
            NPSIZE: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x144);

        /// address: 0x40016d48
        /// DSI Host Video HSA Current Configuration
        /// Register
        pub const DSI_VHSACCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Synchronism Active
            /// duration
            HSA: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x148);

        /// address: 0x40016d4c
        /// DSI Host Video HBP Current Configuration
        /// Register
        pub const DSI_VHBPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Back-Porch
            /// duration
            HBP: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14c);

        /// address: 0x40016d50
        /// DSI Host Video Line Current Configuration
        /// Register
        pub const DSI_VLCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Line duration
            HLINE: u15,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x150);

        /// address: 0x40016d54
        /// DSI Host Video VSA Current Configuration
        /// Register
        pub const DSI_VVSACCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Synchronism Active
            /// duration
            VSA: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x154);

        /// address: 0x40016d58
        /// DSI Host Video VBP Current Configuration
        /// Register
        pub const DSI_VVBPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Back-Porch
            /// duration
            VBP: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x158);

        /// address: 0x40016d5c
        /// DSI Host Video VFP Current Configuration
        /// Register
        pub const DSI_VVFPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Front-Porch
            /// duration
            VFP: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x15c);

        /// address: 0x40016d60
        /// DSI Host Video VA Current Configuration
        /// Register
        pub const DSI_VVACCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Active duration
            VA: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x160);

        /// address: 0x40017000
        /// DSI Wrapper Configuration
        /// Register
        pub const DSI_WCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DSI Mode
            DSIM: u1,
            /// Color Multiplexing
            COLMUX: u3,
            /// TE Source
            TESRC: u1,
            /// TE Polarity
            TEPOL: u1,
            /// Automatic Refresh
            AR: u1,
            /// VSync Polarity
            VSPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x400);

        /// address: 0x40017004
        /// DSI Wrapper Control Register
        pub const DSI_WCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Mode
            COLM: u1,
            /// Shutdown
            SHTDN: u1,
            /// LTDC Enable
            LTDCEN: u1,
            /// DSI Enable
            DSIEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x404);

        /// address: 0x40017008
        /// DSI Wrapper Interrupt Enable
        /// Register
        pub const DSI_WIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tearing Effect Interrupt
            /// Enable
            TEIE: u1,
            /// End of Refresh Interrupt
            /// Enable
            ERIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// PLL Lock Interrupt Enable
            PLLLIE: u1,
            /// PLL Unlock Interrupt
            /// Enable
            PLLUIE: u1,
            reserved7: u1,
            reserved8: u1,
            /// Regulator Ready Interrupt
            /// Enable
            RRIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x408);

        /// address: 0x4001700c
        /// DSI Wrapper Interrupt & Status
        /// Register
        pub const DSI_WISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tearing Effect Interrupt
            /// Flag
            TEIF: u1,
            /// End of Refresh Interrupt
            /// Flag
            ERIF: u1,
            /// Busy Flag
            BUSY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PLL Lock Status
            PLLLS: u1,
            /// PLL Lock Interrupt Flag
            PLLLIF: u1,
            /// PLL Unlock Interrupt Flag
            PLLUIF: u1,
            reserved5: u1,
            /// Regulator Ready Status
            RRS: u1,
            /// Regulator Ready Interrupt
            /// Flag
            RRIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x40c);

        /// address: 0x40017010
        /// DSI Wrapper Interrupt Flag Clear
        /// Register
        pub const DSI_WIFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear Tearing Effect Interrupt
            /// Flag
            CTEIF: u1,
            /// Clear End of Refresh Interrupt
            /// Flag
            CERIF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Clear PLL Lock Interrupt
            /// Flag
            CPLLLIF: u1,
            /// Clear PLL Unlock Interrupt
            /// Flag
            CPLLUIF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Clear Regulator Ready Interrupt
            /// Flag
            CRRIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x410);

        /// address: 0x40017018
        /// DSI Wrapper PHY Configuration Register
        /// 1
        pub const DSI_WPCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Unit Interval multiplied by
            /// 4
            UIX4: u6,
            /// Swap Clock Lane pins
            SWCL: u1,
            /// Swap Data Lane 0 pins
            SWDL0: u1,
            /// Swap Data Lane 1 pins
            SWDL1: u1,
            /// Invert Hight-Speed data signal on Clock
            /// Lane
            HSICL: u1,
            /// Invert the Hight-Speed data signal on
            /// Data Lane 0
            HSIDL0: u1,
            /// Invert the High-Speed data signal on
            /// Data Lane 1
            HSIDL1: u1,
            /// Force in TX Stop Mode the Clock
            /// Lane
            FTXSMCL: u1,
            /// Force in TX Stop Mode the Data
            /// Lanes
            FTXSMDL: u1,
            /// Contention Detection OFF on Data
            /// Lanes
            CDOFFDL: u1,
            reserved0: u1,
            /// Turn Disable Data Lanes
            TDDL: u1,
            reserved1: u1,
            /// Pull-Down Enable
            PDEN: u1,
            /// custom time for tCLK-PREPARE
            /// Enable
            TCLKPREPEN: u1,
            /// custom time for tCLK-ZERO
            /// Enable
            TCLKZEROEN: u1,
            /// custom time for tHS-PREPARE
            /// Enable
            THSPREPEN: u1,
            /// custom time for tHS-TRAIL
            /// Enable
            THSTRAILEN: u1,
            /// custom time for tHS-ZERO
            /// Enable
            THSZEROEN: u1,
            /// custom time for tLPX for Data lanes
            /// Enable
            TLPXDEN: u1,
            /// custom time for tHS-EXIT
            /// Enable
            THSEXITEN: u1,
            /// custom time for tLPX for Clock lane
            /// Enable
            TLPXCEN: u1,
            /// custom time for tCLK-POST
            /// Enable
            TCLKPOSTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x418);

        /// address: 0x4001701c
        /// DSI Wrapper PHY Configuration Register
        /// 2
        pub const DSI_WPCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// High-Speed Transmission Delay on Clock
            /// Lane
            HSTXDCL: u2,
            /// High-Speed Transmission Delay on Data
            /// Lanes
            HSTXDLL: u2,
            reserved0: u1,
            reserved1: u1,
            /// Low-Power transmission Slew Rate
            /// Compensation on Clock Lane
            LPSRCL: u2,
            /// Low-Power transmission Slew Rate
            /// Compensation on Data Lanes
            LPSRDL: u2,
            reserved2: u1,
            reserved3: u1,
            /// SDD Control
            SDCC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// High-Speed Transmission Slew Rate
            /// Control on Clock Lane
            HSTXSRCCL: u2,
            /// High-Speed Transmission Slew Rate
            /// Control on Data Lanes
            HSTXSRCDL: u2,
            reserved7: u1,
            reserved8: u1,
            /// Forces LP Receiver in Low-Power
            /// Mode
            FLPRXLPM: u1,
            reserved9: u1,
            reserved10: u1,
            /// Low-Power RX low-pass Filtering
            /// Tuning
            LPRXFT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x41c);

        /// address: 0x40017020
        /// DSI Wrapper PHY Configuration Register
        /// 3
        pub const DSI_WPCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// tCLK-PREPARE
            TCLKPREP: u8,
            /// tCLK-ZERO
            TCLKZEO: u8,
            /// tHS-PREPARE
            THSPREP: u8,
            /// tHSTRAIL
            THSTRAIL: u8,
        }), base_address + 0x420);

        /// address: 0x40017024
        /// DSI_WPCR4
        pub const DSI_WPCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// tHS-ZERO
            THSZERO: u8,
            /// tLPX for Data lanes
            TLPXD: u8,
            /// tHSEXIT
            THSEXIT: u8,
            /// tLPXC for Clock lane
            TLPXC: u8,
        }), base_address + 0x424);

        /// address: 0x40017028
        /// DSI Wrapper PHY Configuration Register
        /// 5
        pub const DSI_WPCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// tCLK-POST
            THSZERO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x428);

        /// address: 0x40017030
        /// DSI Wrapper Regulator and PLL Control
        /// Register
        pub const DSI_WRPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL Enable
            PLLEN: u1,
            reserved0: u1,
            /// PLL Loop Division Factor
            NDIV: u7,
            reserved1: u1,
            reserved2: u1,
            /// PLL Input Division Factor
            IDF: u4,
            reserved3: u1,
            /// PLL Output Division Factor
            ODF: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Regulator Enable
            REGEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x430);
    };

    /// MCU debug component
    pub const DBGMCU = struct {
        pub const base_address = 0xe0042000;

        /// address: 0xe0042000
        /// DBGMCU_IDCODE
        pub const IDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device identifier
            DEV_ID: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Revision identifie
            REV_ID: u16,
        }), base_address + 0x0);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
